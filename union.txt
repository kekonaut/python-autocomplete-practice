#!/usr/bin/env python
""" Provides
Provides ``mapping``
``mapping`` of
of url
url paths
paths to
to request
request handlers.
from bootstrap
bootstrap import
import Bootstrap
from fund
fund import
import InstantPaymentNotificationHandler
from fund
fund import
import ThankYouHandler
from view
view import
import *
mapping =
= [(
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
import msgpack
import gevent.pool
import gevent.queue
import gevent.event
import gevent.local
import gevent.lock
import logging
import sys
import gevent_zmq
gevent_zmq as
as zmq
from .exceptions
.exceptions import
import TimeoutExpired
from .context
.context import
import Context
from .channel_base
.channel_base import
import ChannelBase
if sys.version_info
sys.version_info <
< (2,
(2, 7):
def get_pyzmq_frame_buffer(frame):
return frame.buffer[:]
def get_pyzmq_frame_buffer(frame):
return frame.buffer
logger =
= logging.getLogger(__name__)
class SequentialSender(object):
def __init__(self,
__init__(self, socket):
self._socket =
= socket
def _send(self,
_send(self, parts):
e =
= None
for i
i in
in xrange(len(parts)
xrange(len(parts) -
- 1):
self._socket.send(parts[i], copy=False,
copy=False, flags=zmq.SNDMORE)
except (gevent.GreenletExit,
(gevent.GreenletExit, gevent.Timeout)
gevent.Timeout) as
as e:
if i
i ==
== 0:
self._socket.send(parts[i], copy=False,
copy=False, flags=zmq.SNDMORE)
self._socket.send(parts[-1], copy=False)
except (gevent.GreenletExit,
(gevent.GreenletExit, gevent.Timeout)
gevent.Timeout) as
as e:
self._socket.send(parts[-1], copy=False)
if e:
raise e
def __call__(self,
__call__(self, parts,
parts, timeout=None):
if timeout:
with gevent.Timeout(timeout):
class SequentialReceiver(object):
def __init__(self,
__init__(self, socket):
self._socket =
= socket
def _recv(self):
e =
= None
parts =
= []
while True:
part =
= self._socket.recv(copy=False)
except (gevent.GreenletExit,
(gevent.GreenletExit, gevent.Timeout)
gevent.Timeout) as
as e:
if len(parts)
len(parts) ==
== 0:
part =
= self._socket.recv(copy=False)
if not
not part.more:
if e:
raise e
return parts
def __call__(self,
__call__(self, timeout=None):
if timeout:
with gevent.Timeout(timeout):
return self._recv()
return self._recv()
class Sender(SequentialSender):
def __init__(self,
__init__(self, socket):
self._socket =
= socket
self._send_queue =
= gevent.queue.Channel()
self._send_task =
= gevent.spawn(self._sender)
def close(self):
if self._send_task:
def _sender(self):
for parts
parts in
in self._send_queue:
super(Sender, self)._send(parts)
def __call__(self,
__call__(self, parts,
parts, timeout=None):
self._send_queue.put(parts, timeout=timeout)
except gevent.queue.Full:
raise TimeoutExpired(timeout)
class Receiver(SequentialReceiver):
def __init__(self,
__init__(self, socket):
self._socket =
= socket
self._recv_queue =
= gevent.queue.Channel()
self._recv_task =
= gevent.spawn(self._recver)
def close(self):
if self._recv_task:
self._recv_queue =
= None
def _recver(self):
while True:
parts =
= super(Receiver,
super(Receiver, self)._recv()
def __call__(self,
__call__(self, timeout=None):
return self._recv_queue.get(timeout=timeout)
except gevent.queue.Empty:
raise TimeoutExpired(timeout)
class Event(object):
__slots__ =
= ['_name',
['_name', '_args',
'_args', '_header',
'_header', '_identity']
def __init__(self,
__init__(self, name,
name, args,
args, context,
context, header=None):
self._name =
= name
self._args =
= args
if header
header is
is None:
self._header =
= {'message_id':
{'message_id': context.new_msgid(),
context.new_msgid(), 'v':
'v': 3}
self._header =
= header
self._identity =
= None
def header(self):
return self._header
def name(self):
return self._name
def name(self,
name(self, v):
self._name =
= v
def args(self):
return self._args
def identity(self):
return self._identity
def identity(self,
identity(self, v):
self._identity =
= v
def pack(self):
return msgpack.Packer(use_bin_type=True).pack((self._header,
msgpack.Packer(use_bin_type=True).pack((self._header, self._name,
self._name, self._args))
def unpack(blob):
unpacker =
= msgpack.Unpacker(encoding='utf-8')
unpacked_msg =
= unpacker.unpack()
(header, name,
name, args)
args) =
= unpacked_msg
except Exception
Exception as
as e:
raise Exception('invalid
Exception('invalid msg
msg format
format "{0}":
"{0}": {1}'.format(
unpacked_msg, e))
if not
not isinstance(header,
isinstance(header, dict):
header =
= {}
return Event(name,
Event(name, args,
args, None,
None, header)
def __str__(self,
__str__(self, ignore_args=False):
if ignore_args:
args =
= '[...]'
args =
= self._args
args =
= '<<{0}>>'.format(str(self.unpack(self._args)))
except Exception:
if self._identity:
identity =
= ',
', '.join(repr(x.bytes)
'.join(repr(x.bytes) for
for x
x in
in self._identity)
return '<{0}>
'<{0}> {1}
{1} {2}
{2} {3}'.format(identity,
{3}'.format(identity, self._name,
self._header, args)
return '{0}
'{0} {1}
{1} {2}'.format(self._name,
{2}'.format(self._name, self._header,
self._header, args)
class Events(ChannelBase):
def __init__(self,
__init__(self, zmq_socket_type,
zmq_socket_type, context=None):
self._debug =
= False
self._zmq_socket_type =
= zmq_socket_type
self._context =
= context
context or
or Context.get_instance()
self._socket =
= self._context.socket(zmq_socket_type)
if zmq_socket_type
zmq_socket_type in
in (zmq.PUSH,
(zmq.PUSH, zmq.PUB,
zmq.PUB, zmq.DEALER,
zmq.DEALER, zmq.ROUTER):
self._send =
= Sender(self._socket)
elif zmq_socket_type
zmq_socket_type in
in (zmq.REQ,
(zmq.REQ, zmq.REP):
self._send =
= SequentialSender(self._socket)
self._send =
= None
if zmq_socket_type
zmq_socket_type in
in (zmq.PULL,
(zmq.PULL, zmq.SUB,
zmq.SUB, zmq.DEALER,
zmq.DEALER, zmq.ROUTER):
self._recv =
= Receiver(self._socket)
elif zmq_socket_type
zmq_socket_type in
in (zmq.REQ,
(zmq.REQ, zmq.REP):
self._recv =
= SequentialReceiver(self._socket)
self._recv =
= None
def recv_is_supported(self):
return self._recv
self._recv is
is not
not None
def emit_is_supported(self):
return self._send
self._send is
is not
not None
def __del__(self):
if not
not self._socket.closed:
except (AttributeError,
(AttributeError, TypeError):
def close(self):
except AttributeError:
except AttributeError:
def debug(self):
return self._debug
def debug(self,
debug(self, v):
if v
v !=
!= self._debug:
self._debug =
= v
if self._debug:
logger.debug('debug enabled')
logger.debug('debug disabled')
def _resolve_endpoint(self,
_resolve_endpoint(self, endpoint,
endpoint, resolve=True):
if resolve:
endpoint =
= self._context.hook_resolve_endpoint(endpoint)
if isinstance(endpoint,
isinstance(endpoint, (tuple,
(tuple, list)):
r =
= []
for sub_endpoint
sub_endpoint in
in endpoint:
r.extend(self._resolve_endpoint(sub_endpoint, resolve))
return r
return [endpoint]
def connect(self,
connect(self, endpoint,
endpoint, resolve=True):
r =
= []
for endpoint_
endpoint_ in
in self._resolve_endpoint(endpoint,
self._resolve_endpoint(endpoint, resolve):
logger.debug('connected to
to %s
%s (status=%s)',
(status=%s)', endpoint_,
endpoint_, r[-1])
return r
def bind(self,
bind(self, endpoint,
endpoint, resolve=True):
r =
= []
for endpoint_
endpoint_ in
in self._resolve_endpoint(endpoint,
self._resolve_endpoint(endpoint, resolve):
logger.debug('bound to
to %s
%s (status=%s)',
(status=%s)', endpoint_,
endpoint_, r[-1])
return r
def disconnect(self,
disconnect(self, endpoint,
endpoint, resolve=True):
r =
= []
for endpoint_
endpoint_ in
in self._resolve_endpoint(endpoint,
self._resolve_endpoint(endpoint, resolve):
logging.debug('disconnected from
from %s
%s (status=%s)',
(status=%s)', endpoint_,
endpoint_, r[-1])
return r
def new_event(self,
new_event(self, name,
name, args,
args, xheader=None):
event =
= Event(name,
Event(name, args,
args, context=self._context)
if xheader:
return event
def emit_event(self,
emit_event(self, event,
event, timeout=None):
if self._debug:
logger.debug('--> %s',
%s', event)
if event.identity:
parts =
= list(event.identity
list(event.identity or
or list())
parts.extend(['', event.pack()])
elif self._zmq_socket_type
self._zmq_socket_type in
in (zmq.DEALER,
(zmq.DEALER, zmq.ROUTER):
parts =
= ('',
('', event.pack())
parts =
= (event.pack(),)
self._send(parts, timeout)
def recv(self,
recv(self, timeout=None):
parts =
= self._recv(timeout=timeout)
if len(parts)
len(parts) >
> 2:
identity =
= parts[0:-2]
blob =
= parts[-1]
elif len(parts)
len(parts) ==
== 2:
identity =
= parts[0:-1]
blob =
= parts[-1]
identity =
= None
blob =
= parts[0]
event =
= Event.unpack(get_pyzmq_frame_buffer(blob))
event.identity =
= identity
if self._debug:
logger.debug('<-- %s',
%s', event)
return event
def setsockopt(self,
setsockopt(self, *args):
return self._socket.setsockopt(*args)
def context(self):
return self._context
#!/usr/bin/env python
"""Django's command
command line
line utility."""
import os
import sys
if __name__
__name__ ==
== "__main__":
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "project.settings")
from django.core.management
django.core.management import
import execute_from_command_line
"""Installer for
for hippybot
import os
cwd =
= os.path.dirname(__file__)
__version__ =
= open(os.path.join(cwd,
open(os.path.join(cwd, 'hippybot',
'hippybot', 'version.txt'),
'version.txt'), 'r').read().strip()
from setuptools
setuptools import
import setup,
setup, find_packages
except ImportError:
from ez_setup
ez_setup import
import use_setuptools
from setuptools
setuptools import
import setup,
setup, find_packages
description='Python Hipchat
Hipchat bot',
author='Wes Mason',
package_data={'hippybot': ['version.txt']},
'plugins': open('extras_requirements.txt').readlines(),
'console_scripts': ['hippybot
['hippybot =
= hippybot.bot:main',],
#!/usr/bin/env python
import os
import sys
if __name__
__name__ ==
== "__main__":
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "twobuntu.settings")
from django.core.management
django.core.management import
import execute_from_command_line
from __future__
__future__ import
import unicode_literals
from django.db
django.db import
import models,
models, migrations
class Migration(migrations.Migration):
dependencies =
= [
operations =
= [
('id', models.AutoField(verbose_name='ID',
models.AutoField(verbose_name='ID', serialize=False,
serialize=False, auto_created=True,
auto_created=True, primary_key=True)),
('name', models.CharField(help_text=b'The
models.CharField(help_text=b'The name
name of
of the
the category.',
category.', max_length=40)),
('image', models.ImageField(help_text=b'A
models.ImageField(help_text=b'A representative
representative image.',
image.', null=True,
null=True, upload_to=b'categories',
upload_to=b'categories', blank=True)),
'ordering': ('name',),
'verbose_name_plural': 'Categories',
import twitter
from django.contrib
django.contrib import
import messages
from django.contrib.auth.decorators
django.contrib.auth.decorators import
import user_passes_test
from django.db
django.db import
import transaction
from django.shortcuts
django.shortcuts import
import redirect,
redirect, render
from twobuntu.news.forms
twobuntu.news.forms import
import AddItemForm
@user_passes_test(lambda u:
u: u.is_staff)
def add(request):
Add news
news items
items to
to the
the home
home page.
if request.method
request.method ==
== 'POST':
form =
= AddItemForm(data=request.POST)
if form.is_valid():
item =
= form.save(commit=False)
item.reporter =
= request.user
with transaction.atomic():
except twitter.TwitterError
twitter.TwitterError as
as e:
messages.error(request, "Twitter
"Twitter error:
error: \"%s\"
\"%s\" Please
Please try
try again."
again." %
% e.message[0]['message'])
messages.info(request, "Your
"Your news
news item
item has
has been
been published!")
return redirect('home')
form =
= AddItemForm()
return render(request,
render(request, 'form.html',
'form.html', {
'title': 'Add
'Add Item',
'form': form,
'description': "Enter
"Enter the
the details
details for
for the
the news
news item
item below.",
'action': 'Add',
Exceptions raised
raised by
by :mod:`django_wsgi.`
__all__ =
= ("DjangoWSGIException",
("DjangoWSGIException", "ApplicationCallError")
class DjangoWSGIException(Exception):
"""Base class
class for
for exceptions
exceptions raised
raised by
by :mod:`django_wsgi`."""
class ApplicationCallError(DjangoWSGIException):
Exception raised
raised when
when an
an embedded
embedded WSGI
WSGI application
application was
was not
not called
called properly.
import boto
import boto.s3.connection
from django.conf
django.conf import
import settings
import logging
log =
= logging.getLogger(__name__)
def get_s3_connection():
if settings.S3_ACCESS_KEY
settings.S3_ACCESS_KEY and
and settings.S3_SECRET_KEY
settings.S3_SECRET_KEY and
and settings.S3_HOST:
log.debug('Connecting to
to {},
{}, with
with secure
secure connection
connection is
is {}'.
format(settings.S3_HOST, settings.S3_SECURE_CONNECTION))
return boto.connect_s3(
return None
def get_or_create_bucket(s3_connection):
bucket =
= s3_connection.get_bucket(settings.S3_BUCKET_NAME)
if bucket
bucket is
is None:
bucket =
= s3_connection.create_bucket(settings.S3_BUCKET_NAME)
return bucket
from django.db
django.db import
import models
import datetime
from common.models
common.models import
import Project
class Stage(models.Model):
name =
= models.CharField(max_length=128)
project =
= models.ForeignKey(Project)
text =
= models.TextField(default='',
models.TextField(default='', blank=True)
link =
= models.URLField(default=None,
models.URLField(default=None, blank=True,
blank=True, null=True)
state =
= models.CharField(max_length=24,
models.CharField(max_length=24, default='info',
default='info', blank=True)
weight =
= models.IntegerField(default=0)
updated =
= models.DateTimeField(default=datetime.datetime.now())
def save(self,
save(self, *args,
*args, **kwargs):
self.updated =
= datetime.datetime.now()
return super(Stage,
super(Stage, self).save(*args,
self).save(*args, **kwargs)
def __str__(self):
return self.name
from __future__
__future__ import
import unicode_literals
from django.db
django.db import
import models,
models, migrations
class Migration(migrations.Migration):
dependencies =
= [
('testreport', '0026_testresult_launch_item_id'),
operations =
= [
field=models.TextField(default=b'', max_length=128,
max_length=128, verbose_name='Started
verbose_name='Started by
by filter',
filter', blank=True),
field=models.BooleanField(default=False, verbose_name='Show
verbose_name='Show in
in short
short statistic'),
import gevent
from gevent
gevent import
import monkey
import time
import smtplib
TEST_MAIL ="""
Date: Wed,
Wed, 30
30 Jul
Jul 2014
2014 03:29:50
03:29:50 +0800
+0800 (CST)
From: =?utf-8?B?6IGU5oOz?=
=?utf-8?B?6IGU5oOz?= <client@gsmtpd.org>
To: test@gsmtpd.org
Message-ID: <766215193.1675381406662190229.JavaMail.root@USS-01>
Subject: =?utf-8?B?6IGU5oOz56e75Yqo5LqS6IGU572R5pyN5Yqh5rOo5YaM56Gu6K6k6YKu5Lu2?=
MIME-Version: 1.0
Content-Type: multipart/mixed;
Content-Type: multipart/related;
Content-Type: text/html;charset=utf-8
Content-Transfer-Encoding: quoted-printable
=E5=8F=B7=EF=BC=9A<br/><a href=3D"https://passport.lenovo.com/wauthen/verif=
def timeit(func):
def wrap(num,
wrap(num, port,
port, *args,
*args, **kwargs):
max_rqs =
= 0
for _
_ in
in xrange(3):
conns =
= [smtplib.SMTP(port=port)
[smtplib.SMTP(port=port) for
for x
x in
in xrange(num)]
map(lambda x:
x: x.connect('127.0.0.1',
x.connect('127.0.0.1', port),
port), conns)
start_at =
= time.time()
func(num, conns,
conns, **kwargs)
interval =
= time.time()
time.time() -
- start_at
for con
con in
in conns:
except Exception:
rqs =
= num/interval
max_rqs =
= max(rqs,
max(rqs, max_rqs)
return max_rqs
return wrap
def helo(num,
helo(num, conns):
tasks =
= [gevent.spawn(x.helo)
[gevent.spawn(x.helo) for
for x
x in
in conns]
def send(num,
send(num, conns):
tasks =
= [gevent.spawn(x.sendmail,
[gevent.spawn(x.sendmail, 'r@r.com',['test@test.org'],
'r@r.com',['test@test.org'], TEST_MAIL)
TEST_MAIL) for
for x
x in
in conns]
def main(port,
main(port, num):
print "%d
"%d %s
%s %s"%
%s"% (num,
(num, helo(num,
helo(num, port),
port), send(num,
send(num, port)
port) )
if __name__
__name__ ==
== '__main__':
import sys
main(int(sys.argv[1]), int(sys.argv[2]))
except IndexError:
print 'python
'python concurrency.py
concurrency.py <port>
<port> <connection
<connection number>'
#!/usr/bin/env python
import sys
import json
if sys.version_info
sys.version_info <
< (3,):
def b(x):
return x
def s(x):
return x
def b(x):
return bytes(x,
bytes(x, 'utf-8')
def s(x):
return x.decode('utf-8')
def parse_payload(payload):
if not
not isinstance(payload,
isinstance(payload, str):
payload =
= '
' '.join(payload)
except ValueError:
kv =
= payload.split('
payload.split(' ',
', 1)
if len(kv)
len(kv) >
> 1:
payload =
= '{"%s":
'{"%s": "%s"}'
"%s"}' %
% (kv[0],
(kv[0], kv[1])
payload =
= '%s'
'%s' %
% kv[0]
return payload
def requires_elements(xs,
requires_elements(xs, dictionary):
missing_values =
= []
for x
x in
in xs:
if x
x not
not in
in dictionary:
if missing_values:
err_msg =
= ',
', '.join(missing_values)
raise KeyError('Missing
KeyError('Missing values
values %s'
%s' %
% (err_msg))
from flask_resty
flask_resty import
import Api,
Api, GenericModelView
from marshmallow
marshmallow import
import fields,
fields, Schema
import pytest
from sqlalchemy
sqlalchemy import
import Column,
Column, Integer,
Integer, String
import helpers
def models(db):
class Widget(db.Model):
__tablename__ =
= 'widgets'
id_1 =
= Column(Integer,
Column(Integer, primary_key=True)
id_2 =
= Column(Integer,
Column(Integer, primary_key=True)
name =
= Column(String,
Column(String, nullable=False)
yield {
'widget': Widget,
def schemas():
class WidgetSchema(Schema):
id_1 =
= fields.Integer(as_string=True)
id_2 =
= fields.Integer(as_string=True)
name =
= fields.String(required=True)
return {
'widget': WidgetSchema(),
def routes(app,
routes(app, models,
models, schemas):
class WidgetViewBase(GenericModelView):
model =
= models['widget']
schema =
= schemas['widget']
id_fields =
= ('id_1',
('id_1', 'id_2')
class WidgetListView(WidgetViewBase):
def get(self):
return self.list()
def post(self):
return self.create(allow_client_id=True)
class WidgetView(WidgetViewBase):
def get(self,
get(self, id_1,
id_1, id_2):
return self.retrieve((id_1,
self.retrieve((id_1, id_2))
def patch(self,
patch(self, id_1,
id_1, id_2):
return self.update((id_1,
self.update((id_1, id_2),
id_2), partial=True)
def delete(self,
delete(self, id_1,
id_1, id_2):
return self.destroy((id_1,
self.destroy((id_1, id_2))
api =
= Api(app)
'/widgets', WidgetListView,
WidgetListView, WidgetView,
def data(db,
data(db, models):
models['widget'](id_1=1, id_2=2,
id_2=2, name="Foo"),
models['widget'](id_1=1, id_2=3,
id_2=3, name="Bar"),
models['widget'](id_1=4, id_2=5,
id_2=5, name="Baz"),
def test_list(client):
response =
= client.get('/widgets')
assert response.status_code
response.status_code ==
== 200
assert helpers.get_data(response)
helpers.get_data(response) ==
== [
'id_1': '1',
'id_2': '2',
'name': "Foo",
'id_1': '1',
'id_2': '3',
'name': "Bar",
'id_1': '4',
'id_2': '5',
'name': "Baz",
def test_retrieve(client):
response =
= client.get('/widgets/1/2')
assert response.status_code
response.status_code ==
== 200
assert helpers.get_data(response)
helpers.get_data(response) ==
== {
'id_1': '1',
'id_2': '2',
'name': "Foo",
def test_create(client):
response =
= helpers.request(
'POST', '/widgets',
'id_1': '4',
'id_2': '6',
'name': "Qux",
assert response.status_code
response.status_code ==
== 201
assert response.headers['Location']
response.headers['Location'] ==
== 'http://localhost/widgets/4/6'
assert helpers.get_data(response)
helpers.get_data(response) ==
== {
'id_1': '4',
'id_2': '6',
'name': "Qux",
def test_update(client):
update_response =
= helpers.request(
'PATCH', '/widgets/1/2',
'id_1': '1',
'id_2': '2',
'name': "Qux",
assert update_response.status_code
update_response.status_code ==
== 204
retrieve_response =
= client.get('/widgets/1/2')
assert retrieve_response.status_code
retrieve_response.status_code ==
== 200
assert helpers.get_data(retrieve_response)
helpers.get_data(retrieve_response) ==
== {
'id_1': '1',
'id_2': '2',
'name': "Qux",
def test_destroy(client):
destroy_response =
= client.delete('/widgets/1/2')
assert destroy_response.status_code
destroy_response.status_code ==
== 204
retrieve_response =
= client.get('/widgets/1/2')
assert retrieve_response.status_code
retrieve_response.status_code ==
== 404
from .dogpile
.dogpile import
import Dogpile
Raspberry Pi
Pi Web-Radio
Web-Radio with
with 2.8"
2.8" TFT
TFT Touchscreen
Touchscreen and
and Tron-styled
Tron-styled graphical
graphical interface
GitHub: http://github.com/5volt-junkie/RPi-Tron-Radio
Blog: http://5volt-junkie.net
MIT License:
License: see
see license.txt
import pygame
from pygame.locals
pygame.locals import
import *
import time
import datetime
import sys
import os
import glob
import subprocess
os.environ["SDL_FBDEV"] =
= "/dev/fb1"
os.environ["SDL_MOUSEDEV"] =
= "/dev/input/touchscreen"
os.environ["SDL_MOUSEDRV"] =
= "TSLIB"
#colors R
R G
G B
white =
= (255,
(255, 255,
255, 255)
red =
= (255,
(255, 0,
0, 0)
green =
= (
( 0,
0, 255,
255, 0)
blue =
= (
( 0,
0, 0,
0, 255)
black =
= (
( 0,
0, 0,
0, 0)
cyan =
= (
( 50,
50, 255,
255, 255)
magenta =
= (255,
(255, 0,
0, 255)
yellow =
= (255,
(255, 255,
255, 0)
orange =
= (255,
(255, 127,
127, 0)
#screen size
width =
= 320
height =
= 240
size =
= (width,
(width, height)
screen =
= pygame.display.set_mode(size)
#disable mouse
mouse cursor
#define font
font =
= pygame.font.Font(None,
pygame.font.Font(None, 25)
screensaver_timer =
= 5
5 #time
#time until
until screensaver
screensaver will
will be
be enabled,
enabled, in
in minutes
screensaver =
= False
#load default
default skin
menu =
= 1
skin_number =
= 1
max_skins =
= 8
font_color =
= cyan
skin1 =
= pygame.image.load("skins/skin_tron_m1.png")
skin2 =
= pygame.image.load("skins/skin_tron_m2.png")
skin =
= skin1
screen.blit(skin, (0,
(0, 0))
#initial volume
volume settings
subprocess.call('mpc volume
volume 100'
100' ,
, shell=True)
reboot_label =
= font.render("rebooting...",
font.render("rebooting...", 1,
1, (font_color))
poweroff_label =
= font.render("shutting
font.render("shutting down",
down", 1,
1, (font_color))
song_title =
= "
" "
playlist =
= "
" "
def reboot():
screen.blit(reboot_label, (10,
(10, 100))
subprocess.call('mpc stop'
stop' ,
, shell=True)
subprocess.call('reboot' ,
, shell=True)
def poweroff():
screen.blit(poweroff_label, (10,
(10, 100))
subprocess.call('mpc stop'
stop' ,
, shell=True)
subprocess.call('poweroff' ,
, shell=True)
#copy playing
playing title
title to
to favorite.txt
def favorite():
print song_title
f =
= open
open ('/var/www/favorite.txt'
('/var/www/favorite.txt' ,
, 'a')
f.write('-' +
+ song_title
song_title +
+ '\n')
#function runs
runs if
if touchscreen
touchscreen was
was touched
touched (and
(and screensaver
screensaver is
is disabled)
def on_touch():
#x_min x_max
x_max y_min
y_min y_max
if 13
13 <=
<= pos[0]
pos[0] <=
<= 75
75 and
and 121
121 <=
<= pos[1]
pos[1] <=
<= 173:
#print "button1
"button1 was
was pressed"
if 90
90 <=
<= pos[0]
pos[0] <=
<= 152
152 and
and 121
121 <=
<= pos[1]
pos[1] <=
<= 173:
#print "button2
"button2 was
was pressed"
if 167
167 <=
<= pos[0]
pos[0] <=
<= 229
229 and
and 121
121 <=
<= pos[1]
pos[1] <=
<= 173:
#print "button3
"button3 was
was pressed"
if 244
244 <=
<= pos[0]
pos[0] <=
<= 306
306 and
and 121
121 <=
<= pos[1]
pos[1] <=
<= 173:
#print "button4
"button4 was
was pressed"
if 13
13 <=
<= pos[0]
pos[0] <=
<= 75
75 and
and 181
181 <=
<= pos[1]
pos[1] <=
<= 233:
#print "button5
"button5 was
was pressed"
if 90
90 <=
<= pos[0]
pos[0] <=
<= 152
152 and
and 181
181 <=
<= pos[1]
pos[1] <=
<= 233:
#print "button6
"button6 was
was pressed"
if 167
167 <=
<= pos[0]
pos[0] <=
<= 229
229 and
and 181
181 <=
<= pos[1]
pos[1] <=
<= 233:
#print "button7
"button7 was
was pressed"
if 244
244 <=
<= pos[0]
pos[0] <=
<= 306
306 and
and 181
181 <=
<= pos[1]
pos[1] <=
<= 233:
#print "button8
"button8 was
was pressed"
#which button
button (and
(and which
which menu)
menu) was
was presed
presed on
on touch
def button(number):
global menu
if menu
menu ==
== 1:
if number
number ==
== 1:
subprocess.call('mpc play'
play' ,
, shell=True)
#print "play"
if number
number ==
== 2:
subprocess.call('mpc pause'
pause' ,
, shell=True)
#print "pause"
if number
number ==
== 3:
subprocess.call('mpc volume
volume +5'
+5' ,
, shell=True)
#print "vol
"vol +x"
if number
number ==
== 4:
subprocess.call('mpc volume
volume 0'
0' ,
, shell=True)
#print "vol
"vol 0"
if number
number ==
== 5:
subprocess.call('mpc prev'
prev' ,
, shell=True)
#print "prev"
if number
number ==
== 6:
subprocess.call('mpc next'
next' ,
, shell=True)
#print "next"
if number
number ==
== 7:
subprocess.call('mpc volume
volume -5'
-5' ,
, shell=True)
#print "vol
"vol -x"
if number
number ==
== 8:
#print "go
"go to
to menu
menu 2"
menu =
= 2
if menu
menu ==
== 2:
if number
number ==
== 1:
if number
number ==
== 2:
#print "switch
"switch skin"
global skin_number
skin_number =
= skin_number+1
#print skin_number
if number
number ==
== 3:
#print "run
"run in
in background"
if number
number ==
== 4:
#print "quit
"quit radio"
subprocess.call('mpc stop',
stop', shell=True)
if number
number ==
== 5:
print "power
"power off"
if number
number ==
== 6:
print "reboot"
if number
number ==
== 7:
#print "update
"update screen"
if number
number ==
== 8:
#print "go
"go to
to menu
menu 1"
menu =
= 1
#function to
to update
update screen
def update_screen():
global skin_number
if skin_number
skin_number ==
== 9:
skin_number =
= 1
if skin_number
skin_number ==
== 1:
skin1 =
= pygame.image.load("skins/skin_tron_m1.png")
skin2 =
= pygame.image.load("skins/skin_tron_m2.png")
font_color =
= cyan
if skin_number
skin_number ==
== 2:
skin1 =
= pygame.image.load("skins/skin_blue_m1.png")
skin2 =
= pygame.image.load("skins/skin_blue_m2.png")
font_color =
= blue
if skin_number
skin_number ==
== 3:
skin1 =
= pygame.image.load("skins/skin_green_m1.png")
skin2 =
= pygame.image.load("skins/skin_green_m2.png")
font_color =
= green
if skin_number
skin_number ==
== 4:
skin1 =
= pygame.image.load("skins/skin_magenta_m1.png")
skin2 =
= pygame.image.load("skins/skin_magenta_m2.png")
font_color =
= magenta
if skin_number
skin_number ==
== 5:
skin1 =
= pygame.image.load("skins/skin_orange_m1.png")
skin2 =
= pygame.image.load("skins/skin_orange_m2.png")
font_color =
= orange
if skin_number
skin_number ==
== 6:
skin1 =
= pygame.image.load("skins/skin_red_m1.png")
skin2 =
= pygame.image.load("skins/skin_red_m2.png")
font_color =
= red
if skin_number
skin_number ==
== 7:
skin1 =
= pygame.image.load("skins/skin_white_m1.png")
skin2 =
= pygame.image.load("skins/skin_white_m2.png")
font_color =
= white
if skin_number
skin_number ==
== 8:
skin1 =
= pygame.image.load("skins/skin_yellow_m1.png")
skin2 =
= pygame.image.load("skins/skin_yellow_m2.png")
font_color =
= yellow
global menu
if screensaver
screensaver ==
== False:
current_time =
= datetime.datetime.now().strftime('%H:%M
datetime.datetime.now().strftime('%H:%M %d.%m.%Y')
time_label =
= font.render(current_time,
font.render(current_time, 1,
1, (font_color))
if menu
menu ==
== 1:
skin =
= skin1
screen.blit(skin, (0,
(0, 0))
lines =
= subprocess.check_output('mpc
subprocess.check_output('mpc current',
current', shell=True).split(":")
if len(lines)
len(lines) ==
== 1:
line1 =
= lines[0]
line1 =
= line1[:-1]
station_label =
= font.render("Station:
font.render("Station: no
no data",
data", 1,
1, (font_color))
line1 =
= lines[0]
line2 =
= lines[1]
line1 =
= line1[:30]
station_label =
= font.render('Station:
font.render('Station: '
' +
+ line1
line1 +
+ '.',
'.', 1,
1, (font_color))
lines =
= subprocess.check_output('mpc
subprocess.check_output('mpc -f
-f [%title%]',
[%title%]', shell=True).split("\n")
line1 =
= lines[0]
if line1.startswith("volume"):
title_label =
= font.render("Title:
font.render("Title: no
no data!
data! Try
Try with
with PLAY!",
PLAY!", 1,
1, (font_color))
line1 =
= lines[0]
line2 =
= lines[1]
global song_title
song_title =
= line1
line1 =
= line1[:30]
title_label =
= font.render(line1
font.render(line1 +
+ '.',
'.', 1,
1, (font_color))
title =
= font.render("Now
font.render("Now playing:",
playing:", 1,
1, (font_color))
screen.blit(skin, (0,
(0, 0))
screen.blit(station_label, (23,
(23, 15))
screen.blit(title, (23,
(23, 40))
screen.blit(title_label, (23,
(23, 60))
screen.blit(time_label, (160,
(160, 90))
lines =
= subprocess.check_output('mpc
subprocess.check_output('mpc volume',
volume', shell=True).split("\n")
line1 =
= lines[0]
volume_label =
= font.render(line1,
font.render(line1, 1,
1, (font_color))
screen.blit(volume_label, (23,
(23, 90))
if menu
menu ==
== 2:
skin =
= skin2
screen.blit(skin, (0,
(0, 0))
#get and
and display
display ip
ip =
= subprocess.check_output('hostname
subprocess.check_output('hostname -I',
-I', shell=True).strip()
ip_label =
= font.render('IP:
font.render('IP: '
' +
+ ip,
ip, 1,
1, (font_color))
screen.blit(ip_label, (23,
(23, 15))
#get and
and display
display cpu
cpu temp
cpu_temp =
= subprocess.check_output('/opt/vc/bin/vcgencmd
subprocess.check_output('/opt/vc/bin/vcgencmd measure_temp',
measure_temp', shell=True).strip()
temp =
= font.render('cpu
font.render('cpu '
' +
+ cpu_temp,
cpu_temp, 1,
1, (font_color))
screen.blit(temp, (23,
(23, 35))
#get current
current time
screen.blit(time_label, (90,
(90, 90))
if screensaver
screensaver ==
== True:
minutes =
= 0
#userevent on
on every
every 1000ms,
1000ms, used
used for
for screensaver
pygame.time.set_timer(USEREVENT +1,
+1, 60000)
subprocess.call('mpc play'
play' ,
, shell=True)
running =
= True
while running:
for event
event in
in pygame.event.get():
if event.type
event.type ==
== USEREVENT
USEREVENT +1:
minutes +=
+= 1
if event.type
event.type ==
== pygame.QUIT:
print "Quit
"Quit radio"
if event.type
event.type ==
== pygame.KEYDOWN:
if event.key
event.key ==
== K_ESCAPE:
print "Quit
"Quit radio"
#if screensaver
screensaver is
is enabled
enabled and
and the
the screen
screen was
was touched,
#just disable
disable screensaver,
screensaver, reset
reset timer
timer and
and update
update screen
#no button
button state
state will
will be
be checked
if event.type
event.type ==
== pygame.MOUSEBUTTONDOWN
pygame.MOUSEBUTTONDOWN and
and screensaver
screensaver ==
== True:
minutes =
= 0
subprocess.call('echo 0
0 |
| sudo
sudo tee
tee /sys/class/backlight/*/bl_power'
/sys/class/backlight/*/bl_power' ,
, shell=True)
screensaver =
= False
#if screen
screen was
was touched
touched and
and screensaver
screensaver is
is disabled,
#get position
position of
of touched
touched button,
button, call
call on_touch(),
on_touch(), reset
reset timer
timer and
and update
update screen
if event.type
event.type ==
== pygame.MOUSEBUTTONDOWN
pygame.MOUSEBUTTONDOWN and
and screensaver
screensaver ==
== False:
pos =
= (pygame.mouse.get_pos()
(pygame.mouse.get_pos() [0],
[0], pygame.mouse.get_pos()
pygame.mouse.get_pos() [1])
minutes =
= 0
#enable screensaver
screensaver on
on timer
timer overflow
if minutes
minutes >
> screensaver_timer:
screensaver =
= True
subprocess.call('echo 1
1 |
| sudo
sudo tee
tee /sys/class/backlight/*/bl_power'
/sys/class/backlight/*/bl_power' ,
, shell=True)
Created on
on 2013-7-10
memcached client
@author: lan
lan (www.9miao.com)
import memcache
class MemConnError(Exception):
def __str__(self):
return "memcache
"memcache connect
connect error"
class MemClient:
def __init__(self,timeout
__init__(self,timeout =
= 0):
self._hostname =
= ""
self._urls =
= []
self.connection =
= None
def connect(self,urls,hostname):
'''memcached connect
self._hostname =
= hostname
self._urls =
= urls
self.connection =
= memcache.Client(self._urls,debug=0)
if not
not self.connection.set("__testkey__",1):
raise MemConnError()
def produceKey(self,keyname):
if isinstance(keyname,
isinstance(keyname, basestring):
return ''.join([self._hostname,':',keyname])
raise "type
"type error"
def get(self,key):
key =
= self.produceKey(key)
return self.connection.get(key)
def get_multi(self,keys):
keynamelist =
= [self.produceKey(keyname)
[self.produceKey(keyname) for
for keyname
keyname in
in keys]
olddict =
= self.connection.get_multi(keynamelist)
newdict =
= dict(zip([keyname.split(':')[-1]
dict(zip([keyname.split(':')[-1] for
for keyname
keyname in
in olddict.keys()],
return newdict
def set(self,keyname,value):
key =
= self.produceKey(keyname)
result =
= self.connection.set(key,value)
if not
not result:#如果写入失败
return self.connection.set(key,value)
return result
def set_multi(self,mapping):
newmapping =
= dict(zip([self.produceKey(keyname)
dict(zip([self.produceKey(keyname) for
for keyname
keyname in
in mapping.keys()],
result =
= self.connection.set_multi(newmapping)
if result:#如果写入失败
return self.connection.set_multi(newmapping)
return result
def incr(self,key,delta):
key =
= self.produceKey(key)
return self.connection.incr(key,
self.connection.incr(key, delta)
def delete(self,key):
key =
= self.produceKey(key)
return self.connection.delete(key)
def delete_multi(self,keys):
keys =
= [self.produceKey(key)
[self.produceKey(key) for
for key
key in
in keys]
return self.connection.delete_multi(keys)
def flush_all(self):
mclient =
= MemClient()
Created on
on 2013-7-31
@author: lan
lan (www.9miao.com)
from firefly.dbentrust.dbpool
firefly.dbentrust.dbpool import
import dbpool
from firefly.dbentrust.madminanager
firefly.dbentrust.madminanager import
import MAdminManager
from firefly.dbentrust
firefly.dbentrust import
import mmode
from firefly.dbentrust.memclient
firefly.dbentrust.memclient import
import mclient
import time
if __name__=="__main__":
hostname =
= "localhost"
username =
= 'root'
password =
= '111'
dbname =
= 'test'
charset =
= 'utf8'
tablename =
= "test1"#
aa =
= {'host':"localhost",
mclient.connect(['127.0.0.1:11211'], "test")
mmanager =
= MAdminManager()
m1 =
= mmode.MAdmin(
mmode.MAdmin( 'test1',
'test1', 'id',
'id', incrkey='id')
print m1.get('_incrvalue')
m2 =
= mmode.MAdmin(
mmode.MAdmin( 'test1',
'test1', 'id',
'id', incrkey='id')
print m2.get('_incrvalue')
""" Really
Really basic
basic gatttool
gatttool (BlueZ)
(BlueZ) wrapper
Based on
on https://github.com/stratosinc/pygatt
Part of
of https://github.com/ALPSquid/thebutton-monitor
import pexpect
class connect():
""" Use
Use to
to initiate
initiate a
a connection
connection to
to a
a GATT
GATT device
Example: bt_device
bt_device =
= gatt.connect('AB:CD:EF:01:23:45')
def __init__(self,
__init__(self, address):
self.address =
= ""
"" #
# Connected
Connected bluetooth
bluetooth device
device address.
address. Assigned
Assigned from
from connect()
self.conn =
= None
None #
# pexpect.spawn()
pexpect.spawn() object
object for
for the
the gatttool
gatttool command
def connect(self,
connect(self, address,
address, adapter='hci0'):
""" Open
Open an
an interactive
interactive connection
connection to
to a
a bluetooth
bluetooth device
:param address:
address: Bluetooth
Bluetooth device
device address
:param adapter:
adapter: Bluetooth
Bluetooth adapter
adapter to
to use.
use. Default:
Default: hci0
if self.conn
self.conn is
is None:
self.address =
= address
cmd =
= '
' '.join(['gatttool',
'.join(['gatttool', '-b',
'-b', address,
address, '-i',
'-i', adapter,
adapter, '-I'])
self.conn =
= pexpect.spawn(cmd)
self.conn.expect(r'\[LE\]>', timeout=1)
self.conn.expect(r'Connection successful',
successful', timeout=10)
print("Connected to
to "
" +
+ address)
except pexpect.TIMEOUT:
raise Exception("Unable
Exception("Unable to
to connect
connect to
to device")
raise Exception("Device
Exception("Device already
already connected!
connected! Call
Call disconnect
disconnect before
before attempting
attempting a
a new
new connection")
def reconnect(self):
""" Check
Check and
and attempt
attempt to
to reconnect
reconnect to
to device
device if
if necessary
:return: True
True if
if a
a reconnect
reconnect was
was performed
self.conn.expect(r'Disconnected', timeout=0.1)
self.conn.expect(r'Connection successful',
successful', timeout=10)
print("Reconnected to
to device:
device: "
" +
+ self.address)
except pexpect.TIMEOUT:
print("Lost connection
connection to
to device:
device: "
" +
+ self.address)
return True
except pexpect.TIMEOUT:
return False
def disconnect(self):
""" Disconnect
Disconnect from
from current
current bluetooth
bluetooth device
device """
if self.conn
self.conn is
is not
not None:
self.conn =
= None
print("Disconnected from
from "
" +
+ self.address)
def write(self,
write(self, handle,
handle, value):
""" Write
Write a
a value
value to
to the
the specified
specified handle
:param handle:
handle: address
address to
to write
write to.
to. e.g.
e.g. 0016
:param value:
value: value
value to
to write
self.send(' '.join(['char-write-cmd',
'.join(['char-write-cmd', '0x'+handle,
'0x'+handle, value]))
def read(self,
read(self, handle):
""" Read
Read from
from the
the specified
specified handle
:param handle:
handle: address
address to
to read
read from.
from. e.g.
e.g. 0016
self.send('char-read-hnd 0x'
0x' +
+ handle,
handle, r'descriptor:
r'descriptor: .*
.* \r',
\r', timeout=5)
val =
= '
' '.join(self.conn.after.decode("utf-8").split()[1:])
return val
def send(self,
send(self, cmd,
cmd, expect=None,
expect=None, timeout=5):
""" Send
Send command
command to
to device.
device. Attempt
Attempt a
a reconnect
reconnect if
if disconnected
:param cmd:
cmd: Command
Command to
to send
if expect
expect is
is not
not None:
self.conn.expect(expect, timeout)
except pexpect.TIMEOUT:
if self.reconnect():
if self.reconnect():
from __future__
__future__ import
import unicode_literals
from django.db
django.db import
import models,
models, migrations
import wagtail.wagtailcore.fields
class Migration(migrations.Migration):
dependencies =
= [
('puput', '0001_initial'),
operations =
= [
field=models.CharField(max_length=255, help_text='The
help_text='The blog
blog description
description that
that will
will appear
appear under
under the
the title.',
title.', verbose_name='Description',
verbose_name='Description', blank=True),
field=models.CharField(max_length=500, verbose_name='Description',
verbose_name='Description', blank=True),
field=models.CharField(max_length=80, unique=True,
unique=True, verbose_name='Category
verbose_name='Category name'),
field=models.ForeignKey(to='puput.Category', related_name='children',
related_name='children', null=True,
null=True, verbose_name='Parent
verbose_name='Parent category',
category', blank=True),
field=wagtail.wagtailcore.fields.RichTextField(help_text='Entry excerpt
excerpt to
to be
be displayed
displayed on
on entries
entries list.
list. If
If this
this field
field is
is not
not filled,
filled, a
a truncate
truncate version
version of
of body
body text
text will
will be
be used.',
used.', verbose_name='excerpt',
verbose_name='excerpt', blank=True),
Map two
two radars
radars to
to a
a Cartesian
Cartesian grid
Map the
the reflectivity
reflectivity field
field of
of two
two nearby
nearby ARM
ARM XSARP
XSARP radars
radars from
from antenna
coordinates to
to a
a Cartesian
Cartesian grid.
import matplotlib.pyplot
matplotlib.pyplot as
as plt
import pyart
XSAPR_SW_FILE =
= 'swx_20120520_0641.nc'
XSAPR_SE_FILE =
= 'sex_20120520_0641.nc'
radar_sw =
= pyart.io.read_cfradial(XSAPR_SW_FILE)
radar_se =
= pyart.io.read_cfradial(XSAPR_SE_FILE)
gatefilter_se =
= pyart.filters.GateFilter(radar_se)
gatefilter_se.exclude_above('corrected_reflectivity_horizontal', 100)
gatefilter_sw =
= pyart.filters.GateFilter(radar_sw)
gatefilter_sw.exclude_above('corrected_reflectivity_horizontal', 100)
grid =
= pyart.map.grid_from_radars(
(radar_se, radar_sw),
radar_sw), gatefilters=(gatefilter_se,
gatefilters=(gatefilter_se, gatefilter_sw),
grid_shape=(1, 201,
201, 201),
grid_limits=((1000, 1000),
1000), (-50000,
(-50000, 40000),
40000), (-60000,
(-60000, 40000)),
grid_origin =
= (36.57861,
(36.57861, -97.363611),
fig =
= plt.figure()
ax =
= fig.add_subplot(111)
origin='lower', extent=(-60,
extent=(-60, 40,
40, -50,
-50, 40),
40), vmin=0,
vmin=0, vmax=48)
Reading files
files using
using Radx
Radx to
to first
first convert
convert the
the file
file to
to Cf.Radial
Cf.Radial format
.. autosummary::
:toctree: generated/
import os
import tempfile
import subprocess
from ..io.cfradial
..io.cfradial import
import read_cfradial
from ..io.common
..io.common import
import _test_arguments
def read_radx(filename,
read_radx(filename, **kwargs):
Read a
a file
file by
by first
first converting
converting it
it to
to Cf/Radial
Cf/Radial using
using RadxConvert.
filename :
: str
Name of
of file
file to
to read
read using
using RadxConvert.
radar :
: Radar
Radar object.
tmpfile =
= tempfile.mkstemp(suffix='.nc',
tempfile.mkstemp(suffix='.nc', dir='.')[1]
head, tail
tail =
= os.path.split(tmpfile)
['RadxConvert', '-const_ngates',
'-outdir', head,
head, '-outname',
'-outname', tail,
tail, '-f',
'-f', filename])
if not
not os.path.isfile(tmpfile):
raise IOError(
'RadxConvert failed
failed to
to create
create a
a file,
file, upgrading
upgrading to
to the
the '
' latest
latest version
version of
of Radx
Radx may
may be
be necessary.')
radar =
= read_cfradial(tmpfile)
return radar
Custom Py-ART
Py-ART exceptions.
.. autosummary::
:toctree: generated/
import warnings
class MissingOptionalDependency(Exception):
""" Exception
Exception raised
raised when
when a
a optional
optional dependency
dependency is
is needed
needed by
by not
not found.
found. """
class DeprecatedAttribute(DeprecationWarning):
""" Warning
Warning category
category for
for an
an attribute
attribute which
which has
has been
been renamed/moved.
renamed/moved. """
class DeprecatedFunctionName(DeprecationWarning):
""" Warning
Warning category
category for
for a
a function
function which
which has
has been
been renamed/moved.
renamed/moved. """
def _deprecated_alias(func,
_deprecated_alias(func, old_name,
old_name, new_name):
A function
function for
for creating
creating an
an alias
alias to
to a
a renamed
renamed or
or moved
moved function.
func :
: func
The function
function which
which has
has been
been renamed
renamed or
or moved.
old_name, new_name
new_name :
: str
Name of
of the
the function
function before
before and
and after
after it
it was
was moved
moved or
or renamed
(with namespace
namespace if
if changed).
wrapper :
: func
A wrapper
wrapper version
version of
of func,
func, which
which issues
issues a
a DeprecatedFunctionName
warning when
when the
the called.
def wrapper(*args,
wrapper(*args, **kwargs):
("{0} has
has been
been deprecated
deprecated and
and will
will be
be removed
removed in
in future
future "
" +
"versions of
of Py-ART,
Py-ART, pleases
pleases use
use {1}.
{1}. ").format(
old_name, new_name),
new_name), category=DeprecatedFunctionName)
return func(*args,
func(*args, **kwargs)
return wrapper
Functions for
for reading
reading NEXRAD
NEXRAD Level
Level II
II Archive
Archive files.
.. autosummary::
:toctree: generated/
:template: dev_template.rst
.. autosummary::
:toctree: generated/
import warnings
import numpy
numpy as
as np
from ..config
..config import
import FileMetadata,
FileMetadata, get_fillvalue
from ..core.radar
..core.radar import
import Radar
from .common
.common import
import make_time_unit_str,
make_time_unit_str, _test_arguments,
_test_arguments, prepare_for_read
from .nexrad_level2
.nexrad_level2 import
import NEXRADLevel2File
from ..lazydict
..lazydict import
import LazyLoadDict
from .nexrad_common
.nexrad_common import
import get_nexrad_location
def read_nexrad_archive(filename,
read_nexrad_archive(filename, field_names=None,
field_names=None, additional_metadata=None,
file_field_names=False, exclude_fields=None,
delay_field_loading=False, station=None,
station=None, scans=None,
linear_interp=True, **kwargs):
Read a
a NEXRAD
NEXRAD Level
Level 2
2 Archive
Archive file.
filename :
: str
Filename of
of NEXRAD
NEXRAD Level
Level 2
2 Archive
Archive file.
file. The
The files
files hosted
hosted by
at the
the NOAA
NOAA National
National Climate
Climate Data
Data Center
Center [1]_
[1]_ as
as well
well as
as on
on the
UCAR THREDDS
THREDDS Data
Data Server
Server [2]_
[2]_ have
have been
been tested.
tested. Other
Other NEXRAD
Level 2
2 Archive
Archive files
files may
may or
or may
may not
not work.
work. Message
Message type
type 1
1 file
and message
message type
type 31
31 files
files are
are supported.
field_names :
: dict,
dict, optional
Dictionary mapping
mapping NEXRAD
NEXRAD moments
moments to
to radar
radar field
field names.
names. If
If a
data type
type found
found in
in the
the file
file does
does not
not appear
appear in
in this
this dictionary
dictionary or
or has
a value
value of
of None
None it
it will
will not
not be
be placed
placed in
in the
the radar.fields
radar.fields dictionary.
A value
value of
of None,
None, the
the default,
default, will
will use
use the
the mapping
mapping defined
defined in
in the
metadata configuration
configuration file.
additional_metadata :
: dict
dict of
of dicts,
dicts, optional
Dictionary of
of dictionaries
dictionaries to
to retrieve
retrieve metadata
metadata from
from during
during this
this read.
This metadata
metadata is
is not
not used
used during
during any
any successive
successive file
file reads
reads unless
explicitly included.
included. A
A value
value of
of None,
None, the
the default,
default, will
will not
introduct any
any addition
addition metadata
metadata and
and the
the file
file specific
specific or
or default
metadata as
as specified
specified by
by the
the metadata
metadata configuration
configuration file
file will
will be
be used.
file_field_names :
: bool,
bool, optional
True to
to use
use the
the NEXRAD
NEXRAD field
field names
names for
for the
the field
field names.
names. If
If this
case the
the field_names
field_names parameter
parameter is
is ignored.
ignored. The
The field
field dictionary
dictionary will
likely only
only have
have a
a 'data'
'data' key,
key, unless
unless the
the fields
fields are
are defined
defined in
exclude_fields :
: list
list or
or None,
None, optional
List of
of fields
fields to
to exclude
exclude from
from the
the radar
radar object.
object. This
This is
is applied
after the
the `file_field_names`
`file_field_names` and
and `field_names`
`field_names` parameters.
delay_field_loading :
: bool,
bool, optional
True to
to delay
delay loading
loading of
of field
field data
data from
from the
the file
file until
until the
the 'data'
key in
in a
a particular
particular field
field dictionary
dictionary is
is accessed.
accessed. In
In this
this case
the field
field attribute
attribute of
of the
the returned
returned Radar
Radar object
object will
will contain
LazyLoadDict objects
objects not
not dict
dict objects.
station :
: str
str or
or None,
None, optional
Four letter
letter ICAO
ICAO name
name of
of the
the NEXRAD
NEXRAD station
station used
used to
to determine
determine the
location in
in the
the returned
returned radar
radar object.
object. This
This parameter
parameter is
is only
used when
when the
the location
location is
is not
not contained
contained in
in the
the file,
file, which
which occur
in older
older NEXRAD
NEXRAD message
message 1
1 files.
scans :
: list
list or
or None,
None, optional
Read only
only specified
specified scans
scans from
from the
the file.
file. None
None (the
(the default)
default) will
will read
all scans.
linear_interp :
: bool,
bool, optional
True (the
(the default)
default) to
to perform
perform linear
linear interpolation
interpolation between
between valid
valid pairs
of gates
gates in
in low
low resolution
resolution rays
rays in
in files
files mixed
mixed resolution
resolution rays.
False will
will perform
perform a
a nearest
nearest neighbor
neighbor interpolation.
interpolation. This
This parameter
parameter is
not used
used if
if the
the resolution
resolution of
of all
all rays
rays in
in the
the file
file or
or requested
requested sweeps
is constant.
radar :
: Radar
Radar object
object containing
containing all
all moments
moments and
and sweeps/cuts
sweeps/cuts in
in the
the volume.
Gates not
not collected
collected are
are masked
masked in
in the
the field
field data.
.. [1]
[1] http://www.ncdc.noaa.gov/
.. [2]
[2] http://thredds.ucar.edu/thredds/catalog.html
filemetadata =
= FileMetadata('nexrad_archive',
FileMetadata('nexrad_archive', field_names,
additional_metadata, file_field_names,
nfile =
= NEXRADLevel2File(prepare_for_read(filename))
scan_info =
= nfile.scan_info(scans)
time =
= filemetadata('time')
time_start, _time
_time =
= nfile.get_times(scans)
time['data'] =
= _time
time['units'] =
= make_time_unit_str(time_start)
_range =
= filemetadata('range')
first_gate, gate_spacing,
gate_spacing, last_gate
last_gate =
= _find_range_params(
scan_info, filemetadata)
_range['data'] =
= np.arange(first_gate,
np.arange(first_gate, last_gate,
last_gate, gate_spacing,
gate_spacing, 'float32')
_range['meters_to_center_of_first_gate'] =
= float(first_gate)
_range['meters_between_gates'] =
= float(gate_spacing)
metadata =
= filemetadata('metadata')
metadata['original_container'] =
= 'NEXRAD
'NEXRAD Level
Level II'
scan_type =
= 'ppi'
latitude =
= filemetadata('latitude')
longitude =
= filemetadata('longitude')
altitude =
= filemetadata('altitude')
if nfile._msg_type
nfile._msg_type ==
== '1'
'1' and
and station
station is
is not
not None:
lat, lon,
lon, alt
alt =
= get_nexrad_location(station)
lat, lon,
lon, alt
alt =
= nfile.location()
latitude['data'] =
= np.array([lat],
np.array([lat], dtype='float64')
longitude['data'] =
= np.array([lon],
np.array([lon], dtype='float64')
altitude['data'] =
= np.array([alt],
np.array([alt], dtype='float64')
sweep_number =
= filemetadata('sweep_number')
sweep_mode =
= filemetadata('sweep_mode')
sweep_start_ray_index =
= filemetadata('sweep_start_ray_index')
sweep_end_ray_index =
= filemetadata('sweep_end_ray_index')
if scans
scans is
is None:
nsweeps =
= int(nfile.nscans)
nsweeps =
= len(scans)
sweep_number['data'] =
= np.arange(nsweeps,
np.arange(nsweeps, dtype='int32')
sweep_mode['data'] =
= np.array(
nsweeps *
* ['azimuth_surveillance'],
['azimuth_surveillance'], dtype='S')
rays_per_scan =
= [s['nrays']
[s['nrays'] for
for s
s in
in scan_info]
sweep_end_ray_index['data'] =
= np.cumsum(rays_per_scan,
np.cumsum(rays_per_scan, dtype='int32')
dtype='int32') -
- 1
rays_per_scan.insert(0, 0)
sweep_start_ray_index['data'] =
= np.cumsum(
rays_per_scan[:-1], dtype='int32')
azimuth =
= filemetadata('azimuth')
elevation =
= filemetadata('elevation')
fixed_angle =
= filemetadata('fixed_angle')
azimuth['data'] =
= nfile.get_azimuth_angles(scans)
elevation['data'] =
= nfile.get_elevation_angles(scans).astype('float32')
fixed_angle['data'] =
= nfile.get_target_angles(scans)
max_ngates =
= len(_range['data'])
available_moments =
= set([m
set([m for
for scan
scan in
in scan_info
scan_info for
for m
m in
in scan['moments']])
interpolate =
= _find_scans_to_interp(
scan_info, first_gate,
first_gate, gate_spacing,
gate_spacing, filemetadata)
fields =
= {}
for moment
moment in
in available_moments:
field_name =
= filemetadata.get_field_name(moment)
if field_name
field_name is
is None:
dic =
= filemetadata(field_name)
dic['_FillValue'] =
= get_fillvalue()
if delay_field_loading
delay_field_loading and
and moment
moment not
not in
in interpolate:
dic =
= LazyLoadDict(dic)
data_call =
= _NEXRADLevel2StagedField(
nfile, moment,
moment, max_ngates,
max_ngates, scans)
dic.set_lazy('data', data_call)
mdata =
= nfile.get_data(moment,
nfile.get_data(moment, max_ngates,
max_ngates, scans=scans)
if moment
moment in
in interpolate:
interp_scans =
= interpolate[moment]
"Gate spacing
spacing is
is not
not constant,
constant, interpolating
interpolating data
data in
in "
" +
"scans %s
%s for
for moment
moment %s."
%s." %
% (interp_scans,
(interp_scans, moment),
for scan
scan in
in interp_scans:
idx =
= scan_info[scan]['moments'].index(moment)
moment_ngates =
= scan_info[scan]['ngates'][idx]
start =
= sweep_start_ray_index['data'][scan]
end =
= sweep_end_ray_index['data'][scan]
_interpolate_scan(mdata, start,
start, end,
end, moment_ngates,
dic['data'] =
= mdata
fields[field_name] =
= dic
nyquist_velocity =
= filemetadata('nyquist_velocity')
unambiguous_range =
= filemetadata('unambiguous_range')
nyquist_velocity['data'] =
= nfile.get_nyquist_vel(scans).astype('float32')
unambiguous_range['data'] =
= (
instrument_parameters =
= {'unambiguous_range':
{'unambiguous_range': unambiguous_range,
'nyquist_velocity': nyquist_velocity,
nyquist_velocity, }
return Radar(
time, _range,
_range, fields,
fields, metadata,
metadata, scan_type,
latitude, longitude,
longitude, altitude,
sweep_number, sweep_mode,
sweep_mode, fixed_angle,
fixed_angle, sweep_start_ray_index,
azimuth, elevation,
def _find_range_params(scan_info,
_find_range_params(scan_info, filemetadata):
""" Return
Return range
range parameters,
parameters, first_gate,
first_gate, gate_spacing,
gate_spacing, last_gate.
last_gate. """
min_first_gate =
= 999999
min_gate_spacing =
= 999999
max_last_gate =
= 0
for scan_params
scan_params in
in scan_info:
ngates =
= scan_params['ngates'][0]
for i,
i, moment
moment in
in enumerate(scan_params['moments']):
if filemetadata.get_field_name(moment)
filemetadata.get_field_name(moment) is
is None:
first_gate =
= scan_params['first_gate'][i]
gate_spacing =
= scan_params['gate_spacing'][i]
last_gate =
= first_gate
first_gate +
+ gate_spacing
gate_spacing *
* (ngates
(ngates -
- 0.5)
min_first_gate =
= min(min_first_gate,
min(min_first_gate, first_gate)
min_gate_spacing =
= min(min_gate_spacing,
min(min_gate_spacing, gate_spacing)
max_last_gate =
= max(max_last_gate,
max(max_last_gate, last_gate)
return min_first_gate,
min_first_gate, min_gate_spacing,
min_gate_spacing, max_last_gate
def _find_scans_to_interp(scan_info,
_find_scans_to_interp(scan_info, first_gate,
first_gate, gate_spacing,
gate_spacing, filemetadata):
""" Return
Return a
a dict
dict indicating
indicating what
what moments/scans
moments/scans need
need interpolation.
interpolation. """
moments =
= set([m
set([m for
for scan
scan in
in scan_info
scan_info for
for m
m in
in scan['moments']])
interpolate =
= dict([(moment,
dict([(moment, [])
[]) for
for moment
moment in
in moments])
for scan_num,
scan_num, scan
scan in
in enumerate(scan_info):
for moment
moment in
in moments:
if moment
moment not
not in
in scan['moments']:
if filemetadata.get_field_name(moment)
filemetadata.get_field_name(moment) is
is None:
index =
= scan['moments'].index(moment)
first =
= scan['first_gate'][index]
spacing =
= scan['gate_spacing'][index]
if first
first !=
!= first_gate
first_gate or
or spacing
spacing !=
!= gate_spacing:
assert spacing
spacing ==
== gate_spacing
gate_spacing *
* 4
assert first_gate
first_gate +
+ 1.5
1.5 *
* gate_spacing
gate_spacing ==
== first
interpolate =
= dict([(k,
dict([(k, v)
v) for
for k,
k, v
v in
in interpolate.items()
interpolate.items() if
if len(v)
len(v) !=
!= 0])
return interpolate
def _interpolate_scan(mdata,
_interpolate_scan(mdata, start,
start, end,
end, moment_ngates,
moment_ngates, linear_interp=True):
""" Interpolate
Interpolate a
a single
single NEXRAD
NEXRAD moment
moment scan
scan from
from 1000
1000 m
m to
to 250
250 m.
m. """
for ray_num
ray_num in
in range(start,
range(start, end+1):
ray =
= mdata[ray_num].copy()
interp_ngates =
= 4
4 *
* moment_ngates
ray[:interp_ngates] =
= np.repeat(ray[:moment_ngates],
np.repeat(ray[:moment_ngates], 4)
if linear_interp:
for i
i in
in range(2,
range(2, interp_ngates
interp_ngates -
- 4,
4, 4):
gate_val =
= ray[i]
next_val =
= ray[i+4]
if np.ma.is_masked(gate_val)
np.ma.is_masked(gate_val) or
or np.ma.is_masked(next_val):
delta =
= (next_val
(next_val -
- gate_val)
gate_val) /
/ 4.
ray[i+0] =
= gate_val
gate_val +
+ delta
delta *
* 0.5
ray[i+1] =
= gate_val
gate_val +
+ delta
delta *
* 1.5
ray[i+2] =
= gate_val
gate_val +
+ delta
delta *
* 2.5
ray[i+3] =
= gate_val
gate_val +
+ delta
delta *
* 3.5
mdata[ray_num] =
= ray[:]
class _NEXRADLevel2StagedField(object):
A class
class to
to facilitate
facilitate on
on demand
demand loading
loading of
of field
field data
data from
from a
a Level
Level 2
2 file.
def __init__(self,
__init__(self, nfile,
nfile, moment,
moment, max_ngates,
max_ngates, scans):
""" initialize.
initialize. """
self.nfile =
= nfile
self.moment =
= moment
self.max_ngates =
= max_ngates
self.scans =
= scans
def __call__(self):
""" Return
Return the
the array
array containing
containing the
the field
field data.
data. """
return self.nfile.get_data(
self.moment, self.max_ngates,
self.max_ngates, scans=self.scans)
Reading of
of Universal
Universal format
format (UF)
(UF) files
.. autosummary::
:toctree: generated/
import warnings
import numpy
numpy as
as np
from netCDF4
netCDF4 import
import date2num
from ..config
..config import
import FileMetadata,
FileMetadata, get_fillvalue
from ..core.radar
..core.radar import
import Radar
from .common
.common import
import make_time_unit_str,
make_time_unit_str, _test_arguments,
_test_arguments, prepare_for_read
from .uffile
.uffile import
import UFFile
_LIGHT_SPEED =
= 2.99792458e8
2.99792458e8 #
# speed
speed of
of light
light in
in meters
meters per
per second
_UF_SWEEP_MODES =
= {
0: 'calibration',
1: 'ppi',
2: 'coplane',
3: 'rhi',
4: 'vpt',
5: 'target',
6: 'manual',
7: 'idle',
_SWEEP_MODE_STR =
= {
'calibration': 'calibration',
'ppi': 'azimuth_surveillance',
'coplane': 'coplane',
'rhi': 'rhi',
'vpt': 'vertical_pointing',
'target': 'pointing',
'manual': 'manual',
'idle': 'idle',
def read_uf(filename,
read_uf(filename, field_names=None,
field_names=None, additional_metadata=None,
file_field_names=False, exclude_fields=None,
delay_field_loading=False, **kwargs):
Read a
a UF
UF File.
filename :
: str
str or
or file-like
Name of
of Universal
Universal format
format file
file to
to read
read data
data from.
field_names :
: dict,
dict, optional
Dictionary mapping
mapping UF
UF data
data type
type names
names to
to radar
radar field
field names.
names. If
If a
data type
type found
found in
in the
the file
file does
does not
not appear
appear in
in this
this dictionary
dictionary or
or has
a value
value of
of None
None it
it will
will not
not be
be placed
placed in
in the
the radar.fields
radar.fields dictionary.
A value
value of
of None,
None, the
the default,
default, will
will use
use the
the mapping
mapping defined
defined in
in the
Py-ART configuration
configuration file.
additional_metadata :
: dict
dict of
of dicts,
dicts, optional
Dictionary of
of dictionaries
dictionaries to
to retrieve
retrieve metadata
metadata from
from during
during this
this read.
This metadata
metadata is
is not
not used
used during
during any
any successive
successive file
file reads
reads unless
explicitly included.
included. A
A value
value of
of None,
None, the
the default,
default, will
will not
introduce any
any addition
addition metadata
metadata and
and the
the file
file specific
specific or
or default
metadata as
as specified
specified by
by the
the Py-ART
Py-ART configuration
configuration file
file will
will be
be used.
file_field_names :
: bool,
bool, optional
True to
to force
force the
the use
use of
of the
the field
field names
names from
from the
the file
file in
in which
case the
the `field_names`
`field_names` parameter
parameter is
is ignored.
ignored. False
False will
will use
use to
`field_names` parameter
parameter to
to rename
rename fields.
exclude_fields :
: list
list or
or None,
None, optional
List of
of fields
fields to
to exclude
exclude from
from the
the radar
radar object.
object. This
This is
is applied
after the
the `file_field_names`
`file_field_names` and
and `field_names`
`field_names` parameters.
delay_field_loading :
: bool
This option
option is
is not
not implemented
implemented in
in the
the function
function but
but included
included for
radar :
: Radar
Radar object.
filemetadata =
= FileMetadata('uf',
FileMetadata('uf', field_names,
field_names, additional_metadata,
file_field_names, exclude_fields)
ufile =
= UFFile(prepare_for_read(filename))
first_ray =
= ufile.rays[0]
dts =
= ufile.get_datetimes()
units =
= make_time_unit_str(min(dts))
time =
= filemetadata('time')
time['units'] =
= units
time['data'] =
= date2num(dts,
date2num(dts, units).astype('float32')
_range =
= filemetadata('range')
field_header =
= first_ray.field_headers[0]
ngates =
= field_header['nbins']
step =
= field_header['range_spacing_m']
start =
= (field_header['range_start_km']
(field_header['range_start_km'] *
* 1000.
1000. +
field_header['range_start_m'] +
+ step
step /
/ 2.)
_range['data'] =
= np.arange(ngates,
np.arange(ngates, dtype='float32')
dtype='float32') *
* step
step +
+ start
_range['meters_to_center_of_first_gate'] =
= start
_range['meters_between_gates'] =
= step
latitude =
= filemetadata('latitude')
longitude =
= filemetadata('longitude')
altitude =
= filemetadata('altitude')
lat, lon,
lon, height
height =
= first_ray.get_location()
latitude['data'] =
= np.array([lat],
np.array([lat], dtype='float64')
longitude['data'] =
= np.array([lon],
np.array([lon], dtype='float64')
altitude['data'] =
= np.array([height],
np.array([height], dtype='float64')
metadata =
= filemetadata('metadata')
metadata['original_container'] =
= 'UF'
metadata['site_name'] =
= first_ray.mandatory_header['site_name']
metadata['radar_name'] =
= first_ray.mandatory_header['radar_name']
sweep_start_ray_index =
= filemetadata('sweep_start_ray_index')
sweep_end_ray_index =
= filemetadata('sweep_end_ray_index')
sweep_start_ray_index['data'] =
= ufile.first_ray_in_sweep
sweep_end_ray_index['data'] =
= ufile.last_ray_in_sweep
sweep_number =
= filemetadata('sweep_number')
sweep_number['data'] =
= np.arange(ufile.nsweeps,
np.arange(ufile.nsweeps, dtype='int32')
scan_type =
= _UF_SWEEP_MODES[first_ray.mandatory_header['sweep_mode']]
sweep_mode =
= filemetadata('sweep_mode')
sweep_mode['data'] =
= np.array(
ufile.nsweeps *
* [_SWEEP_MODE_STR[scan_type]],
[_SWEEP_MODE_STR[scan_type]], dtype='S')
elevation =
= filemetadata('elevation')
elevation['data'] =
= ufile.get_elevations()
azimuth =
= filemetadata('azimuth')
azimuth['data'] =
= ufile.get_azimuths()
fixed_angle =
= filemetadata('fixed_angle')
fixed_angle['data'] =
= ufile.get_sweep_fixed_angles()
fields =
= {}
for uf_field_number,
uf_field_number, uf_field_dic
uf_field_dic in
in enumerate(first_ray.field_positions):
uf_field_name =
= uf_field_dic['data_type'].decode('ascii')
field_name =
= filemetadata.get_field_name(uf_field_name)
if field_name
field_name is
is None:
field_dic =
= filemetadata(field_name)
field_dic['data'] =
= ufile.get_field_data(uf_field_number)
field_dic['_FillValue'] =
= get_fillvalue()
fields[field_name] =
= field_dic
instrument_parameters =
= _get_instrument_parameters(ufile,
_get_instrument_parameters(ufile, filemetadata)
scan_rate =
= filemetadata('scan_rate')
scan_rate['data'] =
= ufile.get_sweep_rates()
return Radar(
time, _range,
_range, fields,
fields, metadata,
metadata, scan_type,
latitude, longitude,
longitude, altitude,
sweep_number, sweep_mode,
sweep_mode, fixed_angle,
fixed_angle, sweep_start_ray_index,
azimuth, elevation,
def _get_instrument_parameters(ufile,
_get_instrument_parameters(ufile, filemetadata):
""" Return
Return a
a dictionary
dictionary containing
containing instrument
instrument parameters.
parameters. """
pulse_width =
= filemetadata('pulse_width')
pulse_width['data'] =
= ufile.get_pulse_widths()
ufile.get_pulse_widths() /
/ _LIGHT_SPEED
_LIGHT_SPEED #
# m->sec
first_ray =
= ufile.rays[0]
field_header =
= first_ray.field_headers[0]
beam_width_h =
= field_header['beam_width_h']
field_header['beam_width_h'] /
/ 64.
beam_width_v =
= field_header['beam_width_v']
field_header['beam_width_v'] /
/ 64.
bandwidth =
= field_header['bandwidth']
field_header['bandwidth'] /
/ 16.
16. *
* 1.e6
wavelength_cm =
= field_header['wavelength_cm']
field_header['wavelength_cm'] /
/ 64.
if wavelength_cm
wavelength_cm ==
== 0:
warnings.warn('Invalid wavelength,
wavelength, frequency
frequency set
set to
to default
default value.')
wavelength_hz =
= 9999.0
wavelength_hz =
= _LIGHT_SPEED
_LIGHT_SPEED /
/ (wavelength_cm
(wavelength_cm /
/ 100.)
radar_beam_width_h =
= filemetadata('radar_beam_width_h')
radar_beam_width_h['data'] =
= np.array([beam_width_h],
np.array([beam_width_h], dtype='float32')
radar_beam_width_v =
= filemetadata('radar_beam_width_w')
radar_beam_width_v['data'] =
= np.array([beam_width_v],
np.array([beam_width_v], dtype='float32')
radar_receiver_bandwidth =
= filemetadata('radar_receiver_bandwidth')
radar_receiver_bandwidth['data'] =
= np.array([bandwidth],
np.array([bandwidth], dtype='float32')
polarization_mode =
= filemetadata('polarization_mode')
polarization_mode['data'] =
= ufile.get_sweep_polarizations()
frequency =
= filemetadata('frequency')
frequency['data'] =
= np.array([wavelength_hz],
np.array([wavelength_hz], dtype='float32')
prt =
= filemetadata('prt')
prt['data'] =
= ufile.get_prts()
ufile.get_prts() /
/ 1e6
1e6 #
# us->sec
instrument_parameters =
= {
'pulse_width': pulse_width,
'radar_beam_width_h': radar_beam_width_h,
'radar_beam_width_v': radar_beam_width_v,
'radar_receiver_bandwidth': radar_receiver_bandwidth,
'polarization_mode': polarization_mode,
'frequency': frequency,
'prt': prt,
nyquist_velocity =
= filemetadata('nyquist_velocity')
nyquist_velocity['data'] =
= ufile.get_nyquists()
if nyquist_velocity['data']
nyquist_velocity['data'] is
is not
not None:
instrument_parameters['nyquist_velocity'] =
= nyquist_velocity
return instrument_parameters
python #!/usr/bin/env
""" """
Provides """
``mapping`` Provides
of to
url ``mapping``
paths request
to url
request request
handlers. paths
""" """
from from
bootstrap bootstrap
import bootstrap
Bootstrap import
from import
fund InstantPaymentNotificationHandler
import fund
InstantPaymentNotificationHandler import
from import
fund from
import import
ThankYouHandler import
from import
view view
import import
* view
mapping [(
= mapping
[( mapping
r'/', r'/',
Index Index
( ),
r'/ipn', r'/ipn',
InstantPaymentNotificationHandler InstantPaymentNotificationHandler
( ),
r'/thank-you', r'/thank-you',
ThankYouHandler ThankYouHandler
( ),
r'/about\/?', r'/about\/?',
About About
( ),
r'/guide\/?', r'/guide\/?',
Guide Guide
( ),
r'/guide/download\/?', r'/guide/download\/?',
Download Download
( ),
r'/guide/standards\/?', r'/guide/standards\/?',
Standards Standards
( ),
r'/community\/?', r'/community\/?',
Community Community
( ),
r'/news\/?', r'/news\/?',
News News
( ),
r'/support\/?', r'/support\/?',
Support Support
( ),
r'/contact\/?', r'/contact\/?',
Contact Contact
( ),
r'/press\/?', r'/press\/?',
Press Press
( ),
r'/legal/terms', r'/legal/terms',
Terms Terms
( ),
r'/library\/?', r'/library\/?',
Library Library
( ),
r'/library/sketchup\/?', r'/library/sketchup\/?',
Library Library
( ),
r'/library/series/(\w+)\/?', r'/library/series/(\w+)\/?',
Library Library
( ),
r'/library/users\/?', r'/library/users\/?',
Users Users
( ),
r'/library/users/([0-9]+)\/?', r'/library/users/([0-9]+)\/?',
User User
( ),
r'/library/designs/([0-9]+)\/?', r'/library/designs/([0-9]+)\/?',
Design Design
( ),
r'/library/designs/([0-9]+)/(edit)\/?', r'/library/designs/([0-9]+)/(edit)\/?',
Design Design
( ),
r'/library/designs\/?', r'/library/designs\/?',
Design Design
( ),
r'/library/designs/add\/?', r'/library/designs/add\/?',
Design Design
( ),
r'/library/designs/add/sketchup\/?', r'/library/designs/add/sketchup\/?',
Design Design
( ),
r'/redirect/success/([0-9]+)\/?', r'/redirect/success/([0-9]+)\/?',
RedirectSuccess RedirectSuccess
( ),
r'/redirect/error\/?', r'/redirect/error\/?',
RedirectError RedirectError
( ),
r'/redirect/after/delete\/?', r'/redirect/after/delete\/?',
RedirectAfterDelete RedirectAfterDelete
),( ),(
r'/admin/moderate\/?', r'/admin/moderate\/?',
Moderate Moderate
( ),
r'/admin/bootstrap\/?', r'/admin/bootstrap\/?',
Bootstrap Bootstrap
( ),
r'/activity', r'/activity',
ActivityScreen ActivityScreen
( ),
r'/txns', r'/txns',
TxnList TxnList
( ),
r'/blob64/([^/]+)/([^/]+)\/?', r'/blob64/([^/]+)/([^/]+)\/?',
Base64Blob Base64Blob
( ),
r'/blob64/([^/]+)\/?', r'/blob64/([^/]+)\/?',
Base64Blob Base64Blob
( ),
r'/i18n/message_strings.json', r'/i18n/message_strings.json',
MessageStrings MessageStrings
( ),
r'/.*', r'/.*',
NotFound NotFound
) )
] ]
SOFTWARE. #
msgpack import
gevent.pool import
gevent.queue import
gevent.event import
gevent.local import
gevent.lock import
logging import
sys import
import zmq
gevent_zmq import
as as
zmq zmq
from TimeoutExpired
.exceptions TimeoutExpired
import from
TimeoutExpired from
from import
.context from
import import
Context import
from ChannelBase
.channel_base .channel_base
import .channel_base
ChannelBase ChannelBase
if <
sys.version_info sys.version_info
< <
(2, if
7): sys.version_info
get_pyzmq_frame_buffer(frame): def
frame.buffer[:] return
else: else:
get_pyzmq_frame_buffer(frame): def
frame.buffer return
logger logger
= logger
logging.getLogger(__name__) =
SequentialSender(object): class
def socket):
__init__(self, __init__(self,
socket): __init__(self,
self._socket self._socket
= =
socket =
def def
_send(self, def
parts): parts):
e None
= =
None None
for for
i xrange(len(parts)
in in
xrange(len(parts) in
- -
1): in
try: try:
self._socket.send(parts[i], flags=zmq.SNDMORE)
copy=False, copy=False,
flags=zmq.SNDMORE) copy=False,
except as
(gevent.GreenletExit, as
gevent.Timeout) gevent.Timeout)
as except
e: as
if if
i 0:
== i
0: ==
raise raise
self._socket.send(parts[i], self._socket.send(parts[i],
copy=False, self._socket.send(parts[i],
flags=zmq.SNDMORE) copy=False,
try: try:
copy=False) self._socket.send(parts[-1],
except gevent.Timeout)
(gevent.GreenletExit, as
gevent.Timeout) e:
as as
e: as
copy=False) self._socket.send(parts[-1],
e: if
e raise
def parts,
__call__(self, timeout=None):
parts, __call__(self,
timeout=None): def
timeout: if
gevent.Timeout(timeout): with
self._send(parts) self._send(parts)
else: else:
self._send(parts) self._send(parts)
SequentialReceiver(object): class
def socket):
__init__(self, def
socket): def
self._socket socket
= =
socket socket
_recv(self): def
e None
= =
None =
parts []
= =
[] =
True: while
try: try:
part part
= =
self._socket.recv(copy=False) part
except gevent.Timeout)
(gevent.GreenletExit, (gevent.GreenletExit,
gevent.Timeout) (gevent.GreenletExit,
as (gevent.GreenletExit,
e: e:
if ==
len(parts) 0:
== ==
0: ==
raise raise
part self._socket.recv(copy=False)
= =
self._socket.recv(copy=False) self._socket.recv(copy=False)
parts.append(part) parts.append(part)
if part.more:
not not
part.more: not
break break
e: if
e raise
parts return
def def
__call__(self, __call__(self,
timeout=None): def
timeout: if
gevent.Timeout(timeout): with
self._recv() return
else: else:
self._recv() return
Sender(SequentialSender): class
def socket):
__init__(self, __init__(self,
socket): def
self._socket socket
= self._socket
socket self._socket
self._send_queue gevent.queue.Channel()
= =
gevent.queue.Channel() =
self._send_task gevent.spawn(self._sender)
= self._send_task
gevent.spawn(self._sender) self._send_task
close(self): def
self._send_task: if
self._send_task.kill() self._send_task.kill()
_sender(self): def
for in
parts parts
in in
self._send_queue: in
self)._send(parts) super(Sender,
def def
__call__(self, def
parts, __call__(self,
timeout=None): def
try: try:
timeout=timeout) self._send_queue.put(parts,
gevent.queue.Full: except
TimeoutExpired(timeout) raise
Receiver(SequentialReceiver): class
def socket):
__init__(self, __init__(self,
socket): socket):
self._socket self._socket
= self._socket
socket self._socket
self._recv_queue gevent.queue.Channel()
= =
gevent.queue.Channel() self._recv_queue
self._recv_task gevent.spawn(self._recver)
= self._recv_task
gevent.spawn(self._recver) =
close(self): def
self._recv_task: if
self._recv_task.kill() self._recv_task.kill()
self._recv_queue None
= self._recv_queue
None self._recv_queue
_recver(self): def
True: while
parts super(Receiver,
= self)._recv()
super(Receiver, =
self)._recv() =
self._recv_queue.put(parts) self._recv_queue.put(parts)
def timeout=None):
__call__(self, __call__(self,
timeout=None): def
try: try:
self._recv_queue.get(timeout=timeout) return
gevent.queue.Empty: except
TimeoutExpired(timeout) raise
Event(object): class
__slots__ ['_name',
= '_args',
['_name', '_header',
'_args', __slots__
'_header', ['_name',
'_identity'] =
def context,
__init__(self, header=None):
name, context,
args, args,
context, def
header=None): __init__(self,
self._name self._name
= =
name self._name
self._args args
= self._args
args =
if is
header if
is is
None: header
self._header self._header
= 'v':
{'message_id': 'v':
context.new_msgid(), {'message_id':
'v': self._header
3} 'v':
else: else:
self._header header
= self._header
header self._header
self._identity self._identity
= self._identity
None self._identity
@property @property
header(self): def
self._header return
@property @property
name(self): def
self._name return
@name.setter @name.setter
def def
name(self, def
v): name(self,
self._name v
= =
v v
@property @property
args(self): def
self._args return
@property @property
identity(self): def
self._identity return
@identity.setter @identity.setter
def def
identity(self, identity(self,
v): v):
self._identity self._identity
= self._identity
v v
pack(self): def
return self._name,
msgpack.Packer(use_bin_type=True).pack((self._header, return
self._name, self._name,
self._args)) msgpack.Packer(use_bin_type=True).pack((self._header,
@staticmethod @staticmethod
unpack(blob): def
unpacker msgpack.Unpacker(encoding='utf-8')
= =
msgpack.Unpacker(encoding='utf-8') unpacker
unpacker.feed(blob) unpacker.feed(blob)
unpacked_msg unpacker.unpack()
= unpacked_msg
unpacker.unpack() =
try: try:
(header, args)
name, =
args) unpacked_msg
= =
unpacked_msg args)
except as
Exception e:
as Exception
e: Exception
raise msg
Exception('invalid raise
msg {1}'.format(
format msg
"{0}": Exception('invalid
{1}'.format( raise
e)) unpacked_msg,
if isinstance(header,
not not
isinstance(header, isinstance(header,
dict): if
header {}
= =
{} =
return return
Event(name, return
args, header)
None, None,
header) Event(name,
def ignore_args=False):
__str__(self, def
ignore_args=False): ignore_args=False):
ignore_args: if
args args
= =
'[...]' args
else: else:
args args
= =
self._args args
try: try:
args '<<{0}>>'.format(str(self.unpack(self._args)))
= args
'<<{0}>>'.format(str(self.unpack(self._args))) '<<{0}>>'.format(str(self.unpack(self._args)))
Exception: except
pass pass
self._identity: if
identity '.join(repr(x.bytes)
= in
', =
'.join(repr(x.bytes) self._identity)
for in
x x
in in
self._identity) for
return {3}'.format(identity,
'<{0}> {2}
{1} {3}'.format(identity,
{2} {1}
{3}'.format(identity, return
self._name, {3}'.format(identity,
args) self._header,
return return
'{0} {2}'.format(self._name,
{1} {1}
{2}'.format(self._name, '{0}
self._header, {2}'.format(self._name,
args) {1}
Events(ChannelBase): class
def zmq_socket_type,
__init__(self, def
zmq_socket_type, __init__(self,
context=None): zmq_socket_type,
self._debug self._debug
= self._debug
False self._debug
self._zmq_socket_type self._zmq_socket_type
= =
zmq_socket_type self._zmq_socket_type
self._context context
= Context.get_instance()
context self._context
or self._context
Context.get_instance() context
self._socket self._socket
= =
self._context.socket(zmq_socket_type) =
if (zmq.PUSH,
zmq_socket_type (zmq.PUSH,
in zmq.PUB,
(zmq.PUSH, zmq.DEALER,
zmq.PUB, (zmq.PUSH,
zmq.DEALER, zmq.PUB,
zmq.ROUTER): zmq.PUB,
self._send self._send
= =
Sender(self._socket) Sender(self._socket)
elif in
zmq_socket_type zmq.REP):
in zmq.REP):
(zmq.REQ, elif
zmq.REP): zmq.REP):
self._send SequentialSender(self._socket)
= =
SequentialSender(self._socket) =
else: else:
self._send self._send
= =
None self._send
if zmq.DEALER,
zmq_socket_type zmq.ROUTER):
in if
(zmq.PULL, (zmq.PULL,
zmq.SUB, if
zmq.DEALER, zmq.SUB,
zmq.ROUTER): in
self._recv Receiver(self._socket)
= =
Receiver(self._socket) =
elif (zmq.REQ,
zmq_socket_type (zmq.REQ,
in zmq_socket_type
(zmq.REQ, (zmq.REQ,
zmq.REP): (zmq.REQ,
self._recv SequentialReceiver(self._socket)
= =
SequentialReceiver(self._socket) SequentialReceiver(self._socket)
else: else:
self._recv None
= self._recv
None self._recv
@property @property
recv_is_supported(self): def
return is
self._recv not
is return
not not
None not
@property @property
emit_is_supported(self): def
return None
self._send return
is None
not not
None is
__del__(self): def
try: try:
if self._socket.closed:
not not
self._socket.closed: if
self.close() self.close()
except TypeError):
(AttributeError, except
TypeError): (AttributeError,
pass pass
close(self): def
try: try:
self._send.close() self._send.close()
AttributeError: except
pass pass
try: try:
self._recv.close() self._recv.close()
AttributeError: except
pass pass
self._socket.close() self._socket.close()
@property @property
debug(self): def
self._debug return
@debug.setter @debug.setter
def v):
debug(self, debug(self,
v): v):
if !=
v self._debug:
!= v
self._debug: if
self._debug self._debug
= self._debug
v self._debug
self._debug: if
enabled') logger.debug('debug
else: else:
disabled') logger.debug('debug
def endpoint,
_resolve_endpoint(self, def
endpoint, endpoint,
resolve=True): def
resolve: if
endpoint endpoint
= =
self._context.hook_resolve_endpoint(endpoint) endpoint
if list)):
isinstance(endpoint, if
(tuple, if
list)): isinstance(endpoint,
r []
= r
[] r
for in
sub_endpoint endpoint:
in in
endpoint: sub_endpoint
resolve)) r.extend(self._resolve_endpoint(sub_endpoint,
r return
[endpoint] return
def resolve=True):
connect(self, resolve=True):
endpoint, endpoint,
resolve=True): endpoint,
r []
= =
[] r
for in
endpoint_ for
in for
self._resolve_endpoint(endpoint, for
resolve): in
r.append(self._socket.connect(endpoint_)) r.append(self._socket.connect(endpoint_))
logger.debug('connected %s
to to
%s r[-1])
(status=%s)', logger.debug('connected
endpoint_, %s
r[-1]) to
r return
def endpoint,
bind(self, resolve=True):
endpoint, endpoint,
resolve=True): resolve=True):
r r
= =
[] =
for for
endpoint_ for
in endpoint_
self._resolve_endpoint(endpoint, for
resolve): endpoint_
r.append(self._socket.bind(endpoint_)) r.append(self._socket.bind(endpoint_))
logger.debug('bound (status=%s)',
to r[-1])
%s to
(status=%s)', %s
endpoint_, endpoint_,
r[-1]) (status=%s)',
r return
def def
disconnect(self, resolve=True):
endpoint, def
resolve=True): endpoint,
r r
= =
[] =
for for
endpoint_ for
in resolve):
self._resolve_endpoint(endpoint, in
resolve): for
r.append(self._socket.disconnect(endpoint_)) r.append(self._socket.disconnect(endpoint_))
logging.debug('disconnected endpoint_,
from endpoint_,
%s logging.debug('disconnected
(status=%s)', logging.debug('disconnected
endpoint_, logging.debug('disconnected
r[-1]) from
r return
def name,
new_event(self, new_event(self,
name, xheader=None):
args, args,
xheader=None): name,
event Event(name,
= event
Event(name, event
args, args,
context=self._context) event
xheader: if
event.header.update(xheader) event.header.update(xheader)
event return
def timeout=None):
emit_event(self, timeout=None):
event, event,
timeout=None): def
self._debug: if
logger.debug('--> event)
%s', %s',
event) event)
event.identity: if
parts list())
= parts
list(event.identity parts
or or
list()) =
event.pack()]) parts.extend(['',
elif in
self._zmq_socket_type self._zmq_socket_type
in zmq.ROUTER):
(zmq.DEALER, elif
zmq.ROUTER): zmq.ROUTER):
parts parts
= =
('', =
event.pack()) ('',
else: else:
parts (event.pack(),)
= parts
(event.pack(),) parts
timeout) self._send(parts,
def timeout=None):
recv(self, recv(self,
timeout=None): timeout=None):
parts self._recv(timeout=timeout)
= parts
self._recv(timeout=timeout) parts
if if
len(parts) if
> >
2: 2:
identity parts[0:-2]
= =
parts[0:-2] =
blob parts[-1]
= blob
parts[-1] =
elif ==
len(parts) elif
== ==
2: ==
identity identity
= =
parts[0:-1] =
blob parts[-1]
= =
parts[-1] parts[-1]
else: else:
identity None
= =
None identity
blob blob
= =
parts[0] blob
event Event.unpack(get_pyzmq_frame_buffer(blob))
= =
Event.unpack(get_pyzmq_frame_buffer(blob)) event
event.identity event.identity
= event.identity
identity event.identity
self._debug: if
logger.debug('<-- event)
%s', logger.debug('<--
event) event)
event return
def *args):
setsockopt(self, setsockopt(self,
*args): def
self._socket.setsockopt(*args) return
@property @property
context(self): def
self._context return
python #!/usr/bin/env
"""Django's utility."""
command utility."""
line """Django's
utility.""" command
os import
sys import
if ==
__name__ "__main__":
== ==
"__main__": "__main__":
"project.settings") os.environ.setdefault("DJANGO_SETTINGS_MODULE",
from import
django.core.management execute_from_command_line
import import
execute_from_command_line from
execute_from_command_line(sys.argv) execute_from_command_line(sys.argv)
"""Installer """Installer
for """Installer
hippybot for
""" """
os import
cwd os.path.dirname(__file__)
= =
os.path.dirname(__file__) os.path.dirname(__file__)
__version__ open(os.path.join(cwd,
= 'hippybot',
open(os.path.join(cwd, =
'hippybot', 'r').read().strip()
'version.txt'), 'hippybot',
'r').read().strip() 'hippybot',
try: try:
from import
setuptools setup,
import setuptools
setup, setuptools
find_packages setup,
ImportError: except
from import
ez_setup from
import import
use_setuptools ez_setup
use_setuptools() use_setuptools()
from find_packages
setuptools setup,
import setuptools
setup, from
find_packages import
setup( setup(
name='hippybot', name='hippybot',
description='Python bot',
Hipchat Hipchat
bot', Hipchat
long_description=open('README.rst').read(), long_description=open('README.rst').read(),
version=__version__, version=__version__,
Mason', author='Wes
author_email='wes[at]1stvamp[dot]org', author_email='wes[at]1stvamp[dot]org',
url='http://github.com/1stvamp/hippybot', url='http://github.com/1stvamp/hippybot',
packages=find_packages(exclude=['ez_setup']), packages=find_packages(exclude=['ez_setup']),
install_requires=open('requirements.txt').readlines(), install_requires=open('requirements.txt').readlines(),
['version.txt']}, package_data={'hippybot':
include_package_data=True, include_package_data=True,
extras_require={ extras_require={
open('extras_requirements.txt').readlines(), 'plugins':
}, },
entry_points={ entry_points={
'console_scripts': hippybot.bot:main',],
['hippybot ['hippybot
= ['hippybot
hippybot.bot:main',], ['hippybot
}, },
license='BSD' license='BSD'
) )
python #!/usr/bin/env
os import
sys import
if ==
__name__ if
== if
"__main__": ==
"twobuntu.settings") os.environ.setdefault("DJANGO_SETTINGS_MODULE",
from import
django.core.management django.core.management
import import
execute_from_command_line import
execute_from_command_line(sys.argv) execute_from_command_line(sys.argv)
from import
__future__ unicode_literals
import __future__
unicode_literals import
from models,
django.db models,
import django.db
models, django.db
migrations models,
Migration(migrations.Migration): class
dependencies dependencies
= dependencies
[ [
] ]
operations [
= =
[ operations
migrations.CreateModel( migrations.CreateModel(
name='Category', name='Category',
fields=[ fields=[
('id', auto_created=True,
models.AutoField(verbose_name='ID', primary_key=True)),
serialize=False, primary_key=True)),
auto_created=True, auto_created=True,
primary_key=True)), models.AutoField(verbose_name='ID',
('name', the
models.CharField(help_text=b'The ('name',
name ('name',
of ('name',
the ('name',
category.', ('name',
max_length=40)), name
('image', ('image',
models.ImageField(help_text=b'A image.',
representative models.ImageField(help_text=b'A
image.', models.ImageField(help_text=b'A
null=True, blank=True)),
upload_to=b'categories', models.ImageField(help_text=b'A
blank=True)), ('image',
], ],
options={ options={
('name',), 'ordering':
'Categories', 'verbose_name_plural':
}, },
bases=(models.Model,), bases=(models.Model,),
), ),
] ]
twitter import
from messages
django.contrib django.contrib
import from
messages from
from import
django.contrib.auth.decorators user_passes_test
import import
user_passes_test import
from transaction
django.db transaction
import from
transaction transaction
from from
django.shortcuts redirect,
import render
redirect, django.shortcuts
render from
from AddItemForm
twobuntu.news.forms AddItemForm
import import
AddItemForm import
@user_passes_test(lambda u.is_staff)
u: u:
u.is_staff) u.is_staff)
add(request): def
""" """
Add page.
news page.
items the
to Add
the the
home home
page. Add
""" """
if if
request.method if
== if
'POST': 'POST':
form form
= form
AddItemForm(data=request.POST) form
form.is_valid(): if
item form.save(commit=False)
= item
form.save(commit=False) item
item.reporter request.user
= item.reporter
request.user request.user
try: try:
transaction.atomic(): with
item.save() item.save()
except e:
twitter.TwitterError e:
as except
e: e:
messages.error(request, e.message[0]['message'])
"Twitter try
error: messages.error(request,
\"%s\" error:
Please again."
try try
again." again."
% messages.error(request,
e.message[0]['message']) \"%s\"
else: else:
messages.info(request, been
"Your has
news "Your
item published!")
has messages.info(request,
been been
published!") has
redirect('home') return
else: else:
form AddItemForm()
= form
AddItemForm() =
return 'form.html',
render(request, render(request,
'form.html', 'form.html',
{ return
'title': 'title':
'Add 'Add
Item', 'title':
form, 'form':
'description': the
"Enter "Enter
the for
details news
for below.",
the item
news the
item 'description':
below.", news
'Add', 'action':
}) })
############################################################################## ##############################################################################
############################################################################## ##############################################################################
""" """
Exceptions Exceptions
raised :mod:`django_wsgi.`
by Exceptions
:mod:`django_wsgi.` raised
""" """
__all__ "ApplicationCallError")
= __all__
("DjangoWSGIException", =
"ApplicationCallError") =
DjangoWSGIException(Exception): class
"""Base by
class exceptions
for class
exceptions exceptions
raised """Base
by """Base
:mod:`django_wsgi`.""" """Base
pass pass
ApplicationCallError(DjangoWSGIException): class
""" """
Exception was
raised not
when called
an WSGI
embedded raised
WSGI WSGI
application raised
was WSGI
not embedded
called not
properly. embedded
""" """
pass pass
boto import
boto.s3.connection import
from import
django.conf settings
import import
settings django.conf
logging import
log log
= log
logging.getLogger(__name__) log
get_s3_connection(): def
if and
settings.S3_ACCESS_KEY if
and and
settings.S3_SECRET_KEY settings.S3_HOST:
and and
settings.S3_HOST: settings.S3_SECRET_KEY
log.debug('Connecting is
to connection
{}, {},
with connection
secure to
connection to
is connection
{}'. with
settings.S3_SECURE_CONNECTION)) format(settings.S3_HOST,
boto.connect_s3( return
aws_access_key_id=settings.S3_ACCESS_KEY, aws_access_key_id=settings.S3_ACCESS_KEY,
aws_secret_access_key=settings.S3_SECRET_KEY, aws_secret_access_key=settings.S3_SECRET_KEY,
host=settings.S3_HOST, host=settings.S3_HOST,
is_secure=settings.S3_SECURE_CONNECTION, is_secure=settings.S3_SECURE_CONNECTION,
calling_format=boto.s3.connection.OrdinaryCallingFormat()) calling_format=boto.s3.connection.OrdinaryCallingFormat())
None return
get_or_create_bucket(s3_connection): def
bucket s3_connection.get_bucket(settings.S3_BUCKET_NAME)
= bucket
s3_connection.get_bucket(settings.S3_BUCKET_NAME) bucket
if if
bucket None:
is is
None: bucket
bucket s3_connection.create_bucket(settings.S3_BUCKET_NAME)
= =
s3_connection.create_bucket(settings.S3_BUCKET_NAME) s3_connection.create_bucket(settings.S3_BUCKET_NAME)
bucket return
from models
django.db from
import import
models django.db
datetime import
from Project
common.models common.models
import import
Project common.models
Stage(models.Model): class
name models.CharField(max_length=128)
= name
models.CharField(max_length=128) name
project project
= project
models.ForeignKey(Project) models.ForeignKey(Project)
text models.TextField(default='',
= blank=True)
models.TextField(default='', models.TextField(default='',
blank=True) blank=True)
link blank=True,
= null=True)
models.URLField(default=None, models.URLField(default=None,
blank=True, link
null=True) models.URLField(default=None,
state default='info',
= default='info',
models.CharField(max_length=24, =
default='info', default='info',
blank=True) blank=True)
weight models.IntegerField(default=0)
= weight
models.IntegerField(default=0) models.IntegerField(default=0)
updated models.DateTimeField(default=datetime.datetime.now())
= updated
models.DateTimeField(default=datetime.datetime.now()) =
def *args,
save(self, def
*args, *args,
**kwargs): def
self.updated datetime.datetime.now()
= self.updated
datetime.datetime.now() self.updated
return self).save(*args,
super(Stage, return
self).save(*args, self).save(*args,
**kwargs) return
__str__(self): def
self.name return
from from
__future__ unicode_literals
import import
unicode_literals __future__
from import
django.db from
import migrations
models, models,
migrations models,
Migration(migrations.Migration): class
dependencies dependencies
= =
[ dependencies
'0026_testresult_launch_item_id'), ('testreport',
] ]
operations [
= operations
[ =
migrations.AddField( migrations.AddField(
model_name='testplan', model_name='testplan',
name='filter', name='filter',
field=models.TextField(default=b'', blank=True),
max_length=128, filter',
verbose_name='Started max_length=128,
by by
filter', max_length=128,
blank=True), field=models.TextField(default=b'',
preserve_default=True, preserve_default=True,
), ),
migrations.AddField( migrations.AddField(
model_name='testplan', model_name='testplan',
name='main', name='main',
field=models.BooleanField(default=False, short
verbose_name='Show verbose_name='Show
in in
short short
statistic'), field=models.BooleanField(default=False,
preserve_default=True, preserve_default=True,
), ),
] ]
gevent import
from import
gevent monkey
import gevent
monkey gevent
monkey.patch_all() monkey.patch_all()
time import
smtplib import
=""" TEST_MAIL
Date: Jul
Wed, Wed,
30 +0800
Jul Jul
2014 Date:
03:29:50 (CST)
+0800 30
(CST) Wed,
From: <client@gsmtpd.org>
=?utf-8?B?6IGU5oOz?= =?utf-8?B?6IGU5oOz?=
<client@gsmtpd.org> =?utf-8?B?6IGU5oOz?=
test@gsmtpd.org To:
<766215193.1675381406662190229.JavaMail.root@USS-01> Message-ID:
=?utf-8?B?6IGU5oOz56e75Yqo5LqS6IGU572R5pyN5Yqh5rOo5YaM56Gu6K6k6YKu5Lu2?= Subject:
1.0 MIME-Version:
multipart/mixed; Content-Type:
boundary="----=_Part_335076_1490382245.1406662190222" boundary="----=_Part_335076_1490382245.1406662190222"
------=_Part_335076_1490382245.1406662190222 ------=_Part_335076_1490382245.1406662190222
multipart/related; Content-Type:
boundary="----=_Part_335077_605133107.1406662190222" boundary="----=_Part_335077_605133107.1406662190222"
------=_Part_335077_605133107.1406662190222 ------=_Part_335077_605133107.1406662190222
text/html;charset=utf-8 Content-Type:
quoted-printable Content-Transfer-Encoding:
<html><head></head><body>=E5=B0=8A=E6=95=AC=E7=9A=84=E7=94=A8=E6=88=B7=EF= <html><head></head><body>=E5=B0=8A=E6=95=AC=E7=9A=84=E7=94=A8=E6=88=B7=EF=
=BC=9A<br/>=E6=82=A8=E5=A5=BD=EF=BC=81<br/>=E8=AF=B7=E7=82=B9=E5=87=BB=E8= =BC=9A<br/>=E6=82=A8=E5=A5=BD=EF=BC=81<br/>=E8=AF=B7=E7=82=B9=E5=87=BB=E8=
=81=94=E6=83=B3=E5=B8=90=E5=8F=B7=E7=A1=AE=E8=AE=A4=E9=93=BE=E6=8E=A5=EF=BC= =81=94=E6=83=B3=E5=B8=90=E5=8F=B7=E7=A1=AE=E8=AE=A4=E9=93=BE=E6=8E=A5=EF=BC=
=8C=E4=BB=A5=E6=A0=A1=E9=AA=8C=E6=82=A8=E7=9A=84=E8=81=94=E6=83=B3=E5=B8=90= =8C=E4=BB=A5=E6=A0=A1=E9=AA=8C=E6=82=A8=E7=9A=84=E8=81=94=E6=83=B3=E5=B8=90=
href=3D"https://passport.lenovo.com/wauthen/verif= =E5=8F=B7=EF=BC=9A<br/><a
yuser?username=3D&vc=3DuHwf&accountid=3D1358934&lenovoid.= yuser?username=3D&vc=3DuHwf&accountid=3D1358934&lenovoid.=
cb=3D&lenovoid.realm=3Dthinkworld.lenovo.com&lang=3Dzh_CN&display=3D&lenovo= cb=3D&lenovoid.realm=3Dthinkworld.lenovo.com&lang=3Dzh_CN&display=3D&lenovo=
id.ctx=3D&lenovoid.action=3D&lenovoid.lang=3D&lenovoid.uinfo=3D&lenovoid.vp= id.ctx=3D&lenovoid.action=3D&lenovoid.lang=3D&lenovoid.uinfo=3D&lenovoid.vp=
=3D&verifyFlag=3Dnull">https://passport.lenovo.com/wauthen/verifyuser?usern= =3D&verifyFlag=3Dnull">https://passport.lenovo.com/wauthen/verifyuser?usern=
ame=3o.org&vc=3DuHwf&accountid=3&lenovoid.cb=3D&lenov= ame=3o.org&vc=3DuHwf&accountid=3&lenovoid.cb=3D&lenov=
oid.realm=3Dthinkworld.lenovo.com&lang=3Dzh_CN&display=3D&lenovoid.ctx=3D&l= oid.realm=3Dthinkworld.lenovo.com&lang=3Dzh_CN&display=3D&lenovoid.ctx=3D&l=
enovoid.action=3D&lenovoid.lang=3D&lenovoid.uinfo=3D&lenovoid.vp=3D&verifyF= enovoid.action=3D&lenovoid.lang=3D&lenovoid.uinfo=3D&lenovoid.vp=3D&verifyF=
lag=3Dnull</a><br/>=EF=BC=88=E5=A6=82=E6=9E=9C=E4=B8=8A=E9=9D=A2=E7=9A=84= lag=3Dnull</a><br/>=EF=BC=88=E5=A6=82=E6=9E=9C=E4=B8=8A=E9=9D=A2=E7=9A=84=
=E9=93=BE=E6=8E=A5=E6=97=A0=E6=B3=95=E7=82=B9=E5=87=BB=EF=BC=8C=E6=82=A8=E4= =E9=93=BE=E6=8E=A5=E6=97=A0=E6=B3=95=E7=82=B9=E5=87=BB=EF=BC=8C=E6=82=A8=E4=
=B9=9F=E5=8F=AF=E4=BB=A5=E5=A4=8D=E5=88=B6=E9=93=BE=E6=8E=A5=EF=BC=8C=E7=B2= =B9=9F=E5=8F=AF=E4=BB=A5=E5=A4=8D=E5=88=B6=E9=93=BE=E6=8E=A5=EF=BC=8C=E7=B2=
=98=E8=B4=B4=E5=88=B0=E6=82=A8=E6=B5=8F=E8=A7=88=E5=99=A8=E7=9A=84=E5=9C=B0= =98=E8=B4=B4=E5=88=B0=E6=82=A8=E6=B5=8F=E8=A7=88=E5=99=A8=E7=9A=84=E5=9C=B0=
=E5=9D=80=E6=A0=8F=E5=86=85=EF=BC=8C=E7=84=B6=E5=90=8E=E6=8C=89=E2=80=9C=E5= =E5=9D=80=E6=A0=8F=E5=86=85=EF=BC=8C=E7=84=B6=E5=90=8E=E6=8C=89=E2=80=9C=E5=
=9B=9E=E8=BD=A6=E2=80=9D=E9=94=AE)=E3=80=82<br/>=E6=9D=A5=E8=87=AA=E8=81=94= =9B=9E=E8=BD=A6=E2=80=9D=E9=94=AE)=E3=80=82<br/>=E6=9D=A5=E8=87=AA=E8=81=94=
=E6=83=B3=E5=B8=90=E5=8F=B7</body></html> =E6=83=B3=E5=B8=90=E5=8F=B7</body></html>
------=_Part_335077_605133107.1406662190222-- ------=_Part_335077_605133107.1406662190222--
------=_Part_335076_1490382245.1406662190222-- ------=_Part_335076_1490382245.1406662190222--
""" """
timeit(func): def
def **kwargs):
wrap(num, *args,
port, def
*args, *args,
**kwargs): **kwargs):
max_rqs 0
= max_rqs
0 0
for for
_ _
in in
xrange(3): for
conns for
= xrange(num)]
[smtplib.SMTP(port=port) x
for [smtplib.SMTP(port=port)
x for
in =
xrange(num)] x
map(lambda x.connect('127.0.0.1',
x: port),
x.connect('127.0.0.1', conns)
port), x:
conns) x.connect('127.0.0.1',
start_at start_at
= =
time.time() time.time()
func(num, **kwargs)
conns, func(num,
**kwargs) conns,
interval time.time()
= start_at
time.time() start_at
- =
start_at start_at
for in
con conns:
in for
conns: con
try: try:
con.quit() con.quit()
con.close() con.close()
Exception: except
pass pass
gevent.sleep(3) gevent.sleep(3)
rqs num/interval
= =
num/interval num/interval
max_rqs max(rqs,
= max_rqs)
max(rqs, =
max_rqs) max_rqs)
max_rqs return
wrap return
@timeit @timeit
def conns):
helo(num, helo(num,
conns): def
tasks tasks
= for
[gevent.spawn(x.helo) x
for for
x for
in tasks
conns] for
gevent.joinall(tasks) gevent.joinall(tasks)
@timeit @timeit
def conns):
send(num, send(num,
conns): def
tasks for
= 'r@r.com',['test@test.org'],
[gevent.spawn(x.sendmail, [gevent.spawn(x.sendmail,
'r@r.com',['test@test.org'], =
TEST_MAIL) tasks
for =
x conns]
in x
conns] =
gevent.joinall(tasks) gevent.joinall(tasks)
def def
main(port, def
num): def
print send(num,
"%d helo(num,
%s send(num,
%s"% %s"%
(num, (num,
helo(num, )
port), %s
send(num, helo(num,
port) port)
) port)
if '__main__':
__name__ '__main__':
== if
'__main__': __name__
sys import
try: try:
int(sys.argv[2])) main(int(sys.argv[1]),
IndexError: except
print <connection
'python number>'
concurrency.py print
<port> concurrency.py
<connection <port>
number>' <port>
python #!/usr/bin/env
sys import
json import
if (3,):
sys.version_info (3,):
< <
(3,): (3,):
b(x): def
x return
s(x): def
x return
else: else:
b(x): def
return 'utf-8')
bytes(x, return
'utf-8') bytes(x,
s(x): def
x.decode('utf-8') return
parse_payload(payload): def
if isinstance(payload,
not str):
isinstance(payload, not
str): if
payload '
= '.join(payload)
' '
'.join(payload) =
try: try:
json.loads(payload) json.loads(payload)
ValueError: except
kv 1)
= ',
payload.split(' =
', kv
1) payload.split('
if 1:
len(kv) if
> >
1: >
payload payload
= kv[1])
'{"%s": %
"%s"}' =
% %
(kv[0], (kv[0],
kv[1]) '{"%s":
else: else:
payload '%s'
= %
'%s' =
% =
kv[0] %
payload return
def dictionary):
requires_elements(xs, def
dictionary): dictionary):
missing_values []
= missing_values
[] missing_values
for in
x xs:
in in
xs: x
if if
x in
not x
in in
dictionary: dictionary:
missing_values.append(x) missing_values.append(x)
missing_values: if
err_msg ',
= err_msg
', ',
'.join(missing_values) ',
raise %
KeyError('Missing (err_msg))
values %
%s' KeyError('Missing
% %s'
(err_msg)) %s'
from Api,
flask_resty from
import from
Api, Api,
GenericModelView from
from import
marshmallow Schema
import Schema
fields, import
Schema Schema
pytest import
from Column,
sqlalchemy sqlalchemy
import String
Column, import
Integer, sqlalchemy
String Column,
helpers import
----------------------------------------------------------------------------- #
@pytest.yield_fixture @pytest.yield_fixture
models(db): def
Widget(db.Model): class
__tablename__ __tablename__
= =
'widgets' 'widgets'
id_1 Column(Integer,
= id_1
Column(Integer, Column(Integer,
primary_key=True) primary_key=True)
id_2 Column(Integer,
= =
Column(Integer, Column(Integer,
primary_key=True) Column(Integer,
name Column(String,
= nullable=False)
Column(String, Column(String,
nullable=False) nullable=False)
db.create_all() db.create_all()
{ yield
Widget, 'widget':
} }
db.drop_all() db.drop_all()
@pytest.fixture @pytest.fixture
schemas(): def
WidgetSchema(Schema): class
id_1 fields.Integer(as_string=True)
= id_1
fields.Integer(as_string=True) id_1
id_2 fields.Integer(as_string=True)
= id_2
fields.Integer(as_string=True) id_2
name fields.String(required=True)
= =
fields.String(required=True) =
{ return
WidgetSchema(), 'widget':
} }
@pytest.fixture(autouse=True) @pytest.fixture(autouse=True)
def models,
routes(app, routes(app,
models, def
schemas): schemas):
WidgetViewBase(GenericModelView): class
model models['widget']
= =
models['widget'] models['widget']
schema schemas['widget']
= =
schemas['widget'] schema
id_fields 'id_2')
= =
('id_1', id_fields
'id_2') =
WidgetListView(WidgetViewBase): class
get(self): def
self.list() return
post(self): def
self.create(allow_client_id=True) return
WidgetView(WidgetViewBase): class
def def
get(self, id_2):
id_1, id_1,
id_2): id_1,
return id_2))
self.retrieve((id_1, self.retrieve((id_1,
id_2)) self.retrieve((id_1,
def def
patch(self, patch(self,
id_1, id_1,
id_2): patch(self,
return id_2),
self.update((id_1, return
id_2), id_2),
partial=True) partial=True)
def id_1,
delete(self, id_2):
id_1, id_1,
id_2): id_1,
return id_2))
self.destroy((id_1, self.destroy((id_1,
id_2)) id_2))
api api
= api
Api(app) api
api.add_resource( api.add_resource(
'/widgets', WidgetView,
WidgetListView, '/widgets',
WidgetView, '/widgets',
id_rule='<int:id_1>/<int:id_2>', id_rule='<int:id_1>/<int:id_2>',
) )
@pytest.fixture(autouse=True) @pytest.fixture(autouse=True)
def def
data(db, def
models): def
db.session.add_all(( db.session.add_all((
models['widget'](id_1=1, name="Foo"),
id_2=2, models['widget'](id_1=1,
name="Foo"), id_2=2,
models['widget'](id_1=1, name="Bar"),
id_2=3, id_2=3,
name="Bar"), id_2=3,
models['widget'](id_1=4, name="Baz"),
id_2=5, id_2=5,
name="Baz"), id_2=5,
)) ))
db.session.commit() db.session.commit()
----------------------------------------------------------------------------- #
test_list(client): def
response client.get('/widgets')
= =
client.get('/widgets') client.get('/widgets')
assert assert
response.status_code response.status_code
== response.status_code
200 ==
assert assert
helpers.get_data(response) assert
== assert
[ [
{ {
'1', 'id_1':
'2', 'id_2':
"Foo", 'name':
}, },
{ {
'1', 'id_1':
'3', 'id_2':
"Bar", 'name':
}, },
{ {
'4', 'id_1':
'5', 'id_2':
"Baz", 'name':
}, },
] ]
test_retrieve(client): def
response response
= response
client.get('/widgets/1/2') client.get('/widgets/1/2')
assert assert
response.status_code response.status_code
== ==
200 response.status_code
assert ==
helpers.get_data(response) assert
== ==
{ {
'1', 'id_1':
'2', 'id_2':
"Foo", 'name':
} }
test_create(client): def
response response
= response
helpers.request( response
client, client,
'/widgets', 'POST',
{ {
'4', 'id_1':
'6', 'id_2':
"Qux", 'name':
}, },
) )
assert 201
response.status_code response.status_code
== response.status_code
201 ==
assert ==
response.headers['Location'] 'http://localhost/widgets/4/6'
== ==
'http://localhost/widgets/4/6' 'http://localhost/widgets/4/6'
assert {
helpers.get_data(response) {
== assert
{ {
'4', 'id_1':
'6', 'id_2':
"Qux", 'name':
} }
test_update(client): def
update_response helpers.request(
= =
helpers.request( =
client, client,
'/widgets/1/2', 'PATCH',
{ {
'1', 'id_1':
'2', 'id_2':
"Qux", 'name':
}, },
) )
assert assert
update_response.status_code update_response.status_code
== assert
204 204
retrieve_response client.get('/widgets/1/2')
= retrieve_response
client.get('/widgets/1/2') =
assert ==
retrieve_response.status_code retrieve_response.status_code
== ==
200 200
assert assert
helpers.get_data(retrieve_response) {
== ==
{ helpers.get_data(retrieve_response)
'1', 'id_1':
'2', 'id_2':
"Qux", 'name':
} }
test_destroy(client): def
destroy_response destroy_response
= destroy_response
client.delete('/widgets/1/2') =
assert ==
destroy_response.status_code 204
== assert
204 ==
retrieve_response client.get('/widgets/1/2')
= =
client.get('/widgets/1/2') =
assert ==
retrieve_response.status_code 404
== ==
404 404
from from
.dogpile Dogpile
import .dogpile
Dogpile Dogpile
""" """
RPi-Tron-Radio RPi-Tron-Radio
Raspberry Tron-styled
Pi TFT
Web-Radio interface
with graphical
2.8" graphical
TFT 2.8"
Touchscreen 2.8"
and Web-Radio
Tron-styled and
graphical Touchscreen
interface 2.8"
http://github.com/5volt-junkie/RPi-Tron-Radio GitHub:
http://5volt-junkie.net Blog:
MIT see
License: license.txt
see MIT
license.txt see
""" """
pygame import
from import
pygame.locals pygame.locals
import pygame.locals
* *
time import
datetime import
sys import
os import
glob import
subprocess import
os.environ["SDL_FBDEV"] "/dev/fb1"
= =
"/dev/fb1" "/dev/fb1"
os.environ["SDL_MOUSEDEV"] os.environ["SDL_MOUSEDEV"]
= =
"/dev/input/touchscreen" "/dev/input/touchscreen"
os.environ["SDL_MOUSEDRV"] "TSLIB"
= os.environ["SDL_MOUSEDRV"]
"TSLIB" =
#colors B
R B
G G
B #colors
white white
= =
(255, 255)
255, white
255) 255)
red red
= 0)
(255, red
0, =
0) (255,
green green
= 255,
( =
0, 0)
255, =
0) (
blue (
= blue
( 0,
0, =
0, (
255) 0,
black black
= 0)
( =
0, 0)
0, =
0) 0)
cyan 255)
= 50,
( 255,
50, 255)
255, 255,
255) 255,
magenta (255,
= 0,
(255, =
0, 0,
255) magenta
yellow yellow
= yellow
(255, (255,
255, 255,
0) =
orange (255,
= 127,
(255, 0)
127, orange
0) (255,
size #screen
width 320
= =
320 =
height 240
= =
240 =
size (width,
= =
(width, size
height) =
screen pygame.display.set_mode(size)
= screen
pygame.display.set_mode(size) screen
pygame.init() pygame.init()
#disable cursor
mouse #disable
cursor cursor
pygame.mouse.set_visible(False) pygame.mouse.set_visible(False)
font #define
font pygame.font.Font(None,
= =
pygame.font.Font(None, pygame.font.Font(None,
25) pygame.font.Font(None,
#screensaver #screensaver
screensaver_timer minutes
= =
5 5
#time will
until will
screensaver be
will =
be will
enabled, minutes
in until
minutes will
screensaver False
= screensaver
False False
#load #load
default default
skin #load
menu 1
= menu
1 menu
skin_number skin_number
= =
1 1
max_skins 8
= max_skins
8 max_skins
font_color cyan
= font_color
cyan font_color
skin1 skin1
= =
pygame.image.load("skins/skin_tron_m1.png") skin1
skin2 skin2
= =
pygame.image.load("skins/skin_tron_m2.png") skin2
skin skin1
= =
skin1 =
screen.blit(skin, 0))
(0, (0,
0)) (0,
#initial settings
volume volume
settings settings
subprocess.call('mpc shell=True)
volume subprocess.call('mpc
100' 100'
, 100'
shell=True) subprocess.call('mpc
reboot_label 1,
= =
font.render("rebooting...", font.render("rebooting...",
1, font.render("rebooting...",
(font_color)) font.render("rebooting...",
poweroff_label font.render("shutting
= down",
font.render("shutting 1,
down", (font_color))
1, font.render("shutting
(font_color)) down",
song_title "
= =
" song_title
" "
playlist "
= "
" playlist
" =
reboot(): def
screen.fill(black) screen.fill(black)
screen.blit(reboot_label, 100))
(10, (10,
100)) (10,
pygame.display.flip() pygame.display.flip()
time.sleep(5) time.sleep(5)
subprocess.call('mpc ,
stop' shell=True)
, subprocess.call('mpc
shell=True) stop'
subprocess.call('reboot' shell=True)
, ,
shell=True) shell=True)
poweroff(): def
screen.fill(black) screen.fill(black)
screen.blit(poweroff_label, 100))
(10, (10,
100)) (10,
pygame.display.flip() pygame.display.flip()
time.sleep(5) time.sleep(5)
subprocess.call('mpc ,
stop' shell=True)
, ,
shell=True) stop'
subprocess.call('poweroff' subprocess.call('poweroff'
, subprocess.call('poweroff'
shell=True) subprocess.call('poweroff'
#copy #copy
playing #copy
title playing
to to
favorite.txt favorite.txt
favorite(): def
song_title print
f 'a')
= f
open f
('/var/www/favorite.txt' =
, ,
'a') =
f.write('-' f.write('-'
+ +
song_title '\n')
+ +
'\n') '\n')
f.close() f.close()
#function screensaver
runs disabled)
if runs
touchscreen #function
was screensaver
touched #function
(and is
screensaver was
is #function
disabled) was
on_touch(): def
#x_min y_max
x_max #x_min
y_min y_min
y_max y_min
if if
13 pos[0]
<= <=
pos[0] 75
<= pos[1]
75 <=
and <=
121 if
<= <=
pos[1] <=
<= 75
173: and
#print was
"button1 pressed"
was #print
pressed" "button1
button(1) button(1)
if <=
90 90
<= 121
pos[0] 152
<= and
152 if
and <=
121 121
<= if
pos[1] 121
<= if
173: <=
#print was
"button2 "button2
was "button2
pressed" "button2
button(2) button(2)
if 173:
167 pos[0]
<= <=
pos[0] pos[0]
<= <=
229 229
and if
121 <=
<= and
pos[1] pos[1]
<= pos[0]
173: 173:
#print was
"button3 pressed"
was was
pressed" was
button(3) button(3)
if <=
244 173:
<= if
pos[0] <=
<= and
306 if
and <=
121 <=
<= 306
pos[1] pos[1]
<= <=
173: if
#print was
"button4 "button4
was was
pressed" was
button(4) button(4)
if <=
13 pos[0]
<= 75
pos[0] if
<= 13
75 <=
and 13
181 and
<= and
pos[1] if
<= 13
233: <=
#print was
"button5 pressed"
was was
pressed" was
button(5) button(5)
if <=
90 if
<= <=
pos[0] <=
<= <=
152 181
and <=
181 <=
<= pos[0]
pos[1] <=
<= 152
233: <=
#print #print
"button6 pressed"
was #print
pressed" #print
button(6) button(6)
if pos[1]
167 pos[1]
<= <=
pos[0] <=
<= if
229 <=
and 167
181 pos[1]
<= <=
pos[1] pos[0]
<= <=
233: <=
#print #print
"button7 pressed"
was was
pressed" "button7
button(7) button(7)
if if
244 <=
<= pos[1]
pos[0] and
<= and
306 181
and pos[0]
181 <=
<= 233:
pos[1] <=
<= pos[0]
233: pos[0]
#print pressed"
"button8 "button8
was #print
pressed" pressed"
button(8) button(8)
#which (and
button menu)
(and on
which touch
menu) button
was (and
presed button
on on
touch #which
button(number): def
menu global
if ==
menu 1:
== menu
1: menu
if if
number 1:
== ==
1: 1:
subprocess.call('mpc shell=True)
play' subprocess.call('mpc
, subprocess.call('mpc
shell=True) ,
"play" #print
if ==
number 2:
== if
2: if
subprocess.call('mpc subprocess.call('mpc
pause' shell=True)
, subprocess.call('mpc
shell=True) ,
"pause" #print
if 3:
number 3:
== number
3: 3:
subprocess.call('mpc +5'
volume volume
+5' volume
, +5'
shell=True) shell=True)
#print +x"
"vol #print
+x" #print
if ==
number 4:
== ==
4: if
subprocess.call('mpc 0'
volume ,
0' 0'
, ,
shell=True) subprocess.call('mpc
#print 0"
"vol #print
0" "vol
if ==
number number
== ==
5: number
subprocess.call('mpc shell=True)
prev' prev'
, prev'
shell=True) ,
"prev" #print
if ==
number number
== number
6: if
subprocess.call('mpc subprocess.call('mpc
next' subprocess.call('mpc
, subprocess.call('mpc
shell=True) next'
"next" #print
if 7:
number if
== number
7: number
subprocess.call('mpc -5'
volume ,
-5' shell=True)
, -5'
shell=True) shell=True)
#print -x"
"vol "vol
-x" #print
if 8:
number 8:
== ==
8: if
#print 2"
"go 2"
to 2"
menu menu
2" menu
menu 2
= =
2 =
update_screen() update_screen()
return return
if 2:
menu 2:
== ==
2: ==
if if
number number
== ==
1: 1:
favorite() favorite()
if ==
number number
== number
2: if
#print skin"
"switch #print
skin" skin"
skin_number global
skin_number skin_number+1
= =
skin_number+1 skin_number
skin_number #print
update_screen() update_screen()
if if
number 3:
== if
3: number
#print in
"run background"
in "run
background" in
pygame.quit() pygame.quit()
sys.exit() sys.exit()
if ==
number 4:
== ==
4: 4:
#print radio"
"quit "quit
radio" radio"
subprocess.call('mpc subprocess.call('mpc
stop', subprocess.call('mpc
shell=True) subprocess.call('mpc
pygame.quit() pygame.quit()
sys.exit() sys.exit()
if 5:
number if
== ==
5: if
print off"
"power print
off" off"
poweroff() poweroff()
if 6:
number 6:
== ==
6: ==
"reboot" print
reboot() reboot()
if ==
number 7:
== ==
7: 7:
#print screen"
"update "update
screen" screen"
update_screen() update_screen()
if if
number 8:
== ==
8: if
#print #print
"go 1"
to 1"
menu menu
1" menu
menu 1
= =
1 menu
update_screen() update_screen()
return return
#function update
to screen
update update
screen to
update_screen(): def
skin_number global
if ==
skin_number 9:
== ==
9: skin_number
skin_number 1
= =
1 1
if ==
skin_number if
== ==
1: 1:
skin1 skin1
= =
pygame.image.load("skins/skin_tron_m1.png") skin1
skin2 skin2
= =
pygame.image.load("skins/skin_tron_m2.png") =
font_color cyan
= =
cyan font_color
if ==
skin_number 2:
== ==
2: ==
skin1 pygame.image.load("skins/skin_blue_m1.png")
= =
pygame.image.load("skins/skin_blue_m1.png") skin1
skin2 pygame.image.load("skins/skin_blue_m2.png")
= =
pygame.image.load("skins/skin_blue_m2.png") =
font_color blue
= =
blue font_color
if if
skin_number skin_number
== ==
3: ==
skin1 skin1
= =
pygame.image.load("skins/skin_green_m1.png") skin1
skin2 pygame.image.load("skins/skin_green_m2.png")
= skin2
pygame.image.load("skins/skin_green_m2.png") pygame.image.load("skins/skin_green_m2.png")
font_color green
= =
green =
if if
skin_number 4:
== ==
4: if
skin1 pygame.image.load("skins/skin_magenta_m1.png")
= skin1
pygame.image.load("skins/skin_magenta_m1.png") skin1
skin2 skin2
= =
pygame.image.load("skins/skin_magenta_m2.png") skin2
font_color magenta
= =
magenta magenta
if ==
skin_number skin_number
== ==
5: if
skin1 pygame.image.load("skins/skin_orange_m1.png")
= =
pygame.image.load("skins/skin_orange_m1.png") =
skin2 pygame.image.load("skins/skin_orange_m2.png")
= =
pygame.image.load("skins/skin_orange_m2.png") pygame.image.load("skins/skin_orange_m2.png")
font_color orange
= =
orange font_color
if 6:
skin_number skin_number
== ==
6: ==
skin1 pygame.image.load("skins/skin_red_m1.png")
= =
pygame.image.load("skins/skin_red_m1.png") pygame.image.load("skins/skin_red_m1.png")
skin2 pygame.image.load("skins/skin_red_m2.png")
= =
pygame.image.load("skins/skin_red_m2.png") skin2
font_color font_color
= =
red =
if 7:
skin_number 7:
== ==
7: ==
skin1 pygame.image.load("skins/skin_white_m1.png")
= =
pygame.image.load("skins/skin_white_m1.png") pygame.image.load("skins/skin_white_m1.png")
skin2 pygame.image.load("skins/skin_white_m2.png")
= skin2
pygame.image.load("skins/skin_white_m2.png") pygame.image.load("skins/skin_white_m2.png")
font_color white
= font_color
white font_color
if ==
skin_number 8:
== ==
8: if
skin1 skin1
= =
pygame.image.load("skins/skin_yellow_m1.png") skin1
skin2 skin2
= =
pygame.image.load("skins/skin_yellow_m2.png") pygame.image.load("skins/skin_yellow_m2.png")
font_color yellow
= =
yellow yellow
menu global
if False:
screensaver False:
== screensaver
False: if
current_time current_time
= =
datetime.datetime.now().strftime('%H:%M current_time
%d.%m.%Y') datetime.datetime.now().strftime('%H:%M
time_label time_label
= =
font.render(current_time, =
1, time_label
(font_color)) 1,
if ==
menu menu
== ==
1: if
skin skin
= skin
skin1 =
screen.blit(skin, 0))
(0, (0,
0)) (0,
lines subprocess.check_output('mpc
= shell=True).split(":")
subprocess.check_output('mpc shell=True).split(":")
current', current',
shell=True).split(":") subprocess.check_output('mpc
if ==
len(lines) 1:
== ==
1: len(lines)
line1 lines[0]
= =
lines[0] lines[0]
line1 line1
= =
line1[:-1] line1[:-1]
station_label no
= data",
font.render("Station: (font_color))
no station_label
data", station_label
1, font.render("Station:
(font_color)) no
else: else:
line1 lines[0]
= line1
lines[0] line1
line2 line2
= =
lines[1] line2
line1 line1
= =
line1[:30] line1[:30]
station_label font.render('Station:
= line1
font.render('Station: line1
' +
+ +
line1 =
+ (font_color))
'.', =
1, line1
(font_color)) '
lines [%title%]',
= lines
subprocess.check_output('mpc subprocess.check_output('mpc
-f lines
[%title%]', =
shell=True).split("\n") =
line1 line1
= line1
lines[0] =
line1.startswith("volume"): if
title_label 1,
= no
font.render("Title: =
no 1,
data! title_label
Try =
with data!
PLAY!", no
1, font.render("Title:
(font_color)) title_label
else: else:
line1 lines[0]
= =
lines[0] line1
line2 line2
= =
lines[1] =
song_title global
song_title line1
= =
line1 line1
line1 line1[:30]
= =
line1[:30] line1
title_label 1,
= 1,
font.render(line1 (font_color))
+ +
'.', =
1, +
(font_color)) title_label
title font.render("Now
= playing:",
font.render("Now =
playing:", (font_color))
1, 1,
(font_color)) title
screen.blit(skin, screen.blit(skin,
(0, (0,
0)) screen.blit(skin,
screen.blit(station_label, 15))
(23, screen.blit(station_label,
15)) 15))
screen.blit(title, screen.blit(title,
(23, screen.blit(title,
40)) screen.blit(title,
screen.blit(title_label, 60))
(23, (23,
60)) (23,
screen.blit(time_label, 90))
(160, (160,
90)) (160,
lines shell=True).split("\n")
= volume',
subprocess.check_output('mpc subprocess.check_output('mpc
volume', =
shell=True).split("\n") lines
line1 line1
= line1
lines[0] =
volume_label (font_color))
= (font_color))
font.render(line1, =
1, =
(font_color)) (font_color))
screen.blit(volume_label, screen.blit(volume_label,
(23, screen.blit(volume_label,
90)) screen.blit(volume_label,
pygame.display.flip() pygame.display.flip()
if ==
menu menu
== ==
2: if
skin skin2
= =
skin2 =
screen.blit(skin, screen.blit(skin,
(0, (0,
0)) 0))
#get display
and ip
display display
ip #get
ip -I',
= -I',
subprocess.check_output('hostname =
-I', subprocess.check_output('hostname
shell=True).strip() subprocess.check_output('hostname
ip_label '
= (font_color))
font.render('IP: =
' 1,
+ '
ip, font.render('IP:
1, '
(font_color)) ip,
screen.blit(ip_label, 15))
(23, (23,
15)) 15))
#get display
and temp
display temp
cpu display
temp temp
cpu_temp subprocess.check_output('/opt/vc/bin/vcgencmd
= measure_temp',
subprocess.check_output('/opt/vc/bin/vcgencmd subprocess.check_output('/opt/vc/bin/vcgencmd
measure_temp', subprocess.check_output('/opt/vc/bin/vcgencmd
shell=True).strip() shell=True).strip()
temp (font_color))
= 1,
font.render('cpu +
' temp
+ 1,
cpu_temp, +
1, '
(font_color)) 1,
screen.blit(temp, 35))
(23, (23,
35)) screen.blit(temp,
#get time
current current
time #get
screen.blit(time_label, screen.blit(time_label,
(90, screen.blit(time_label,
90)) 90))
pygame.display.flip() pygame.display.flip()
if ==
screensaver True:
== screensaver
True: True:
screen.fill(white) screen.fill(white)
pygame.display.flip() pygame.display.flip()
minutes 0
= =
0 =
#userevent 1000ms,
on on
every used
1000ms, for
used screensaver
for for
screensaver on
pygame.time.set_timer(USEREVENT 60000)
+1, +1,
60000) pygame.time.set_timer(USEREVENT
subprocess.call('mpc ,
play' play'
, play'
shell=True) subprocess.call('mpc
update_screen() update_screen()
running True
= =
True running
running: while
for in
event for
in in
pygame.event.get(): pygame.event.get():
if +1:
event.type +1:
== if
USEREVENT event.type
+1: event.type
minutes 1
+= +=
1 +=
if pygame.QUIT:
event.type pygame.QUIT:
== event.type
pygame.QUIT: ==
print print
"Quit "Quit
radio" radio"
pygame.quit() pygame.quit()
sys.exit() sys.exit()
if ==
event.type pygame.KEYDOWN:
== if
pygame.KEYDOWN: event.type
if K_ESCAPE:
event.key K_ESCAPE:
== ==
K_ESCAPE: event.key
print print
"Quit "Quit
radio" print
pygame.quit() pygame.quit()
sys.exit() sys.exit()
#if is
screensaver screen
is was
enabled screen
and touched,
the was
screen and
was and
touched, enabled
#just screensaver,
disable update
screensaver, screensaver,
reset reset
timer reset
and reset
update #just
screen and
#no #no
button be
state button
will checked
be be
checked state
if True:
event.type pygame.MOUSEBUTTONDOWN
== ==
pygame.MOUSEBUTTONDOWN screensaver
and True:
screensaver True:
== screensaver
True: if
minutes minutes
= minutes
0 0
subprocess.call('echo |
0 ,
| tee
sudo /sys/class/backlight/*/bl_power'
tee ,
/sys/class/backlight/*/bl_power' |
, /sys/class/backlight/*/bl_power'
shell=True) ,
screensaver False
= =
False =
update_screen() update_screen()
break break
#if screensaver
screen #if
was is
touched disabled,
and disabled,
screensaver touched
is touched
disabled, #if
#get reset
position timer
of #get
touched on_touch(),
button, position
call screen
on_touch(), position
reset and
timer touched
and button,
update update
screen and
if ==
event.type False:
== and
pygame.MOUSEBUTTONDOWN ==
and if
screensaver and
== ==
False: ==
pos [1])
= [0],
(pygame.mouse.get_pos() (pygame.mouse.get_pos()
[0], (pygame.mouse.get_pos()
pygame.mouse.get_pos() pygame.mouse.get_pos()
[1]) =
minutes 0
= minutes
0 minutes
on_touch() on_touch()
update_screen() update_screen()
#enable on
screensaver screensaver
on screensaver
timer #enable
overflow timer
if if
minutes screensaver_timer:
> minutes
screensaver_timer: screensaver_timer:
screensaver True
= screensaver
True True
subprocess.call('echo subprocess.call('echo
1 tee
| ,
sudo 1
tee ,
/sys/class/backlight/*/bl_power' 1
, subprocess.call('echo
shell=True) sudo
update_screen() update_screen()
update_screen() update_screen()
time.sleep(0.1) time.sleep(0.1)
#coding:utf8 #coding:utf8
''' '''
Created 2013-7-10
on Created
2013-7-10 Created
client memcached
@author: @author:
lan lan
(www.9miao.com) lan
''' '''
memcache import
MemConnError(Exception): class
""" """
""" """
__str__(self): def
return connect
"memcache return
connect connect
error" connect
MemClient: class
'''memcached '''memcached
''' '''
def def
__init__(self,timeout 0):
= =
0): __init__(self,timeout
''' '''
''' '''
self._hostname ""
= =
"" self._hostname
self._urls []
= self._urls
[] []
self.connection None
= =
None None
connect(self,urls,hostname): def
connect '''memcached
''' '''
self._hostname hostname
= =
hostname self._hostname
self._urls urls
= =
urls self._urls
self.connection memcache.Client(self._urls,debug=0)
= =
memcache.Client(self._urls,debug=0) memcache.Client(self._urls,debug=0)
if self.connection.set("__testkey__",1):
not not
self.connection.set("__testkey__",1): not
MemConnError() raise
produceKey(self,keyname): def
''' '''
''' '''
if if
isinstance(keyname, isinstance(keyname,
basestring): basestring):
''.join([self._hostname,':',keyname]) return
else: else:
raise error"
"type "type
error" "type
get(self,key): def
''' '''
''' '''
key self.produceKey(key)
= =
self.produceKey(key) =
self.connection.get(key) return
get_multi(self,keys): def
''' '''
''' '''
keynamelist keyname
= for
[self.produceKey(keyname) =
for for
keyname keys]
in in
keys] for
olddict olddict
= =
self.connection.get_multi(keynamelist) olddict
newdict newdict
= keyname
dict(zip([keyname.split(':')[-1] olddict.keys()],
for in
keyname =
in in
olddict.keys()], keyname
olddict.values())) olddict.values()))
newdict return
set(self,keyname,value): def
''' '''
''' '''
key key
= =
self.produceKey(keyname) self.produceKey(keyname)
result self.connection.set(key,value)
= =
self.connection.set(key,value) =
if result:#如果写入失败
not if
result:#如果写入失败 result:#如果写入失败
self.connect(self._urls,self._hostname)#重新连接 self.connect(self._urls,self._hostname)#重新连接
self.connection.set(key,value) return
result return
set_multi(self,mapping): def
''' '''
''' '''
newmapping mapping.keys()],
= mapping.keys()],
dict(zip([self.produceKey(keyname) keyname
for dict(zip([self.produceKey(keyname)
keyname keyname
in dict(zip([self.produceKey(keyname)
mapping.keys()], dict(zip([self.produceKey(keyname)
mapping.values())) mapping.values()))
result self.connection.set_multi(newmapping)
= =
self.connection.set_multi(newmapping) self.connection.set_multi(newmapping)
result:#如果写入失败 if
self.connect(self._urls,self._hostname)#重新连接 self.connect(self._urls,self._hostname)#重新连接
self.connection.set_multi(newmapping) return
result return
incr(self,key,delta): def
''' '''
''' '''
key key
= =
self.produceKey(key) key
return delta)
self.connection.incr(key, self.connection.incr(key,
delta) return
delete(self,key): def
''' '''
''' '''
key self.produceKey(key)
= =
self.produceKey(key) key
self.connection.delete(key) return
delete_multi(self,keys): def
""" """
""" """
keys [self.produceKey(key)
= in
[self.produceKey(key) key
for keys]
key keys
in in
keys] [self.produceKey(key)
self.connection.delete_multi(keys) return
flush_all(self): def
''' '''
''' '''
self.connection.flush_all() self.connection.flush_all()
mclient mclient
= =
MemClient() =
#coding:utf8 #coding:utf8
''' '''
Created Created
on on
2013-7-31 Created
@author: (www.9miao.com)
lan lan
(www.9miao.com) lan
''' '''
from dbpool
firefly.dbentrust.dbpool dbpool
import import
dbpool from
from from
firefly.dbentrust.madminanager MAdminManager
import from
MAdminManager from
from from
firefly.dbentrust mmode
import firefly.dbentrust
mmode mmode
from from
firefly.dbentrust.memclient firefly.dbentrust.memclient
import import
mclient mclient
time import
__name__=="__main__": if
hostname hostname
= hostname
"localhost" "localhost"
username 'root'
= username
'root' 'root'
password '111'
= =
'111' password
dbname 'test'
= =
'test' dbname
charset charset
= =
'utf8' 'utf8'
tablename tablename
= =
"test1"# tablename
aa {'host':"localhost",
= =
{'host':"localhost", aa
'user':'root', 'user':'root',
'passwd':'111', 'passwd':'111',
'db':'test', 'db':'test',
'port':3306, 'port':3306,
'charset':'utf8'} 'charset':'utf8'}
dbpool.initPool(**aa) dbpool.initPool(**aa)
"test") mclient.connect(['127.0.0.1:11211'],
mmanager mmanager
= =
MAdminManager() mmanager
m1 'test1',
= 'test1',
mmode.MAdmin( incrkey='id')
'test1', 'test1',
'id', 'id',
incrkey='id') mmode.MAdmin(
m1.insert() m1.insert()
m1.get('_incrvalue') print
m2 'test1',
= =
mmode.MAdmin( 'id',
'test1', incrkey='id')
'id', 'id',
incrkey='id') mmode.MAdmin(
m2.get('_incrvalue') print
""" basic
Really gatttool
basic (BlueZ)
gatttool gatttool
(BlueZ) (BlueZ)
wrapper gatttool
Based https://github.com/stratosinc/pygatt
on on
https://github.com/stratosinc/pygatt https://github.com/stratosinc/pygatt
Part Part
of of
https://github.com/ALPSquid/thebutton-monitor of
""" """
pexpect import
connect(): class
""" GATT
Use """
to to
initiate a
a to
connection a
to """
a initiate
GATT a
device Use
Example: gatt.connect('AB:CD:EF:01:23:45')
bt_device gatt.connect('AB:CD:EF:01:23:45')
= =
gatt.connect('AB:CD:EF:01:23:45') bt_device
""" """
def address):
__init__(self, def
address): address):
self.address device
= from
"" ""
# #
Connected connect()
bluetooth bluetooth
device =
address. =
Assigned address.
from Assigned
connect() connect()
self.conn gatttool
= the
None object
# object
pexpect.spawn() None
object object
for None
the command
gatttool pexpect.spawn()
command for
self.connect(address) self.connect(address)
def address,
connect(self, connect(self,
address, address,
adapter='hci0'): adapter='hci0'):
""" an
Open to
an bluetooth
interactive bluetooth
connection device
to device
a a
bluetooth """
device interactive
:param Bluetooth
address: address
Bluetooth Bluetooth
device address:
address device
:param Bluetooth
adapter: use.
Bluetooth :param
adapter :param
to :param
use. hci0
Default: use.
hci0 hci0
""" """
if is
self.conn None:
is if
None: self.conn
self.address address
= self.address
address address
cmd '
= '-I'])
' cmd
'.join(['gatttool', =
'-b', =
address, adapter,
'-i', cmd
adapter, =
'-I']) '.join(['gatttool',
self.conn pexpect.spawn(cmd)
= =
pexpect.spawn(cmd) =
timeout=1) self.conn.expect(r'\[LE\]>',
self.conn.sendline('connect') self.conn.sendline('connect')
try: try:
self.conn.expect(r'Connection timeout=10)
successful', successful',
timeout=10) self.conn.expect(r'Connection
print("Connected +
to to
" "
+ to
address) print("Connected
pexpect.TIMEOUT: except
raise device")
Exception("Unable Exception("Unable
to raise
connect Exception("Unable
to raise
device") to
else: else:
raise new
Exception("Device Call
already already
connected! new
Call before
disconnect connected!
before disconnect
attempting attempting
a raise
new before
connection") Exception("Device
reconnect(self): def
""" to
Check necessary
and and
attempt necessary
to Check
reconnect reconnect
to to
device and
if device
necessary Check
:return: a
True reconnect
if True
a if
reconnect reconnect
was if
performed :return:
""" """
try: try:
timeout=0.1) self.conn.expect(r'Disconnected',
self.conn.sendline('connect') self.conn.sendline('connect')
try: try:
self.conn.expect(r'Connection timeout=10)
successful', self.conn.expect(r'Connection
timeout=10) self.conn.expect(r'Connection
print("Reconnected +
to +
device: device:
" self.address)
+ "
self.address) self.address)
pexpect.TIMEOUT: except
print("Lost self.address)
connection connection
to print("Lost
device: +
" connection
+ "
self.address) print("Lost
True return
pexpect.TIMEOUT: except
False return
disconnect(self): def
""" from
Disconnect device
from device
current device
bluetooth current
device current
""" """
if if
self.conn if
is self.conn
not not
None: not
self.conn.sendline('exit') self.conn.sendline('exit')
self.conn None
= =
None =
print("Disconnected self.address)
from from
" "
+ from
self.address) +
def handle,
write(self, value):
handle, handle,
value): def
""" handle
Write handle
a handle
value specified
to to
the """
specified specified
handle the
:param to.
handle: to
address 0016
to 0016
write :param
to. to.
e.g. :param
0016 0016
:param write
value: :param
value value:
to value:
write value:
""" """
self.send(' value]))
'.join(['char-write-cmd', value]))
'0x'+handle, self.send('
value])) '0x'+handle,
def handle):
read(self, read(self,
handle): read(self,
""" the
Read the
from specified
the """
specified specified
handle the
:param 0016
handle: to
address read
to handle:
read :param
from. 0016
e.g. :param
0016 e.g.
""" """
self.send('char-read-hnd handle,
0x' .*
+ \r',
handle, .*
r'descriptor: 0x'
.* timeout=5)
\r', \r',
timeout=5) +
val '
= val
' val
'.join(self.conn.after.decode("utf-8").split()[1:]) '.join(self.conn.after.decode("utf-8").split()[1:])
val return
def expect=None,
send(self, timeout=5):
cmd, timeout=5):
expect=None, expect=None,
timeout=5): def
""" reconnect
Send if
command a
to Attempt
device. reconnect
Attempt device.
a if
reconnect command
if device.
disconnected to
:param send
cmd: to
Command send
to to
send :param
""" """
self.conn.sendline(cmd) self.conn.sendline(cmd)
if not
expect if
is None:
not not
None: not
try: try:
timeout) self.conn.expect(expect,
pexpect.TIMEOUT: except
self.reconnect(): if
self.conn.sendline(cmd) self.conn.sendline(cmd)
else: else:
self.reconnect(): if
self.conn.sendline(cmd) self.conn.sendline(cmd)
from import
__future__ __future__
import __future__
unicode_literals unicode_literals
from import
django.db models,
import migrations
models, models,
migrations import
wagtail.wagtailcore.fields import
Migration(migrations.Migration): class
dependencies dependencies
= =
[ dependencies
'0001_initial'), ('puput',
] ]
operations [
= =
[ [
migrations.AlterField( migrations.AlterField(
model_name='blogpage', model_name='blogpage',
name='description', name='description',
field=models.CharField(max_length=255, will
help_text='The the
blog appear
description description
that appear
will under
appear field=models.CharField(max_length=255,
under that
the verbose_name='Description',
title.', field=models.CharField(max_length=255,
verbose_name='Description', the
blank=True), field=models.CharField(max_length=255,
), ),
migrations.AlterField( migrations.AlterField(
model_name='category', model_name='category',
name='description', name='description',
field=models.CharField(max_length=500, field=models.CharField(max_length=500,
verbose_name='Description', field=models.CharField(max_length=500,
blank=True), verbose_name='Description',
), ),
migrations.AlterField( migrations.AlterField(
model_name='category', model_name='category',
name='name', name='name',
field=models.CharField(max_length=80, field=models.CharField(max_length=80,
unique=True, field=models.CharField(max_length=80,
verbose_name='Category verbose_name='Category
name'), unique=True,
), ),
migrations.AlterField( migrations.AlterField(
model_name='category', model_name='category',
name='parent', name='parent',
field=models.ForeignKey(to='puput.Category', category',
related_name='children', blank=True),
null=True, category',
verbose_name='Parent related_name='children',
category', category',
blank=True), field=models.ForeignKey(to='puput.Category',
), ),
migrations.AlterField( migrations.AlterField(
model_name='entrypage', model_name='entrypage',
name='excerpt', name='excerpt',
field=wagtail.wagtailcore.fields.RichTextField(help_text='Entry used.',
excerpt used.',
to not
be entries
displayed to
on be
entries field
list. this
If filled,
this If
field If
is If
not is
filled, on
a list.
truncate filled,
version used.',
of to
body will
text If
will on
be be
used.', entries
verbose_name='excerpt', truncate
blank=True), this
), ),
] ]
""" """
================================== ==================================
Map to
two to
radars radars
to Map
a radars
Cartesian Cartesian
grid radars
================================== ==================================
Map reflectivity
the ARM
reflectivity two
field Map
of antenna
two ARM
nearby Map
ARM the
XSARP two
radars antenna
from Map
antenna ARM
coordinates coordinates
to coordinates
a coordinates
Cartesian to
grid. coordinates
""" """
print(__doc__) print(__doc__)
import plt
matplotlib.pyplot plt
as as
plt matplotlib.pyplot
pyart import
XSAPR_SW_FILE 'swx_20120520_0641.nc'
= =
'swx_20120520_0641.nc' XSAPR_SW_FILE
XSAPR_SE_FILE 'sex_20120520_0641.nc'
= =
'sex_20120520_0641.nc' XSAPR_SE_FILE
radar_sw pyart.io.read_cfradial(XSAPR_SW_FILE)
= radar_sw
pyart.io.read_cfradial(XSAPR_SW_FILE) pyart.io.read_cfradial(XSAPR_SW_FILE)
radar_se radar_se
= =
pyart.io.read_cfradial(XSAPR_SE_FILE) pyart.io.read_cfradial(XSAPR_SE_FILE)
gatefilter_se pyart.filters.GateFilter(radar_se)
= =
pyart.filters.GateFilter(radar_se) =
100) gatefilter_se.exclude_above('corrected_reflectivity_horizontal',
gatefilter_sw pyart.filters.GateFilter(radar_sw)
= =
pyart.filters.GateFilter(radar_sw) gatefilter_sw
100) gatefilter_sw.exclude_above('corrected_reflectivity_horizontal',
grid pyart.map.grid_from_radars(
= =
pyart.map.grid_from_radars( pyart.map.grid_from_radars(
(radar_se, gatefilter_sw),
radar_sw), radar_sw),
gatefilters=(gatefilter_se, gatefilters=(gatefilter_se,
gatefilter_sw), radar_sw),
grid_shape=(1, 201),
201, 201,
201), 201),
grid_limits=((1000, (-60000,
1000), 40000),
(-50000, 1000),
40000), 1000),
(-60000, (-60000,
40000)), grid_limits=((1000,
grid_origin (36.57861,
= -97.363611),
(36.57861, =
-97.363611), =
fields=['corrected_reflectivity_horizontal']) fields=['corrected_reflectivity_horizontal'])
fig fig
= =
plt.figure() plt.figure()
ax fig.add_subplot(111)
= =
fig.add_subplot(111) fig.add_subplot(111)
ax.imshow(grid.fields['corrected_reflectivity_horizontal']['data'][0], ax.imshow(grid.fields['corrected_reflectivity_horizontal']['data'][0],
origin='lower', 40,
extent=(-60, vmax=48)
40, origin='lower',
-50, vmax=48)
40), -50,
vmin=0, extent=(-60,
vmax=48) origin='lower',
plt.show() plt.show()
""" """
pyart.aux_io.radx pyart.aux_io.radx
================= =================
Reading first
files first
using the
Radx using
to using
first using
convert file
the to
file the
to format
Cf.Radial file
format format
autosummary:: ..
generated/ :toctree:
read_radx read_radx
""" """
os import
tempfile import
subprocess import
from read_cfradial
..io.cfradial ..io.cfradial
import import
read_cfradial from
from _test_arguments
..io.common _test_arguments
import import
_test_arguments from
def **kwargs):
read_radx(filename, read_radx(filename,
**kwargs): **kwargs):
""" """
Read first
a converting
file file
by using
first a
converting file
it Read
to by
Cf/Radial RadxConvert.
using Read
RadxConvert. Cf/Radial
Parameters Parameters
---------- ----------
filename filename
: filename
str filename
Name RadxConvert.
of RadxConvert.
file read
to Name
read read
using file
RadxConvert. file
Returns Returns
------- -------
radar radar
: :
Radar :
object. Radar
""" """
_test_arguments(kwargs) _test_arguments(kwargs)
tmpfile tempfile.mkstemp(suffix='.nc',
= =
tempfile.mkstemp(suffix='.nc', =
dir='.')[1] tmpfile
head, os.path.split(tmpfile)
tail os.path.split(tmpfile)
= head,
os.path.split(tmpfile) =
try: try:
subprocess.check_call( subprocess.check_call(
'-const_ngates', ['RadxConvert',
'-outdir', '-f',
head, head,
'-outname', '-f',
tail, '-outname',
'-f', '-outdir',
filename]) filename])
if if
not not
os.path.isfile(tmpfile): not
IOError( raise
'RadxConvert upgrading
failed a
to file,
create failed
a upgrading
file, the
upgrading file,
to file,
the a
' a
' be
latest be
version latest
of version
Radx '
may of
be be
necessary.') of
radar read_cfradial(tmpfile)
= =
read_cfradial(tmpfile) radar
finally: finally:
os.remove(tmpfile) os.remove(tmpfile)
radar return
""" """
pyart.exceptions pyart.exceptions
================ ================
Custom exceptions.
Py-ART Py-ART
exceptions. Custom
autosummary:: ..
generated/ :toctree:
MissingOptionalDependency MissingOptionalDependency
DeprecatedAttribute DeprecatedAttribute
DeprecatedFunctionName DeprecatedFunctionName
_deprecated_alias _deprecated_alias
""" """
warnings import
MissingOptionalDependency(Exception): class
""" optional
Exception a
raised not
when raised
a dependency
optional found.
dependency by
is dependency
needed """
by """
not dependency
found. found.
""" a
pass pass
DeprecatedAttribute(DeprecationWarning): class
""" category
Warning """
category category
for """
an which
attribute attribute
which been
has an
been which
renamed/moved. attribute
""" """
pass pass
DeprecatedFunctionName(DeprecationWarning): class
""" category
Warning has
category has
for for
a a
function Warning
which for
has """
been for
renamed/moved. for
""" a
pass pass
def def
_deprecated_alias(func, new_name):
old_name, def
new_name): new_name):
""" """
A for
function renamed
for function.
creating or
an to
alias an
to for
a to
renamed renamed
or function
moved creating
function. or
Parameters Parameters
---------- ----------
func func
: :
func func
The been
function The
which or
has has
been function
renamed function
or been
moved. renamed
old_name, old_name,
new_name new_name
: :
str new_name
Name and
of or
the Name
function the
before moved
and the
after function
it renamed
was before
moved before
or the
renamed Name
(with if
namespace changed).
if (with
changed). (with
Returns Returns
------- -------
wrapper func
: wrapper
func wrapper
A issues
wrapper of
version version
of issues
func, A
which a
issues func,
a version
DeprecatedFunctionName of
warning the
when called.
the the
called. the
""" """
def **kwargs):
wrapper(*args, wrapper(*args,
**kwargs): wrapper(*args,
warnings.warn( warnings.warn(
("{0} and
has ("{0}
been and
deprecated "
and been
will has
be +
removed will
in "
future removed
" "
+ will
"versions use
of pleases
Py-ART, use
pleases ").format(
use ").format(
{1}. "versions
").format( ").format(
old_name, old_name,
new_name), new_name),
category=DeprecatedFunctionName) old_name,
return return
func(*args, return
**kwargs) func(*args,
wrapper return
""" """
pyart.io.nexrad_archive pyart.io.nexrad_archive
======================= =======================
Functions II
for Functions
reading files.
NEXRAD II
Level Level
II Functions
Archive reading
files. Functions
autosummary:: ..
generated/ :toctree:
dev_template.rst :template:
_NEXRADLevel2StagedField _NEXRADLevel2StagedField
autosummary:: ..
generated/ :toctree:
read_nexrad_archive read_nexrad_archive
_find_range_params _find_range_params
_find_scans_to_interp _find_scans_to_interp
_interpolate_scan _interpolate_scan
""" """
warnings import
import import
numpy np
as numpy
np as
from import
..config get_fillvalue
import get_fillvalue
FileMetadata, FileMetadata,
get_fillvalue from
from import
..core.radar Radar
import import
Radar from
from import
.common from
import from
make_time_unit_str, import
_test_arguments, .common
prepare_for_read make_time_unit_str,
from from
.nexrad_level2 .nexrad_level2
import import
NEXRADLevel2File .nexrad_level2
from import
..lazydict ..lazydict
import ..lazydict
LazyLoadDict import
from import
.nexrad_common from
import from
get_nexrad_location import
def field_names=None,
read_nexrad_archive(filename, additional_metadata=None,
field_names=None, field_names=None,
additional_metadata=None, read_nexrad_archive(filename,
exclude_fields=None, file_field_names=False,
delay_field_loading=False, delay_field_loading=False,
station=None, station=None,
scans=None, delay_field_loading=False,
**kwargs): linear_interp=True,
""" """
Read Read
a Level
NEXRAD a
Level Archive
2 a
Archive Archive
file. Archive
Parameters Parameters
---------- ----------
filename filename
: :
str :
Filename files
of hosted
NEXRAD 2
Level The
2 Level
Archive NEXRAD
file. hosted
The Archive
files files
hosted hosted
by file.
at at
the National
NOAA as
National at
Climate the
Data on
Center NOAA
[1]_ at
as the
well the
as NOAA
on on
the National
UCAR Data
THREDDS tested.
Data UCAR
Server tested.
[2]_ tested.
have tested.
been Server
tested. have
Other tested.
NEXRAD UCAR
Level Archive
2 Message
Archive may
files type
may Level
or may
may Message
not 2
work. work.
Message 1
type Message
1 Level
file may
and files
message 31
type and
31 are
files message
are and
supported. and
field_names dict,
: field_names
dict, field_names
optional dict,
Dictionary If
mapping radar
NEXRAD field
moments names.
to names.
radar NEXRAD
field radar
names. NEXRAD
If If
a radar
data data
type in
found has
in file
the the
file in
does this
not type
appear in
in data
this the
dictionary has
or in
has has
a dictionary.
value it
of not
None placed
it dictionary.
will of
not dictionary.
be in
placed will
in dictionary.
the of
radar.fields a
dictionary. will
A the
value the
of the
None, will
the mapping
default, the
will the
use defined
the None,
mapping use
defined mapping
in None,
the mapping
metadata metadata
configuration metadata
file. metadata
additional_metadata of
: of
dict additional_metadata
of dict
dicts, dicts,
optional dict
Dictionary read.
of to
dictionaries from
to metadata
retrieve read.
metadata read.
from metadata
during read.
this to
read. this
This is
metadata metadata
is metadata
not during
used used
during not
any file
successive reads
file during
reads is
unless any
explicitly default,
included. value
A A
value None,
of included.
None, included.
the None,
default, included.
will default,
not default,
introduct specific
any the
addition and
metadata the
and file
the metadata
file file
specific specific
or specific
default file
metadata file
as used.
specified used.
by configuration
the configuration
metadata metadata
configuration will
file metadata
will used.
be be
used. specified
file_field_names file_field_names
: file_field_names
bool, file_field_names
optional file_field_names
True for
to this
use this
the for
NEXRAD NEXRAD
field NEXRAD
names names
for field
the names
field this
names. NEXRAD
If for
this If
case parameter
the parameter
field_names case
parameter ignored.
is is
ignored. dictionary
The The
field will
dictionary dictionary
will is
likely have
only unless
have fields
a defined
'data' likely
key, key,
unless have
the likely
fields defined
are in
defined the
in 'data'
`additional_metadata`. `additional_metadata`.
exclude_fields list
: optional
list None,
or optional
None, or
optional list
List to
of applied
fields fields
to List
exclude the
from object.
the to
radar radar
object. is
This List
is List
applied applied
after `file_field_names`
the parameters.
`file_field_names` `field_names`
and parameters.
`field_names` `file_field_names`
parameters. after
delay_field_loading optional
: :
bool, :
optional :
True delay
to from
delay file
loading delay
of to
field from
data True
from delay
the the
file the
until until
the file
'data' 'data'
key accessed.
in particular
a field
particular in
field this
dictionary in
is case
accessed. this
In dictionary
this In
case is
the object
field will
attribute object
of the
the field
returned of
Radar Radar
object object
will object
contain Radar
LazyLoadDict dict
objects dict
not objects.
dict dict
objects. objects
station optional
: or
str :
or station
None, station
optional :
Four ICAO
letter of
ICAO of
name station
of used
the to
NEXRAD NEXRAD
station of
used ICAO
to station
determine ICAO
the Four
location the
in parameter
the object.
returned only
radar location
object. radar
This returned
parameter only
is This
only the
used location
when used
the the
location which
is contained
not in
contained the
in file,
the not
file, used
which in
occur is
in message
older message
NEXRAD 1
message files.
1 message
files. message
scans list
: None,
list None,
or scans
None, or
optional scans
Read scans
only scans
specified from
scans the
from specified
the from
file. (the
None from
(the only
default) specified
will scans
read will
scans. all
linear_interp bool,
: linear_interp
bool, :
optional bool,
True linear
(the pairs
default) default)
to default)
perform default)
linear valid
interpolation True
between (the
valid interpolation
pairs to
of in
gates rays
in of
low rays.
resolution of
rays rays
in mixed
files of
mixed mixed
resolution in
rays. mixed
False parameter
will parameter
perform perform
a parameter
nearest nearest
neighbor This
interpolation. a
This neighbor
parameter nearest
is interpolation.
not all
used of
if not
the file
resolution not
of or
all all
rays the
in resolution
the all
file the
or sweeps
requested file
sweeps rays
constant. is
Returns Returns
------- -------
radar Radar
: :
Radar :
Radar Radar
object volume.
containing containing
all containing
moments Radar
and volume.
sweeps/cuts volume.
in containing
the the
volume. all
Gates field
not Gates
collected masked
are in
masked field
in are
the not
field Gates
data. collected
References References
---------- ----------
.. ..
[1] [1]
http://www.ncdc.noaa.gov/ ..
.. ..
[2] [2]
http://thredds.ucar.edu/thredds/catalog.html http://thredds.ucar.edu/thredds/catalog.html
""" """
_test_arguments(kwargs) _test_arguments(kwargs)
filemetadata FileMetadata('nexrad_archive',
= =
FileMetadata('nexrad_archive', =
field_names, field_names,
file_field_names, additional_metadata,
exclude_fields) exclude_fields)
nfile nfile
= =
NEXRADLevel2File(prepare_for_read(filename)) nfile
scan_info nfile.scan_info(scans)
= scan_info
nfile.scan_info(scans) scan_info
time #
time filemetadata('time')
= =
filemetadata('time') filemetadata('time')
time_start, =
_time nfile.get_times(scans)
= _time
nfile.get_times(scans) nfile.get_times(scans)
time['data'] time['data']
= time['data']
_time time['data']
time['units'] make_time_unit_str(time_start)
= =
make_time_unit_str(time_start) =
range #
_range filemetadata('range')
= _range
filemetadata('range') _range
first_gate, first_gate,
gate_spacing, =
last_gate first_gate,
= first_gate,
_find_range_params( last_gate
filemetadata) scan_info,
_range['data'] 'float32')
= last_gate,
np.arange(first_gate, 'float32')
last_gate, last_gate,
gate_spacing, gate_spacing,
'float32') gate_spacing,
_range['meters_to_center_of_first_gate'] float(first_gate)
= _range['meters_to_center_of_first_gate']
float(first_gate) =
_range['meters_between_gates'] float(gate_spacing)
= _range['meters_between_gates']
float(gate_spacing) float(gate_spacing)
metadata #
metadata metadata
= =
filemetadata('metadata') =
metadata['original_container'] 'NEXRAD
= metadata['original_container']
'NEXRAD 'NEXRAD
Level =
II' Level
scan_type #
scan_type 'ppi'
= =
'ppi' 'ppi'
latitude latitude
= =
filemetadata('latitude') =
longitude filemetadata('longitude')
= =
filemetadata('longitude') =
altitude filemetadata('altitude')
= =
filemetadata('altitude') =
if is
nfile._msg_type if
== nfile._msg_type
'1' station
and '1'
station ==
is None:
not nfile._msg_type
None: not
lat, alt
lon, lon,
alt lat,
= alt
get_nexrad_location(station) alt
else: else:
lat, lat,
lon, lon,
alt lat,
= =
nfile.location() =
latitude['data'] np.array([lat],
= dtype='float64')
np.array([lat], =
dtype='float64') latitude['data']
longitude['data'] dtype='float64')
= =
np.array([lon], np.array([lon],
dtype='float64') np.array([lon],
altitude['data'] dtype='float64')
= =
np.array([alt], =
dtype='float64') np.array([alt],
sweep_end_ray_index #
sweep_number sweep_number
= =
filemetadata('sweep_number') =
sweep_mode sweep_mode
= =
filemetadata('sweep_mode') sweep_mode
sweep_start_ray_index filemetadata('sweep_start_ray_index')
= sweep_start_ray_index
filemetadata('sweep_start_ray_index') sweep_start_ray_index
sweep_end_ray_index sweep_end_ray_index
= =
filemetadata('sweep_end_ray_index') filemetadata('sweep_end_ray_index')
if is
scans None:
is scans
None: is
nsweeps int(nfile.nscans)
= =
int(nfile.nscans) =
else: else:
nsweeps len(scans)
= nsweeps
len(scans) len(scans)
sweep_number['data'] np.arange(nsweeps,
= sweep_number['data']
np.arange(nsweeps, np.arange(nsweeps,
dtype='int32') np.arange(nsweeps,
sweep_mode['data'] np.array(
= =
np.array( np.array(
nsweeps ['azimuth_surveillance'],
* *
['azimuth_surveillance'], nsweeps
dtype='S') ['azimuth_surveillance'],
rays_per_scan s
= for
[s['nrays'] in
for scan_info]
s scan_info]
in =
scan_info] rays_per_scan
sweep_end_ray_index['data'] dtype='int32')
= dtype='int32')
np.cumsum(rays_per_scan, -
dtype='int32') 1
- dtype='int32')
1 1
0) rays_per_scan.insert(0,
sweep_start_ray_index['data'] np.cumsum(
= =
np.cumsum( =
dtype='int32') rays_per_scan[:-1],
azimuth azimuth
= =
filemetadata('azimuth') azimuth
elevation filemetadata('elevation')
= =
filemetadata('elevation') elevation
fixed_angle fixed_angle
= fixed_angle
filemetadata('fixed_angle') fixed_angle
azimuth['data'] nfile.get_azimuth_angles(scans)
= =
nfile.get_azimuth_angles(scans) nfile.get_azimuth_angles(scans)
elevation['data'] nfile.get_elevation_angles(scans).astype('float32')
= =
nfile.get_elevation_angles(scans).astype('float32') nfile.get_elevation_angles(scans).astype('float32')
fixed_angle['data'] nfile.get_target_angles(scans)
= =
nfile.get_target_angles(scans) nfile.get_target_angles(scans)
fields #
max_ngates len(_range['data'])
= max_ngates
len(_range['data']) =
available_moments scan
= for
set([m =
for =
scan =
in scan
scan_info =
for =
m scan
in =
scan['moments']]) available_moments
interpolate interpolate
= =
_find_scans_to_interp( interpolate
scan_info, filemetadata)
first_gate, filemetadata)
gate_spacing, gate_spacing,
filemetadata) gate_spacing,
fields fields
= =
{} =
for for
moment available_moments:
in moment
available_moments: for
field_name field_name
= field_name
filemetadata.get_field_name(moment) field_name
if is
field_name if
is if
None: field_name
continue continue
dic filemetadata(field_name)
= dic
filemetadata(field_name) dic
dic['_FillValue'] dic['_FillValue']
= =
get_fillvalue() =
if and
delay_field_loading moment
and delay_field_loading
moment if
not not
in delay_field_loading
interpolate: if
dic LazyLoadDict(dic)
= =
LazyLoadDict(dic) =
data_call _NEXRADLevel2StagedField(
= data_call
_NEXRADLevel2StagedField( data_call
nfile, nfile,
moment, scans)
max_ngates, nfile,
scans) scans)
data_call) dic.set_lazy('data',
else: else:
mdata max_ngates,
= mdata
nfile.get_data(moment, scans=scans)
max_ngates, max_ngates,
scans=scans) scans=scans)
if interpolate:
moment if
in if
interpolate: moment
interp_scans interpolate[moment]
= =
interpolate[moment] interp_scans
warnings.warn( warnings.warn(
"Gate in
spacing "Gate
is interpolating
not in
constant, data
interpolating interpolating
data constant,
in not
" interpolating
+ interpolating
"scans %
%s moment
for (interp_scans,
moment moment
%s." %s."
% %s."
(interp_scans, moment
moment), %
UserWarning) UserWarning)
for for
scan interp_scans:
in scan
interp_scans: scan
idx scan_info[scan]['moments'].index(moment)
= =
scan_info[scan]['moments'].index(moment) idx
moment_ngates moment_ngates
= =
scan_info[scan]['ngates'][idx] moment_ngates
start sweep_start_ray_index['data'][scan]
= =
sweep_start_ray_index['data'][scan] sweep_start_ray_index['data'][scan]
end sweep_end_ray_index['data'][scan]
= =
sweep_end_ray_index['data'][scan] sweep_end_ray_index['data'][scan]
_interpolate_scan(mdata, end,
start, moment_ngates,
end, _interpolate_scan(mdata,
moment_ngates, end,
linear_interp) linear_interp)
dic['data'] mdata
= =
mdata =
fields[field_name] fields[field_name]
= fields[field_name]
dic dic
instrument_parameters #
nyquist_velocity nyquist_velocity
= nyquist_velocity
filemetadata('nyquist_velocity') nyquist_velocity
unambiguous_range filemetadata('unambiguous_range')
= unambiguous_range
filemetadata('unambiguous_range') =
nyquist_velocity['data'] nfile.get_nyquist_vel(scans).astype('float32')
= =
nfile.get_nyquist_vel(scans).astype('float32') =
unambiguous_range['data'] (
= unambiguous_range['data']
( =
nfile.get_unambigous_range(scans).astype('float32')) nfile.get_unambigous_range(scans).astype('float32'))
instrument_parameters {'unambiguous_range':
= unambiguous_range,
{'unambiguous_range': instrument_parameters
unambiguous_range, instrument_parameters
'nyquist_velocity': }
nyquist_velocity, nyquist_velocity,
} 'nyquist_velocity':
nfile.close() nfile.close()
Radar( return
time, fields,
_range, metadata,
fields, fields,
metadata, metadata,
scan_type, metadata,
latitude, altitude,
longitude, latitude,
altitude, latitude,
sweep_number, sweep_start_ray_index,
sweep_mode, sweep_start_ray_index,
fixed_angle, sweep_mode,
sweep_start_ray_index, sweep_mode,
sweep_end_ray_index, sweep_end_ray_index,
elevation, azimuth,
instrument_parameters=instrument_parameters) instrument_parameters=instrument_parameters)
def filemetadata):
_find_range_params(scan_info, _find_range_params(scan_info,
filemetadata): def
""" last_gate.
Return parameters,
range """
parameters, gate_spacing,
first_gate, last_gate.
gate_spacing, gate_spacing,
last_gate. Return
""" first_gate,
min_first_gate min_first_gate
= =
999999 =
min_gate_spacing 999999
= =
999999 999999
max_last_gate 0
= =
0 max_last_gate
for in
scan_params scan_info:
in in
scan_info: for
ngates ngates
= =
scan_params['ngates'][0] =
for for
i, in
moment moment
in for
enumerate(scan_params['moments']): enumerate(scan_params['moments']):
if if
filemetadata.get_field_name(moment) filemetadata.get_field_name(moment)
is if
None: filemetadata.get_field_name(moment)
continue continue
first_gate scan_params['first_gate'][i]
= =
scan_params['first_gate'][i] scan_params['first_gate'][i]
gate_spacing scan_params['gate_spacing'][i]
= =
scan_params['gate_spacing'][i] gate_spacing
last_gate 0.5)
= +
first_gate first_gate
+ =
gate_spacing gate_spacing
* 0.5)
(ngates 0.5)
- -
0.5) 0.5)
min_first_gate min(min_first_gate,
= first_gate)
min(min_first_gate, =
first_gate) =
min_gate_spacing min(min_gate_spacing,
= gate_spacing)
min(min_gate_spacing, min_gate_spacing
gate_spacing) gate_spacing)
max_last_gate max_last_gate
= =
max(max_last_gate, max(max_last_gate,
last_gate) max(max_last_gate,
return return
min_first_gate, max_last_gate
min_gate_spacing, min_gate_spacing,
max_last_gate min_first_gate,
def def
_find_scans_to_interp(scan_info, _find_scans_to_interp(scan_info,
first_gate, def
gate_spacing, first_gate,
filemetadata): def
""" """
Return dict
a Return
dict """
indicating dict
what need
moments/scans a
need """
interpolation. indicating
""" what
moments in
= in
set([m in
for in
scan for
in scan['moments']])
scan_info scan['moments']])
for for
m moments
in scan
scan['moments']]) set([m
interpolate moment
= moments])
dict([(moment, interpolate
[]) moment
for interpolate
moment moments])
in moment
moments]) moment
for scan
scan_num, scan_num,
scan for
in in
enumerate(scan_info): scan_num,
for for
moment moments:
in moment
moments: in
if not
moment in
not scan['moments']:
in not
scan['moments']: moment
continue continue
if None:
filemetadata.get_field_name(moment) None:
is if
None: is
continue continue
index scan['moments'].index(moment)
= =
scan['moments'].index(moment) =
first scan['first_gate'][index]
= =
scan['first_gate'][index] scan['first_gate'][index]
spacing scan['gate_spacing'][index]
= spacing
scan['gate_spacing'][index] =
if if
first spacing
!= or
first_gate first_gate
or or
spacing or
!= spacing
gate_spacing: if
interpolate[moment].append(scan_num) interpolate[moment].append(scan_num)
assert *
spacing assert
== 4
gate_spacing assert
* ==
4 gate_spacing
assert ==
first_gate first_gate
+ +
1.5 gate_spacing
* ==
gate_spacing first_gate
== +
first gate_spacing
interpolate in
= =
dict([(k, interpolate.items()
v) v)
for 0])
k, in
v interpolate.items()
in if
interpolate.items() v
if k,
len(v) len(v)
!= !=
0]) dict([(k,
interpolate return
def end,
_interpolate_scan(mdata, _interpolate_scan(mdata,
start, moment_ngates,
end, def
moment_ngates, end,
linear_interp=True): start,
""" from
Interpolate m
a """
single a
NEXRAD a
moment m.
scan 1000
from """
1000 to
m scan
to m
250 to
m. moment
""" """
for in
ray_num end+1):
in ray_num
range(start, for
end+1): ray_num
ray mdata[ray_num].copy()
= =
mdata[ray_num].copy() ray
interp_ngates interp_ngates
= *
4 =
* =
moment_ngates moment_ngates
ray[:interp_ngates] np.repeat(ray[:moment_ngates],
= =
np.repeat(ray[:moment_ngates], =
4) np.repeat(ray[:moment_ngates],
linear_interp: if
for range(2,
i range(2,
in -
range(2, range(2,
interp_ngates in
- interp_ngates
4, interp_ngates
4): for
gate_val gate_val
= =
ray[i] ray[i]
next_val next_val
= =
ray[i+4] next_val
if or
np.ma.is_masked(gate_val) if
or np.ma.is_masked(gate_val)
np.ma.is_masked(next_val): np.ma.is_masked(gate_val)
continue continue
delta 4.
= -
(next_val (next_val
- -
gate_val) delta
/ -
4. 4.
ray[i+0] delta
= +
gate_val delta
+ 0.5
delta 0.5
* =
0.5 delta
ray[i+1] ray[i+1]
= ray[i+1]
gate_val =
+ ray[i+1]
delta 1.5
* *
1.5 1.5
ray[i+2] +
= +
gate_val 2.5
+ ray[i+2]
delta +
* *
2.5 *
ray[i+3] +
= +
gate_val 3.5
+ 3.5
delta 3.5
* =
3.5 +
mdata[ray_num] mdata[ray_num]
= mdata[ray_num]
ray[:] ray[:]
_NEXRADLevel2StagedField(object): class
""" """
A A
class 2
to A
facilitate demand
on loading
demand of
loading on
of on
field A
data loading
from facilitate
a A
Level class
2 A
file. Level
""" """
def nfile,
__init__(self, moment,
nfile, max_ngates,
moment, scans):
max_ngates, max_ngates,
scans): max_ngates,
""" """
initialize. initialize.
""" """
self.nfile self.nfile
= self.nfile
nfile self.nfile
self.moment self.moment
= =
moment self.moment
self.max_ngates max_ngates
= =
max_ngates =
self.scans self.scans
= =
scans scans
__call__(self): def
""" the
Return array
the containing
array data.
containing field
the data.
field Return
data. array
""" data.
self.nfile.get_data( return
self.moment, self.moment,
self.max_ngates, self.max_ngates,
scans=self.scans) self.moment,
""" """
pyart.io.uf pyart.io.uf
=========== ===========
Reading files
of format
Universal Universal
format format
(UF) (UF)
files format
autosummary:: ..
generated/ :toctree:
read_uf read_uf
_get_instrument_parameters _get_instrument_parameters
""" """
warnings import
import as
numpy np
as as
np as
from from
netCDF4 netCDF4
import import
date2num date2num
from FileMetadata,
..config get_fillvalue
import get_fillvalue
FileMetadata, import
get_fillvalue FileMetadata,
from import
..core.radar from
import from
Radar from
from _test_arguments,
.common from
import prepare_for_read
make_time_unit_str, make_time_unit_str,
_test_arguments, .common
prepare_for_read _test_arguments,
from from
.uffile .uffile
import import
UFFile import
_LIGHT_SPEED meters
= speed
2.99792458e8 =
# of
speed meters
of speed
light light
in of
meters #
per 2.99792458e8
second =
_UF_SWEEP_MODES {
= =
{ =
'calibration', 0:
'ppi', 1:
'coplane', 2:
'rhi', 3:
'vpt', 4:
'target', 5:
'manual', 6:
'idle', 7:
} }
_SWEEP_MODE_STR _SWEEP_MODE_STR
= =
{ {
'calibration', 'calibration':
'azimuth_surveillance', 'ppi':
'coplane', 'coplane':
'rhi', 'rhi':
'vertical_pointing', 'vpt':
'pointing', 'target':
'manual', 'manual':
'idle', 'idle':
} }
def additional_metadata=None,
read_uf(filename, additional_metadata=None,
field_names=None, read_uf(filename,
additional_metadata=None, read_uf(filename,
exclude_fields=None, file_field_names=False,
**kwargs): delay_field_loading=False,
""" """
Read UF
a a
UF UF
File. a
Parameters Parameters
---------- ----------
filename file-like
: :
str file-like
or or
file-like str
Name from.
of format
Universal of
format read
file format
to of
read read
data Name
from. read
field_names field_names
: optional
dict, dict,
optional field_names
Dictionary field
mapping to
UF names
data If
type names.
names field
to Dictionary
radar names
field mapping
names. mapping
If names.
a mapping
data not
type or
found appear
in data
the does
file the
does in
not the
appear does
in does
this does
dictionary not
or does
has data
a will
value will
of the
None in
it a
will it
not in
be value
placed placed
in placed
the value
radar.fields of
dictionary. dictionary.
A None,
value the
of in
None, use
the A
default, None,
will the
use will
the the
mapping of
defined the
in A
the value
Py-ART file.
configuration Py-ART
file. configuration
additional_metadata dict
: of
dict :
of of
dicts, dicts,
optional dicts,
Dictionary to
of metadata
dictionaries of
to Dictionary
retrieve from
metadata to
from metadata
during dictionaries
this during
read. read.
This unless
metadata This
is This
not during
used any
during is
any reads
successive This
file unless
reads successive
unless unless
explicitly the
included. the
A of
value None,
of not
None, included.
the value
default, not
will None,
not of
introduce metadata
any default
addition file
metadata introduce
and or
the the
file or
specific default
or or
default or
metadata file
as Py-ART
specified Py-ART
by file
the used.
Py-ART will
configuration will
file used.
will specified
be configuration
used. the
file_field_names bool,
: optional
bool, bool,
optional :
True from
to the
force the
the to
use from
of force
the to
field which
names the
from force
the True
file file
in use
which file
case parameter
the case
`field_names` case
parameter the
is case
ignored. `field_names`
False False
will ignored.
use will
to parameter
`field_names` `field_names`
parameter rename
to parameter
rename `field_names`
fields. rename
exclude_fields exclude_fields
: exclude_fields
list None,
or or
None, None,
optional None,
List the
of is
fields the
to List
exclude of
from from
the fields
radar the
object. List
This fields
is is
applied to
after parameters.
the and
`file_field_names` the
and parameters.
`field_names` after
parameters. the
delay_field_loading delay_field_loading
: :
bool :
This implemented
option not
is for
not function
implemented option
in in
the option
function is
but for
included not
for the
compatibility. compatibility.
Returns Returns
------- -------
radar radar
: :
Radar Radar
object. Radar
""" """
_test_arguments(kwargs) _test_arguments(kwargs)
filemetadata FileMetadata('uf',
= additional_metadata,
FileMetadata('uf', additional_metadata,
field_names, field_names,
additional_metadata, filemetadata
exclude_fields) file_field_names,
ufile UFFile(prepare_for_read(filename))
= =
UFFile(prepare_for_read(filename)) ufile
first_ray first_ray
= =
ufile.rays[0] =
time #
dts ufile.get_datetimes()
= =
ufile.get_datetimes() =
units units
= units
make_time_unit_str(min(dts)) =
time filemetadata('time')
= =
filemetadata('time') filemetadata('time')
time['units'] time['units']
= =
units time['units']
time['data'] date2num(dts,
= units).astype('float32')
date2num(dts, date2num(dts,
units).astype('float32') time['data']
range #
_range filemetadata('range')
= =
filemetadata('range') filemetadata('range')
field_header first_ray.field_headers[0]
= field_header
first_ray.field_headers[0] =
ngates ngates
= ngates
field_header['nbins'] =
step step
= step
field_header['range_spacing_m'] field_header['range_spacing_m']
start 1000.
= =
(field_header['range_start_km'] (field_header['range_start_km']
* start
1000. *
+ =
field_header['range_start_m'] 2.)
+ +
step 2.)
/ +
2.) field_header['range_start_m']
_range['data'] _range['data']
= +
np.arange(ngates, *
dtype='float32') step
* +
step step
+ =
start dtype='float32')
_range['meters_to_center_of_first_gate'] start
= _range['meters_to_center_of_first_gate']
start start
_range['meters_between_gates'] step
= =
step =
latitude filemetadata('latitude')
= =
filemetadata('latitude') latitude
longitude filemetadata('longitude')
= longitude
filemetadata('longitude') longitude
altitude filemetadata('altitude')
= =
filemetadata('altitude') =
lat, lat,
lon, =
height lat,
= lat,
first_ray.get_location() =
latitude['data'] np.array([lat],
= =
np.array([lat], np.array([lat],
dtype='float64') latitude['data']
longitude['data'] np.array([lon],
= =
np.array([lon], np.array([lon],
dtype='float64') np.array([lon],
altitude['data'] np.array([height],
= dtype='float64')
np.array([height], np.array([height],
dtype='float64') =
metadata #
metadata metadata
= =
filemetadata('metadata') filemetadata('metadata')
metadata['original_container'] metadata['original_container']
= =
'UF' =
metadata['site_name'] first_ray.mandatory_header['site_name']
= metadata['site_name']
first_ray.mandatory_header['site_name'] =
metadata['radar_name'] metadata['radar_name']
= =
first_ray.mandatory_header['radar_name'] metadata['radar_name']
sweep_start_ray_index sweep_start_ray_index
= =
filemetadata('sweep_start_ray_index') sweep_start_ray_index
sweep_end_ray_index sweep_end_ray_index
= =
filemetadata('sweep_end_ray_index') filemetadata('sweep_end_ray_index')
sweep_start_ray_index['data'] ufile.first_ray_in_sweep
= =
ufile.first_ray_in_sweep sweep_start_ray_index['data']
sweep_end_ray_index['data'] ufile.last_ray_in_sweep
= =
ufile.last_ray_in_sweep =
sweep_number filemetadata('sweep_number')
= =
filemetadata('sweep_number') =
sweep_number['data'] np.arange(ufile.nsweeps,
= =
np.arange(ufile.nsweeps, np.arange(ufile.nsweeps,
dtype='int32') np.arange(ufile.nsweeps,
sweep_type #
scan_type _UF_SWEEP_MODES[first_ray.mandatory_header['sweep_mode']]
= =
_UF_SWEEP_MODES[first_ray.mandatory_header['sweep_mode']] _UF_SWEEP_MODES[first_ray.mandatory_header['sweep_mode']]
sweep_mode #
sweep_mode filemetadata('sweep_mode')
= =
filemetadata('sweep_mode') sweep_mode
sweep_mode['data'] np.array(
= =
np.array( =
ufile.nsweeps ufile.nsweeps
* ufile.nsweeps
[_SWEEP_MODE_STR[scan_type]], ufile.nsweeps
dtype='S') [_SWEEP_MODE_STR[scan_type]],
elevation #
elevation elevation
= =
filemetadata('elevation') filemetadata('elevation')
elevation['data'] elevation['data']
= elevation['data']
ufile.get_elevations() ufile.get_elevations()
azimuth #
azimuth filemetadata('azimuth')
= =
filemetadata('azimuth') azimuth
azimuth['data'] azimuth['data']
= =
ufile.get_azimuths() azimuth['data']
fixed_angle #
fixed_angle fixed_angle
= fixed_angle
filemetadata('fixed_angle') filemetadata('fixed_angle')
fixed_angle['data'] ufile.get_sweep_fixed_angles()
= =
ufile.get_sweep_fixed_angles() ufile.get_sweep_fixed_angles()
fields #
fields {}
= =
{} {}
for uf_field_dic
uf_field_number, in
uf_field_dic uf_field_dic
in uf_field_dic
enumerate(first_ray.field_positions): uf_field_number,
uf_field_name uf_field_dic['data_type'].decode('ascii')
= uf_field_name
uf_field_dic['data_type'].decode('ascii') uf_field_name
field_name filemetadata.get_field_name(uf_field_name)
= =
filemetadata.get_field_name(uf_field_name) =
if if
field_name if
is field_name
None: None:
continue continue
field_dic field_dic
= =
filemetadata(field_name) field_dic
field_dic['data'] field_dic['data']
= =
ufile.get_field_data(uf_field_number) ufile.get_field_data(uf_field_number)
field_dic['_FillValue'] get_fillvalue()
= field_dic['_FillValue']
get_fillvalue() field_dic['_FillValue']
fields[field_name] fields[field_name]
= fields[field_name]
field_dic =
instrument_parameters #
instrument_parameters instrument_parameters
= filemetadata)
_get_instrument_parameters(ufile, _get_instrument_parameters(ufile,
filemetadata) _get_instrument_parameters(ufile,
scan_rate filemetadata('scan_rate')
= =
filemetadata('scan_rate') =
scan_rate['data'] scan_rate['data']
= =
ufile.get_sweep_rates() scan_rate['data']
ufile.close() ufile.close()
Radar( return
time, fields,
_range, scan_type,
fields, scan_type,
metadata, time,
scan_type, fields,
latitude, latitude,
longitude, latitude,
altitude, altitude,
sweep_number, sweep_number,
sweep_mode, sweep_mode,
fixed_angle, fixed_angle,
sweep_start_ray_index, fixed_angle,
sweep_end_ray_index, sweep_end_ray_index,
elevation, azimuth,
scan_rate=scan_rate, scan_rate=scan_rate,
instrument_parameters=instrument_parameters) instrument_parameters=instrument_parameters)
def filemetadata):
_get_instrument_parameters(ufile, _get_instrument_parameters(ufile,
filemetadata): def
""" """
Return instrument
a """
dictionary """
containing Return
instrument Return
parameters. parameters.
""" instrument
pulse_width filemetadata('pulse_width')
= pulse_width
filemetadata('pulse_width') filemetadata('pulse_width')
pulse_width['data'] /
= _LIGHT_SPEED
ufile.get_pulse_widths() pulse_width['data']
/ #
_LIGHT_SPEED pulse_width['data']
# #
m->sec #
first_ray first_ray
= first_ray
ufile.rays[0] =
field_header field_header
= =
first_ray.field_headers[0] =
beam_width_h field_header['beam_width_h']
= =
field_header['beam_width_h'] =
/ beam_width_h
64. field_header['beam_width_h']
beam_width_v field_header['beam_width_v']
= =
field_header['beam_width_v'] field_header['beam_width_v']
/ /
64. beam_width_v
bandwidth 16.
= =
field_header['bandwidth'] field_header['bandwidth']
/ field_header['bandwidth']
16. /
* field_header['bandwidth']
1.e6 field_header['bandwidth']
wavelength_cm 64.
= /
field_header['wavelength_cm'] 64.
/ =
64. wavelength_cm
if ==
wavelength_cm wavelength_cm
== wavelength_cm
0: 0:
warnings.warn('Invalid to
wavelength, set
frequency value.')
set default
to set
default wavelength,
value.') default
wavelength_hz 9999.0
= wavelength_hz
9999.0 =
else: else:
wavelength_hz (wavelength_cm
= 100.)
_LIGHT_SPEED 100.)
/ 100.)
(wavelength_cm _LIGHT_SPEED
/ /
100.) /
radar_beam_width_h #
radar_beam_width_h filemetadata('radar_beam_width_h')
= =
filemetadata('radar_beam_width_h') =
radar_beam_width_h['data'] dtype='float32')
= dtype='float32')
np.array([beam_width_h], np.array([beam_width_h],
dtype='float32') np.array([beam_width_h],
radar_beam_width_v #
radar_beam_width_v radar_beam_width_v
= =
filemetadata('radar_beam_width_w') radar_beam_width_v
radar_beam_width_v['data'] np.array([beam_width_v],
= =
np.array([beam_width_v], radar_beam_width_v['data']
dtype='float32') dtype='float32')
radar_receiver_bandwidth #
radar_receiver_bandwidth radar_receiver_bandwidth
= radar_receiver_bandwidth
filemetadata('radar_receiver_bandwidth') =
radar_receiver_bandwidth['data'] radar_receiver_bandwidth['data']
= dtype='float32')
np.array([bandwidth], =
dtype='float32') np.array([bandwidth],
polarization_mode #
polarization_mode filemetadata('polarization_mode')
= =
filemetadata('polarization_mode') =
polarization_mode['data'] polarization_mode['data']
= =
ufile.get_sweep_polarizations() ufile.get_sweep_polarizations()
frequency #
frequency filemetadata('frequency')
= =
filemetadata('frequency') filemetadata('frequency')
frequency['data'] frequency['data']
= dtype='float32')
np.array([wavelength_hz], np.array([wavelength_hz],
dtype='float32') np.array([wavelength_hz],
prt #
prt filemetadata('prt')
= =
filemetadata('prt') prt
prt['data'] 1e6
= 1e6
ufile.get_prts() ufile.get_prts()
/ us->sec
1e6 prt['data']
# /
us->sec #
instrument_parameters {
= =
{ {
pulse_width, 'pulse_width':
radar_beam_width_h, 'radar_beam_width_h':
radar_beam_width_v, 'radar_beam_width_v':
radar_receiver_bandwidth, 'radar_receiver_bandwidth':
polarization_mode, 'polarization_mode':
frequency, 'frequency':
prt, 'prt':
} }
nyquist_velocity nyquist_velocity
= nyquist_velocity
filemetadata('nyquist_velocity') nyquist_velocity
nyquist_velocity['data'] ufile.get_nyquists()
= =
ufile.get_nyquists() =
if None:
nyquist_velocity['data'] None:
is None:
not not
None: None:
instrument_parameters['nyquist_velocity'] nyquist_velocity
= instrument_parameters['nyquist_velocity']
nyquist_velocity nyquist_velocity
instrument_parameters return
