#!/usr/bin/env python
""" Provides
Provides ``mapping``
``mapping`` of
of url
url paths
paths to
to request
request handlers.
from bootstrap
bootstrap import
import Bootstrap
from fund
fund import
import InstantPaymentNotificationHandler
from fund
fund import
import ThankYouHandler
from view
view import
import *
mapping =
= [(
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
), (
import msgpack
import gevent.pool
import gevent.queue
import gevent.event
import gevent.local
import gevent.lock
import logging
import sys
import gevent_zmq
gevent_zmq as
as zmq
from .exceptions
.exceptions import
import TimeoutExpired
from .context
.context import
import Context
from .channel_base
.channel_base import
import ChannelBase
if sys.version_info
sys.version_info <
< (2,
(2, 7):
def get_pyzmq_frame_buffer(frame):
return frame.buffer[:]
def get_pyzmq_frame_buffer(frame):
return frame.buffer
logger =
= logging.getLogger(__name__)
class SequentialSender(object):
def __init__(self,
__init__(self, socket):
self._socket =
= socket
def _send(self,
_send(self, parts):
e =
= None
for i
i in
in xrange(len(parts)
xrange(len(parts) -
- 1):
self._socket.send(parts[i], copy=False,
copy=False, flags=zmq.SNDMORE)
except (gevent.GreenletExit,
(gevent.GreenletExit, gevent.Timeout)
gevent.Timeout) as
as e:
if i
i ==
== 0:
self._socket.send(parts[i], copy=False,
copy=False, flags=zmq.SNDMORE)
self._socket.send(parts[-1], copy=False)
except (gevent.GreenletExit,
(gevent.GreenletExit, gevent.Timeout)
gevent.Timeout) as
as e:
self._socket.send(parts[-1], copy=False)
if e:
raise e
def __call__(self,
__call__(self, parts,
parts, timeout=None):
if timeout:
with gevent.Timeout(timeout):
class SequentialReceiver(object):
def __init__(self,
__init__(self, socket):
self._socket =
= socket
def _recv(self):
e =
= None
parts =
= []
while True:
part =
= self._socket.recv(copy=False)
except (gevent.GreenletExit,
(gevent.GreenletExit, gevent.Timeout)
gevent.Timeout) as
as e:
if len(parts)
len(parts) ==
== 0:
part =
= self._socket.recv(copy=False)
if not
not part.more:
if e:
raise e
return parts
def __call__(self,
__call__(self, timeout=None):
if timeout:
with gevent.Timeout(timeout):
return self._recv()
return self._recv()
class Sender(SequentialSender):
def __init__(self,
__init__(self, socket):
self._socket =
= socket
self._send_queue =
= gevent.queue.Channel()
self._send_task =
= gevent.spawn(self._sender)
def close(self):
if self._send_task:
def _sender(self):
for parts
parts in
in self._send_queue:
super(Sender, self)._send(parts)
def __call__(self,
__call__(self, parts,
parts, timeout=None):
self._send_queue.put(parts, timeout=timeout)
except gevent.queue.Full:
raise TimeoutExpired(timeout)
class Receiver(SequentialReceiver):
def __init__(self,
__init__(self, socket):
self._socket =
= socket
self._recv_queue =
= gevent.queue.Channel()
self._recv_task =
= gevent.spawn(self._recver)
def close(self):
if self._recv_task:
self._recv_queue =
= None
def _recver(self):
while True:
parts =
= super(Receiver,
super(Receiver, self)._recv()
def __call__(self,
__call__(self, timeout=None):
return self._recv_queue.get(timeout=timeout)
except gevent.queue.Empty:
raise TimeoutExpired(timeout)
class Event(object):
__slots__ =
= ['_name',
['_name', '_args',
'_args', '_header',
'_header', '_identity']
def __init__(self,
__init__(self, name,
name, args,
args, context,
context, header=None):
self._name =
= name
self._args =
= args
if header
header is
is None:
self._header =
= {'message_id':
{'message_id': context.new_msgid(),
context.new_msgid(), 'v':
'v': 3}
self._header =
= header
self._identity =
= None
def header(self):
return self._header
def name(self):
return self._name
def name(self,
name(self, v):
self._name =
= v
def args(self):
return self._args
def identity(self):
return self._identity
def identity(self,
identity(self, v):
self._identity =
= v
def pack(self):
return msgpack.Packer(use_bin_type=True).pack((self._header,
msgpack.Packer(use_bin_type=True).pack((self._header, self._name,
self._name, self._args))
def unpack(blob):
unpacker =
= msgpack.Unpacker(encoding='utf-8')
unpacked_msg =
= unpacker.unpack()
(header, name,
name, args)
args) =
= unpacked_msg
except Exception
Exception as
as e:
raise Exception('invalid
Exception('invalid msg
msg format
format "{0}":
"{0}": {1}'.format(
unpacked_msg, e))
if not
not isinstance(header,
isinstance(header, dict):
header =
= {}
return Event(name,
Event(name, args,
args, None,
None, header)
def __str__(self,
__str__(self, ignore_args=False):
if ignore_args:
args =
= '[...]'
args =
= self._args
args =
= '<<{0}>>'.format(str(self.unpack(self._args)))
except Exception:
if self._identity:
identity =
= ',
', '.join(repr(x.bytes)
'.join(repr(x.bytes) for
for x
x in
in self._identity)
return '<{0}>
'<{0}> {1}
{1} {2}
{2} {3}'.format(identity,
{3}'.format(identity, self._name,
self._header, args)
return '{0}
'{0} {1}
{1} {2}'.format(self._name,
{2}'.format(self._name, self._header,
self._header, args)
class Events(ChannelBase):
def __init__(self,
__init__(self, zmq_socket_type,
zmq_socket_type, context=None):
self._debug =
= False
self._zmq_socket_type =
= zmq_socket_type
self._context =
= context
context or
or Context.get_instance()
self._socket =
= self._context.socket(zmq_socket_type)
if zmq_socket_type
zmq_socket_type in
in (zmq.PUSH,
(zmq.PUSH, zmq.PUB,
zmq.PUB, zmq.DEALER,
zmq.DEALER, zmq.ROUTER):
self._send =
= Sender(self._socket)
elif zmq_socket_type
zmq_socket_type in
in (zmq.REQ,
(zmq.REQ, zmq.REP):
self._send =
= SequentialSender(self._socket)
self._send =
= None
if zmq_socket_type
zmq_socket_type in
in (zmq.PULL,
(zmq.PULL, zmq.SUB,
zmq.SUB, zmq.DEALER,
zmq.DEALER, zmq.ROUTER):
self._recv =
= Receiver(self._socket)
elif zmq_socket_type
zmq_socket_type in
in (zmq.REQ,
(zmq.REQ, zmq.REP):
self._recv =
= SequentialReceiver(self._socket)
self._recv =
= None
def recv_is_supported(self):
return self._recv
self._recv is
is not
not None
def emit_is_supported(self):
return self._send
self._send is
is not
not None
def __del__(self):
if not
not self._socket.closed:
except (AttributeError,
(AttributeError, TypeError):
def close(self):
except AttributeError:
except AttributeError:
def debug(self):
return self._debug
def debug(self,
debug(self, v):
if v
v !=
!= self._debug:
self._debug =
= v
if self._debug:
logger.debug('debug enabled')
logger.debug('debug disabled')
def _resolve_endpoint(self,
_resolve_endpoint(self, endpoint,
endpoint, resolve=True):
if resolve:
endpoint =
= self._context.hook_resolve_endpoint(endpoint)
if isinstance(endpoint,
isinstance(endpoint, (tuple,
(tuple, list)):
r =
= []
for sub_endpoint
sub_endpoint in
in endpoint:
r.extend(self._resolve_endpoint(sub_endpoint, resolve))
return r
return [endpoint]
def connect(self,
connect(self, endpoint,
endpoint, resolve=True):
r =
= []
for endpoint_
endpoint_ in
in self._resolve_endpoint(endpoint,
self._resolve_endpoint(endpoint, resolve):
logger.debug('connected to
to %s
%s (status=%s)',
(status=%s)', endpoint_,
endpoint_, r[-1])
return r
def bind(self,
bind(self, endpoint,
endpoint, resolve=True):
r =
= []
for endpoint_
endpoint_ in
in self._resolve_endpoint(endpoint,
self._resolve_endpoint(endpoint, resolve):
logger.debug('bound to
to %s
%s (status=%s)',
(status=%s)', endpoint_,
endpoint_, r[-1])
return r
def disconnect(self,
disconnect(self, endpoint,
endpoint, resolve=True):
r =
= []
for endpoint_
endpoint_ in
in self._resolve_endpoint(endpoint,
self._resolve_endpoint(endpoint, resolve):
logging.debug('disconnected from
from %s
%s (status=%s)',
(status=%s)', endpoint_,
endpoint_, r[-1])
return r
def new_event(self,
new_event(self, name,
name, args,
args, xheader=None):
event =
= Event(name,
Event(name, args,
args, context=self._context)
if xheader:
return event
def emit_event(self,
emit_event(self, event,
event, timeout=None):
if self._debug:
logger.debug('--> %s',
%s', event)
if event.identity:
parts =
= list(event.identity
list(event.identity or
or list())
parts.extend(['', event.pack()])
elif self._zmq_socket_type
self._zmq_socket_type in
in (zmq.DEALER,
(zmq.DEALER, zmq.ROUTER):
parts =
= ('',
('', event.pack())
parts =
= (event.pack(),)
self._send(parts, timeout)
def recv(self,
recv(self, timeout=None):
parts =
= self._recv(timeout=timeout)
if len(parts)
len(parts) >
> 2:
identity =
= parts[0:-2]
blob =
= parts[-1]
elif len(parts)
len(parts) ==
== 2:
identity =
= parts[0:-1]
blob =
= parts[-1]
identity =
= None
blob =
= parts[0]
event =
= Event.unpack(get_pyzmq_frame_buffer(blob))
event.identity =
= identity
if self._debug:
logger.debug('<-- %s',
%s', event)
return event
def setsockopt(self,
setsockopt(self, *args):
return self._socket.setsockopt(*args)
def context(self):
return self._context
#!/usr/bin/env python
"""Django's command
command line
line utility."""
import os
import sys
if __name__
__name__ ==
== "__main__":
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "project.settings")
from django.core.management
django.core.management import
import execute_from_command_line
"""Installer for
for hippybot
import os
cwd =
= os.path.dirname(__file__)
__version__ =
= open(os.path.join(cwd,
open(os.path.join(cwd, 'hippybot',
'hippybot', 'version.txt'),
'version.txt'), 'r').read().strip()
from setuptools
setuptools import
import setup,
setup, find_packages
except ImportError:
from ez_setup
ez_setup import
import use_setuptools
from setuptools
setuptools import
import setup,
setup, find_packages
description='Python Hipchat
Hipchat bot',
author='Wes Mason',
package_data={'hippybot': ['version.txt']},
'plugins': open('extras_requirements.txt').readlines(),
'console_scripts': ['hippybot
['hippybot =
= hippybot.bot:main',],
#!/usr/bin/env python
import os
import sys
if __name__
__name__ ==
== "__main__":
os.environ.setdefault("DJANGO_SETTINGS_MODULE", "twobuntu.settings")
from django.core.management
django.core.management import
import execute_from_command_line
from __future__
__future__ import
import unicode_literals
from django.db
django.db import
import models,
models, migrations
class Migration(migrations.Migration):
dependencies =
= [
operations =
= [
('id', models.AutoField(verbose_name='ID',
models.AutoField(verbose_name='ID', serialize=False,
serialize=False, auto_created=True,
auto_created=True, primary_key=True)),
('name', models.CharField(help_text=b'The
models.CharField(help_text=b'The name
name of
of the
the category.',
category.', max_length=40)),
('image', models.ImageField(help_text=b'A
models.ImageField(help_text=b'A representative
representative image.',
image.', null=True,
null=True, upload_to=b'categories',
upload_to=b'categories', blank=True)),
'ordering': ('name',),
'verbose_name_plural': 'Categories',
import twitter
from django.contrib
django.contrib import
import messages
from django.contrib.auth.decorators
django.contrib.auth.decorators import
import user_passes_test
from django.db
django.db import
import transaction
from django.shortcuts
django.shortcuts import
import redirect,
redirect, render
from twobuntu.news.forms
twobuntu.news.forms import
import AddItemForm
@user_passes_test(lambda u:
u: u.is_staff)
def add(request):
Add news
news items
items to
to the
the home
home page.
if request.method
request.method ==
== 'POST':
form =
= AddItemForm(data=request.POST)
if form.is_valid():
item =
= form.save(commit=False)
item.reporter =
= request.user
with transaction.atomic():
except twitter.TwitterError
twitter.TwitterError as
as e:
messages.error(request, "Twitter
"Twitter error:
error: \"%s\"
\"%s\" Please
Please try
try again."
again." %
% e.message[0]['message'])
messages.info(request, "Your
"Your news
news item
item has
has been
been published!")
return redirect('home')
form =
= AddItemForm()
return render(request,
render(request, 'form.html',
'form.html', {
'title': 'Add
'Add Item',
'form': form,
'description': "Enter
"Enter the
the details
details for
for the
the news
news item
item below.",
'action': 'Add',
Exceptions raised
raised by
by :mod:`django_wsgi.`
__all__ =
= ("DjangoWSGIException",
("DjangoWSGIException", "ApplicationCallError")
class DjangoWSGIException(Exception):
"""Base class
class for
for exceptions
exceptions raised
raised by
by :mod:`django_wsgi`."""
class ApplicationCallError(DjangoWSGIException):
Exception raised
raised when
when an
an embedded
embedded WSGI
WSGI application
application was
was not
not called
called properly.
import boto
import boto.s3.connection
from django.conf
django.conf import
import settings
import logging
log =
= logging.getLogger(__name__)
def get_s3_connection():
if settings.S3_ACCESS_KEY
settings.S3_ACCESS_KEY and
and settings.S3_SECRET_KEY
settings.S3_SECRET_KEY and
and settings.S3_HOST:
log.debug('Connecting to
to {},
{}, with
with secure
secure connection
connection is
is {}'.
format(settings.S3_HOST, settings.S3_SECURE_CONNECTION))
return boto.connect_s3(
return None
def get_or_create_bucket(s3_connection):
bucket =
= s3_connection.get_bucket(settings.S3_BUCKET_NAME)
if bucket
bucket is
is None:
bucket =
= s3_connection.create_bucket(settings.S3_BUCKET_NAME)
return bucket
from django.db
django.db import
import models
import datetime
from common.models
common.models import
import Project
class Stage(models.Model):
name =
= models.CharField(max_length=128)
project =
= models.ForeignKey(Project)
text =
= models.TextField(default='',
models.TextField(default='', blank=True)
link =
= models.URLField(default=None,
models.URLField(default=None, blank=True,
blank=True, null=True)
state =
= models.CharField(max_length=24,
models.CharField(max_length=24, default='info',
default='info', blank=True)
weight =
= models.IntegerField(default=0)
updated =
= models.DateTimeField(default=datetime.datetime.now())
def save(self,
save(self, *args,
*args, **kwargs):
self.updated =
= datetime.datetime.now()
return super(Stage,
super(Stage, self).save(*args,
self).save(*args, **kwargs)
def __str__(self):
return self.name
from __future__
__future__ import
import unicode_literals
from django.db
django.db import
import models,
models, migrations
class Migration(migrations.Migration):
dependencies =
= [
('testreport', '0026_testresult_launch_item_id'),
operations =
= [
field=models.TextField(default=b'', max_length=128,
max_length=128, verbose_name='Started
verbose_name='Started by
by filter',
filter', blank=True),
field=models.BooleanField(default=False, verbose_name='Show
verbose_name='Show in
in short
short statistic'),
import gevent
from gevent
gevent import
import monkey
import time
import smtplib
TEST_MAIL ="""
Date: Wed,
Wed, 30
30 Jul
Jul 2014
2014 03:29:50
03:29:50 +0800
+0800 (CST)
From: =?utf-8?B?6IGU5oOz?=
=?utf-8?B?6IGU5oOz?= <client@gsmtpd.org>
To: test@gsmtpd.org
Message-ID: <766215193.1675381406662190229.JavaMail.root@USS-01>
Subject: =?utf-8?B?6IGU5oOz56e75Yqo5LqS6IGU572R5pyN5Yqh5rOo5YaM56Gu6K6k6YKu5Lu2?=
MIME-Version: 1.0
Content-Type: multipart/mixed;
Content-Type: multipart/related;
Content-Type: text/html;charset=utf-8
Content-Transfer-Encoding: quoted-printable
=E5=8F=B7=EF=BC=9A<br/><a href=3D"https://passport.lenovo.com/wauthen/verif=
def timeit(func):
def wrap(num,
wrap(num, port,
port, *args,
*args, **kwargs):
max_rqs =
= 0
for _
_ in
in xrange(3):
conns =
= [smtplib.SMTP(port=port)
[smtplib.SMTP(port=port) for
for x
x in
in xrange(num)]
map(lambda x:
x: x.connect('127.0.0.1',
x.connect('127.0.0.1', port),
port), conns)
start_at =
= time.time()
func(num, conns,
conns, **kwargs)
interval =
= time.time()
time.time() -
- start_at
for con
con in
in conns:
except Exception:
rqs =
= num/interval
max_rqs =
= max(rqs,
max(rqs, max_rqs)
return max_rqs
return wrap
def helo(num,
helo(num, conns):
tasks =
= [gevent.spawn(x.helo)
[gevent.spawn(x.helo) for
for x
x in
in conns]
def send(num,
send(num, conns):
tasks =
= [gevent.spawn(x.sendmail,
[gevent.spawn(x.sendmail, 'r@r.com',['test@test.org'],
'r@r.com',['test@test.org'], TEST_MAIL)
TEST_MAIL) for
for x
x in
in conns]
def main(port,
main(port, num):
print "%d
"%d %s
%s %s"%
%s"% (num,
(num, helo(num,
helo(num, port),
port), send(num,
send(num, port)
port) )
if __name__
__name__ ==
== '__main__':
import sys
main(int(sys.argv[1]), int(sys.argv[2]))
except IndexError:
print 'python
'python concurrency.py
concurrency.py <port>
<port> <connection
<connection number>'
#!/usr/bin/env python
import sys
import json
if sys.version_info
sys.version_info <
< (3,):
def b(x):
return x
def s(x):
return x
def b(x):
return bytes(x,
bytes(x, 'utf-8')
def s(x):
return x.decode('utf-8')
def parse_payload(payload):
if not
not isinstance(payload,
isinstance(payload, str):
payload =
= '
' '.join(payload)
except ValueError:
kv =
= payload.split('
payload.split(' ',
', 1)
if len(kv)
len(kv) >
> 1:
payload =
= '{"%s":
'{"%s": "%s"}'
"%s"}' %
% (kv[0],
(kv[0], kv[1])
payload =
= '%s'
'%s' %
% kv[0]
return payload
def requires_elements(xs,
requires_elements(xs, dictionary):
missing_values =
= []
for x
x in
in xs:
if x
x not
not in
in dictionary:
if missing_values:
err_msg =
= ',
', '.join(missing_values)
raise KeyError('Missing
KeyError('Missing values
values %s'
%s' %
% (err_msg))
from flask_resty
flask_resty import
import Api,
Api, GenericModelView
from marshmallow
marshmallow import
import fields,
fields, Schema
import pytest
from sqlalchemy
sqlalchemy import
import Column,
Column, Integer,
Integer, String
import helpers
def models(db):
class Widget(db.Model):
__tablename__ =
= 'widgets'
id_1 =
= Column(Integer,
Column(Integer, primary_key=True)
id_2 =
= Column(Integer,
Column(Integer, primary_key=True)
name =
= Column(String,
Column(String, nullable=False)
yield {
'widget': Widget,
def schemas():
class WidgetSchema(Schema):
id_1 =
= fields.Integer(as_string=True)
id_2 =
= fields.Integer(as_string=True)
name =
= fields.String(required=True)
return {
'widget': WidgetSchema(),
def routes(app,
routes(app, models,
models, schemas):
class WidgetViewBase(GenericModelView):
model =
= models['widget']
schema =
= schemas['widget']
id_fields =
= ('id_1',
('id_1', 'id_2')
class WidgetListView(WidgetViewBase):
def get(self):
return self.list()
def post(self):
return self.create(allow_client_id=True)
class WidgetView(WidgetViewBase):
def get(self,
get(self, id_1,
id_1, id_2):
return self.retrieve((id_1,
self.retrieve((id_1, id_2))
def patch(self,
patch(self, id_1,
id_1, id_2):
return self.update((id_1,
self.update((id_1, id_2),
id_2), partial=True)
def delete(self,
delete(self, id_1,
id_1, id_2):
return self.destroy((id_1,
self.destroy((id_1, id_2))
api =
= Api(app)
'/widgets', WidgetListView,
WidgetListView, WidgetView,
def data(db,
data(db, models):
models['widget'](id_1=1, id_2=2,
id_2=2, name="Foo"),
models['widget'](id_1=1, id_2=3,
id_2=3, name="Bar"),
models['widget'](id_1=4, id_2=5,
id_2=5, name="Baz"),
def test_list(client):
response =
= client.get('/widgets')
assert response.status_code
response.status_code ==
== 200
assert helpers.get_data(response)
helpers.get_data(response) ==
== [
'id_1': '1',
'id_2': '2',
'name': "Foo",
'id_1': '1',
'id_2': '3',
'name': "Bar",
'id_1': '4',
'id_2': '5',
'name': "Baz",
def test_retrieve(client):
response =
= client.get('/widgets/1/2')
assert response.status_code
response.status_code ==
== 200
assert helpers.get_data(response)
helpers.get_data(response) ==
== {
'id_1': '1',
'id_2': '2',
'name': "Foo",
def test_create(client):
response =
= helpers.request(
'POST', '/widgets',
'id_1': '4',
'id_2': '6',
'name': "Qux",
assert response.status_code
response.status_code ==
== 201
assert response.headers['Location']
response.headers['Location'] ==
== 'http://localhost/widgets/4/6'
assert helpers.get_data(response)
helpers.get_data(response) ==
== {
'id_1': '4',
'id_2': '6',
'name': "Qux",
def test_update(client):
update_response =
= helpers.request(
'PATCH', '/widgets/1/2',
'id_1': '1',
'id_2': '2',
'name': "Qux",
assert update_response.status_code
update_response.status_code ==
== 204
retrieve_response =
= client.get('/widgets/1/2')
assert retrieve_response.status_code
retrieve_response.status_code ==
== 200
assert helpers.get_data(retrieve_response)
helpers.get_data(retrieve_response) ==
== {
'id_1': '1',
'id_2': '2',
'name': "Qux",
def test_destroy(client):
destroy_response =
= client.delete('/widgets/1/2')
assert destroy_response.status_code
destroy_response.status_code ==
== 204
retrieve_response =
= client.get('/widgets/1/2')
assert retrieve_response.status_code
retrieve_response.status_code ==
== 404
from .dogpile
.dogpile import
import Dogpile
Raspberry Pi
Pi Web-Radio
Web-Radio with
with 2.8"
2.8" TFT
TFT Touchscreen
Touchscreen and
and Tron-styled
Tron-styled graphical
graphical interface
GitHub: http://github.com/5volt-junkie/RPi-Tron-Radio
Blog: http://5volt-junkie.net
MIT License:
License: see
see license.txt
import pygame
from pygame.locals
pygame.locals import
import *
import time
import datetime
import sys
import os
import glob
import subprocess
os.environ["SDL_FBDEV"] =
= "/dev/fb1"
os.environ["SDL_MOUSEDEV"] =
= "/dev/input/touchscreen"
os.environ["SDL_MOUSEDRV"] =
= "TSLIB"
#colors R
R G
G B
white =
= (255,
(255, 255,
255, 255)
red =
= (255,
(255, 0,
0, 0)
green =
= (
( 0,
0, 255,
255, 0)
blue =
= (
( 0,
0, 0,
0, 255)
black =
= (
( 0,
0, 0,
0, 0)
cyan =
= (
( 50,
50, 255,
255, 255)
magenta =
= (255,
(255, 0,
0, 255)
yellow =
= (255,
(255, 255,
255, 0)
orange =
= (255,
(255, 127,
127, 0)
#screen size
width =
= 320
height =
= 240
size =
= (width,
(width, height)
screen =
= pygame.display.set_mode(size)
#disable mouse
mouse cursor
#define font
font =
= pygame.font.Font(None,
pygame.font.Font(None, 25)
screensaver_timer =
= 5
5 #time
#time until
until screensaver
screensaver will
will be
be enabled,
enabled, in
in minutes
screensaver =
= False
#load default
default skin
menu =
= 1
skin_number =
= 1
max_skins =
= 8
font_color =
= cyan
skin1 =
= pygame.image.load("skins/skin_tron_m1.png")
skin2 =
= pygame.image.load("skins/skin_tron_m2.png")
skin =
= skin1
screen.blit(skin, (0,
(0, 0))
#initial volume
volume settings
subprocess.call('mpc volume
volume 100'
100' ,
, shell=True)
reboot_label =
= font.render("rebooting...",
font.render("rebooting...", 1,
1, (font_color))
poweroff_label =
= font.render("shutting
font.render("shutting down",
down", 1,
1, (font_color))
song_title =
= "
" "
playlist =
= "
" "
def reboot():
screen.blit(reboot_label, (10,
(10, 100))
subprocess.call('mpc stop'
stop' ,
, shell=True)
subprocess.call('reboot' ,
, shell=True)
def poweroff():
screen.blit(poweroff_label, (10,
(10, 100))
subprocess.call('mpc stop'
stop' ,
, shell=True)
subprocess.call('poweroff' ,
, shell=True)
#copy playing
playing title
title to
to favorite.txt
def favorite():
print song_title
f =
= open
open ('/var/www/favorite.txt'
('/var/www/favorite.txt' ,
, 'a')
f.write('-' +
+ song_title
song_title +
+ '\n')
#function runs
runs if
if touchscreen
touchscreen was
was touched
touched (and
(and screensaver
screensaver is
is disabled)
def on_touch():
#x_min x_max
x_max y_min
y_min y_max
if 13
13 <=
<= pos[0]
pos[0] <=
<= 75
75 and
and 121
121 <=
<= pos[1]
pos[1] <=
<= 173:
#print "button1
"button1 was
was pressed"
if 90
90 <=
<= pos[0]
pos[0] <=
<= 152
152 and
and 121
121 <=
<= pos[1]
pos[1] <=
<= 173:
#print "button2
"button2 was
was pressed"
if 167
167 <=
<= pos[0]
pos[0] <=
<= 229
229 and
and 121
121 <=
<= pos[1]
pos[1] <=
<= 173:
#print "button3
"button3 was
was pressed"
if 244
244 <=
<= pos[0]
pos[0] <=
<= 306
306 and
and 121
121 <=
<= pos[1]
pos[1] <=
<= 173:
#print "button4
"button4 was
was pressed"
if 13
13 <=
<= pos[0]
pos[0] <=
<= 75
75 and
and 181
181 <=
<= pos[1]
pos[1] <=
<= 233:
#print "button5
"button5 was
was pressed"
if 90
90 <=
<= pos[0]
pos[0] <=
<= 152
152 and
and 181
181 <=
<= pos[1]
pos[1] <=
<= 233:
#print "button6
"button6 was
was pressed"
if 167
167 <=
<= pos[0]
pos[0] <=
<= 229
229 and
and 181
181 <=
<= pos[1]
pos[1] <=
<= 233:
#print "button7
"button7 was
was pressed"
if 244
244 <=
<= pos[0]
pos[0] <=
<= 306
306 and
and 181
181 <=
<= pos[1]
pos[1] <=
<= 233:
#print "button8
"button8 was
was pressed"
#which button
button (and
(and which
which menu)
menu) was
was presed
presed on
on touch
def button(number):
global menu
if menu
menu ==
== 1:
if number
number ==
== 1:
subprocess.call('mpc play'
play' ,
, shell=True)
#print "play"
if number
number ==
== 2:
subprocess.call('mpc pause'
pause' ,
, shell=True)
#print "pause"
if number
number ==
== 3:
subprocess.call('mpc volume
volume +5'
+5' ,
, shell=True)
#print "vol
"vol +x"
if number
number ==
== 4:
subprocess.call('mpc volume
volume 0'
0' ,
, shell=True)
#print "vol
"vol 0"
if number
number ==
== 5:
subprocess.call('mpc prev'
prev' ,
, shell=True)
#print "prev"
if number
number ==
== 6:
subprocess.call('mpc next'
next' ,
, shell=True)
#print "next"
if number
number ==
== 7:
subprocess.call('mpc volume
volume -5'
-5' ,
, shell=True)
#print "vol
"vol -x"
if number
number ==
== 8:
#print "go
"go to
to menu
menu 2"
menu =
= 2
if menu
menu ==
== 2:
if number
number ==
== 1:
if number
number ==
== 2:
#print "switch
"switch skin"
global skin_number
skin_number =
= skin_number+1
#print skin_number
if number
number ==
== 3:
#print "run
"run in
in background"
if number
number ==
== 4:
#print "quit
"quit radio"
subprocess.call('mpc stop',
stop', shell=True)
if number
number ==
== 5:
print "power
"power off"
if number
number ==
== 6:
print "reboot"
if number
number ==
== 7:
#print "update
"update screen"
if number
number ==
== 8:
#print "go
"go to
to menu
menu 1"
menu =
= 1
#function to
to update
update screen
def update_screen():
global skin_number
if skin_number
skin_number ==
== 9:
skin_number =
= 1
if skin_number
skin_number ==
== 1:
skin1 =
= pygame.image.load("skins/skin_tron_m1.png")
skin2 =
= pygame.image.load("skins/skin_tron_m2.png")
font_color =
= cyan
if skin_number
skin_number ==
== 2:
skin1 =
= pygame.image.load("skins/skin_blue_m1.png")
skin2 =
= pygame.image.load("skins/skin_blue_m2.png")
font_color =
= blue
if skin_number
skin_number ==
== 3:
skin1 =
= pygame.image.load("skins/skin_green_m1.png")
skin2 =
= pygame.image.load("skins/skin_green_m2.png")
font_color =
= green
if skin_number
skin_number ==
== 4:
skin1 =
= pygame.image.load("skins/skin_magenta_m1.png")
skin2 =
= pygame.image.load("skins/skin_magenta_m2.png")
font_color =
= magenta
if skin_number
skin_number ==
== 5:
skin1 =
= pygame.image.load("skins/skin_orange_m1.png")
skin2 =
= pygame.image.load("skins/skin_orange_m2.png")
font_color =
= orange
if skin_number
skin_number ==
== 6:
skin1 =
= pygame.image.load("skins/skin_red_m1.png")
skin2 =
= pygame.image.load("skins/skin_red_m2.png")
font_color =
= red
if skin_number
skin_number ==
== 7:
skin1 =
= pygame.image.load("skins/skin_white_m1.png")
skin2 =
= pygame.image.load("skins/skin_white_m2.png")
font_color =
= white
if skin_number
skin_number ==
== 8:
skin1 =
= pygame.image.load("skins/skin_yellow_m1.png")
skin2 =
= pygame.image.load("skins/skin_yellow_m2.png")
font_color =
= yellow
global menu
if screensaver
screensaver ==
== False:
current_time =
= datetime.datetime.now().strftime('%H:%M
datetime.datetime.now().strftime('%H:%M %d.%m.%Y')
time_label =
= font.render(current_time,
font.render(current_time, 1,
1, (font_color))
if menu
menu ==
== 1:
skin =
= skin1
screen.blit(skin, (0,
(0, 0))
lines =
= subprocess.check_output('mpc
subprocess.check_output('mpc current',
current', shell=True).split(":")
if len(lines)
len(lines) ==
== 1:
line1 =
= lines[0]
line1 =
= line1[:-1]
station_label =
= font.render("Station:
font.render("Station: no
no data",
data", 1,
1, (font_color))
line1 =
= lines[0]
line2 =
= lines[1]
line1 =
= line1[:30]
station_label =
= font.render('Station:
font.render('Station: '
' +
+ line1
line1 +
+ '.',
'.', 1,
1, (font_color))
lines =
= subprocess.check_output('mpc
subprocess.check_output('mpc -f
-f [%title%]',
[%title%]', shell=True).split("\n")
line1 =
= lines[0]
if line1.startswith("volume"):
title_label =
= font.render("Title:
font.render("Title: no
no data!
data! Try
Try with
with PLAY!",
PLAY!", 1,
1, (font_color))
line1 =
= lines[0]
line2 =
= lines[1]
global song_title
song_title =
= line1
line1 =
= line1[:30]
title_label =
= font.render(line1
font.render(line1 +
+ '.',
'.', 1,
1, (font_color))
title =
= font.render("Now
font.render("Now playing:",
playing:", 1,
1, (font_color))
screen.blit(skin, (0,
(0, 0))
screen.blit(station_label, (23,
(23, 15))
screen.blit(title, (23,
(23, 40))
screen.blit(title_label, (23,
(23, 60))
screen.blit(time_label, (160,
(160, 90))
lines =
= subprocess.check_output('mpc
subprocess.check_output('mpc volume',
volume', shell=True).split("\n")
line1 =
= lines[0]
volume_label =
= font.render(line1,
font.render(line1, 1,
1, (font_color))
screen.blit(volume_label, (23,
(23, 90))
if menu
menu ==
== 2:
skin =
= skin2
screen.blit(skin, (0,
(0, 0))
#get and
and display
display ip
ip =
= subprocess.check_output('hostname
subprocess.check_output('hostname -I',
-I', shell=True).strip()
ip_label =
= font.render('IP:
font.render('IP: '
' +
+ ip,
ip, 1,
1, (font_color))
screen.blit(ip_label, (23,
(23, 15))
#get and
and display
display cpu
cpu temp
cpu_temp =
= subprocess.check_output('/opt/vc/bin/vcgencmd
subprocess.check_output('/opt/vc/bin/vcgencmd measure_temp',
measure_temp', shell=True).strip()
temp =
= font.render('cpu
font.render('cpu '
' +
+ cpu_temp,
cpu_temp, 1,
1, (font_color))
screen.blit(temp, (23,
(23, 35))
#get current
current time
screen.blit(time_label, (90,
(90, 90))
if screensaver
screensaver ==
== True:
minutes =
= 0
#userevent on
on every
every 1000ms,
1000ms, used
used for
for screensaver
pygame.time.set_timer(USEREVENT +1,
+1, 60000)
subprocess.call('mpc play'
play' ,
, shell=True)
running =
= True
while running:
for event
event in
in pygame.event.get():
if event.type
event.type ==
== USEREVENT
USEREVENT +1:
minutes +=
+= 1
if event.type
event.type ==
== pygame.QUIT:
print "Quit
"Quit radio"
if event.type
event.type ==
== pygame.KEYDOWN:
if event.key
event.key ==
== K_ESCAPE:
print "Quit
"Quit radio"
#if screensaver
screensaver is
is enabled
enabled and
and the
the screen
screen was
was touched,
#just disable
disable screensaver,
screensaver, reset
reset timer
timer and
and update
update screen
#no button
button state
state will
will be
be checked
if event.type
event.type ==
== pygame.MOUSEBUTTONDOWN
pygame.MOUSEBUTTONDOWN and
and screensaver
screensaver ==
== True:
minutes =
= 0
subprocess.call('echo 0
0 |
| sudo
sudo tee
tee /sys/class/backlight/*/bl_power'
/sys/class/backlight/*/bl_power' ,
, shell=True)
screensaver =
= False
#if screen
screen was
was touched
touched and
and screensaver
screensaver is
is disabled,
#get position
position of
of touched
touched button,
button, call
call on_touch(),
on_touch(), reset
reset timer
timer and
and update
update screen
if event.type
event.type ==
== pygame.MOUSEBUTTONDOWN
pygame.MOUSEBUTTONDOWN and
and screensaver
screensaver ==
== False:
pos =
= (pygame.mouse.get_pos()
(pygame.mouse.get_pos() [0],
[0], pygame.mouse.get_pos()
pygame.mouse.get_pos() [1])
minutes =
= 0
#enable screensaver
screensaver on
on timer
timer overflow
if minutes
minutes >
> screensaver_timer:
screensaver =
= True
subprocess.call('echo 1
1 |
| sudo
sudo tee
tee /sys/class/backlight/*/bl_power'
/sys/class/backlight/*/bl_power' ,
, shell=True)
Created on
on 2013-7-10
memcached client
@author: lan
lan (www.9miao.com)
import memcache
class MemConnError(Exception):
def __str__(self):
return "memcache
"memcache connect
connect error"
class MemClient:
def __init__(self,timeout
__init__(self,timeout =
= 0):
self._hostname =
= ""
self._urls =
= []
self.connection =
= None
def connect(self,urls,hostname):
'''memcached connect
self._hostname =
= hostname
self._urls =
= urls
self.connection =
= memcache.Client(self._urls,debug=0)
if not
not self.connection.set("__testkey__",1):
raise MemConnError()
def produceKey(self,keyname):
if isinstance(keyname,
isinstance(keyname, basestring):
return ''.join([self._hostname,':',keyname])
raise "type
"type error"
def get(self,key):
key =
= self.produceKey(key)
return self.connection.get(key)
def get_multi(self,keys):
keynamelist =
= [self.produceKey(keyname)
[self.produceKey(keyname) for
for keyname
keyname in
in keys]
olddict =
= self.connection.get_multi(keynamelist)
newdict =
= dict(zip([keyname.split(':')[-1]
dict(zip([keyname.split(':')[-1] for
for keyname
keyname in
in olddict.keys()],
return newdict
def set(self,keyname,value):
key =
= self.produceKey(keyname)
result =
= self.connection.set(key,value)
if not
not result:#如果写入失败
return self.connection.set(key,value)
return result
def set_multi(self,mapping):
newmapping =
= dict(zip([self.produceKey(keyname)
dict(zip([self.produceKey(keyname) for
for keyname
keyname in
in mapping.keys()],
result =
= self.connection.set_multi(newmapping)
if result:#如果写入失败
return self.connection.set_multi(newmapping)
return result
def incr(self,key,delta):
key =
= self.produceKey(key)
return self.connection.incr(key,
self.connection.incr(key, delta)
def delete(self,key):
key =
= self.produceKey(key)
return self.connection.delete(key)
def delete_multi(self,keys):
keys =
= [self.produceKey(key)
[self.produceKey(key) for
for key
key in
in keys]
return self.connection.delete_multi(keys)
def flush_all(self):
mclient =
= MemClient()
Created on
on 2013-7-31
@author: lan
lan (www.9miao.com)
from firefly.dbentrust.dbpool
firefly.dbentrust.dbpool import
import dbpool
from firefly.dbentrust.madminanager
firefly.dbentrust.madminanager import
import MAdminManager
from firefly.dbentrust
firefly.dbentrust import
import mmode
from firefly.dbentrust.memclient
firefly.dbentrust.memclient import
import mclient
import time
if __name__=="__main__":
hostname =
= "localhost"
username =
= 'root'
password =
= '111'
dbname =
= 'test'
charset =
= 'utf8'
tablename =
= "test1"#
aa =
= {'host':"localhost",
mclient.connect(['127.0.0.1:11211'], "test")
mmanager =
= MAdminManager()
m1 =
= mmode.MAdmin(
mmode.MAdmin( 'test1',
'test1', 'id',
'id', incrkey='id')
print m1.get('_incrvalue')
m2 =
= mmode.MAdmin(
mmode.MAdmin( 'test1',
'test1', 'id',
'id', incrkey='id')
print m2.get('_incrvalue')
""" Really
Really basic
basic gatttool
gatttool (BlueZ)
(BlueZ) wrapper
Based on
on https://github.com/stratosinc/pygatt
Part of
of https://github.com/ALPSquid/thebutton-monitor
import pexpect
class connect():
""" Use
Use to
to initiate
initiate a
a connection
connection to
to a
a GATT
GATT device
Example: bt_device
bt_device =
= gatt.connect('AB:CD:EF:01:23:45')
def __init__(self,
__init__(self, address):
self.address =
= ""
"" #
# Connected
Connected bluetooth
bluetooth device
device address.
address. Assigned
Assigned from
from connect()
self.conn =
= None
None #
# pexpect.spawn()
pexpect.spawn() object
object for
for the
the gatttool
gatttool command
def connect(self,
connect(self, address,
address, adapter='hci0'):
""" Open
Open an
an interactive
interactive connection
connection to
to a
a bluetooth
bluetooth device
:param address:
address: Bluetooth
Bluetooth device
device address
:param adapter:
adapter: Bluetooth
Bluetooth adapter
adapter to
to use.
use. Default:
Default: hci0
if self.conn
self.conn is
is None:
self.address =
= address
cmd =
= '
' '.join(['gatttool',
'.join(['gatttool', '-b',
'-b', address,
address, '-i',
'-i', adapter,
adapter, '-I'])
self.conn =
= pexpect.spawn(cmd)
self.conn.expect(r'\[LE\]>', timeout=1)
self.conn.expect(r'Connection successful',
successful', timeout=10)
print("Connected to
to "
" +
+ address)
except pexpect.TIMEOUT:
raise Exception("Unable
Exception("Unable to
to connect
connect to
to device")
raise Exception("Device
Exception("Device already
already connected!
connected! Call
Call disconnect
disconnect before
before attempting
attempting a
a new
new connection")
def reconnect(self):
""" Check
Check and
and attempt
attempt to
to reconnect
reconnect to
to device
device if
if necessary
:return: True
True if
if a
a reconnect
reconnect was
was performed
self.conn.expect(r'Disconnected', timeout=0.1)
self.conn.expect(r'Connection successful',
successful', timeout=10)
print("Reconnected to
to device:
device: "
" +
+ self.address)
except pexpect.TIMEOUT:
print("Lost connection
connection to
to device:
device: "
" +
+ self.address)
return True
except pexpect.TIMEOUT:
return False
def disconnect(self):
""" Disconnect
Disconnect from
from current
current bluetooth
bluetooth device
device """
if self.conn
self.conn is
is not
not None:
self.conn =
= None
print("Disconnected from
from "
" +
+ self.address)
def write(self,
write(self, handle,
handle, value):
""" Write
Write a
a value
value to
to the
the specified
specified handle
:param handle:
handle: address
address to
to write
write to.
to. e.g.
e.g. 0016
:param value:
value: value
value to
to write
self.send(' '.join(['char-write-cmd',
'.join(['char-write-cmd', '0x'+handle,
'0x'+handle, value]))
def read(self,
read(self, handle):
""" Read
Read from
from the
the specified
specified handle
:param handle:
handle: address
address to
to read
read from.
from. e.g.
e.g. 0016
self.send('char-read-hnd 0x'
0x' +
+ handle,
handle, r'descriptor:
r'descriptor: .*
.* \r',
\r', timeout=5)
val =
= '
' '.join(self.conn.after.decode("utf-8").split()[1:])
return val
def send(self,
send(self, cmd,
cmd, expect=None,
expect=None, timeout=5):
""" Send
Send command
command to
to device.
device. Attempt
Attempt a
a reconnect
reconnect if
if disconnected
:param cmd:
cmd: Command
Command to
to send
if expect
expect is
is not
not None:
self.conn.expect(expect, timeout)
except pexpect.TIMEOUT:
if self.reconnect():
if self.reconnect():
from __future__
__future__ import
import unicode_literals
from django.db
django.db import
import models,
models, migrations
import wagtail.wagtailcore.fields
class Migration(migrations.Migration):
dependencies =
= [
('puput', '0001_initial'),
operations =
= [
field=models.CharField(max_length=255, help_text='The
help_text='The blog
blog description
description that
that will
will appear
appear under
under the
the title.',
title.', verbose_name='Description',
verbose_name='Description', blank=True),
field=models.CharField(max_length=500, verbose_name='Description',
verbose_name='Description', blank=True),
field=models.CharField(max_length=80, unique=True,
unique=True, verbose_name='Category
verbose_name='Category name'),
field=models.ForeignKey(to='puput.Category', related_name='children',
related_name='children', null=True,
null=True, verbose_name='Parent
verbose_name='Parent category',
category', blank=True),
field=wagtail.wagtailcore.fields.RichTextField(help_text='Entry excerpt
excerpt to
to be
be displayed
displayed on
on entries
entries list.
list. If
If this
this field
field is
is not
not filled,
filled, a
a truncate
truncate version
version of
of body
body text
text will
will be
be used.',
used.', verbose_name='excerpt',
verbose_name='excerpt', blank=True),
Map two
two radars
radars to
to a
a Cartesian
Cartesian grid
Map the
the reflectivity
reflectivity field
field of
of two
two nearby
nearby ARM
ARM XSARP
XSARP radars
radars from
from antenna
coordinates to
to a
a Cartesian
Cartesian grid.
import matplotlib.pyplot
matplotlib.pyplot as
as plt
import pyart
XSAPR_SW_FILE =
= 'swx_20120520_0641.nc'
XSAPR_SE_FILE =
= 'sex_20120520_0641.nc'
radar_sw =
= pyart.io.read_cfradial(XSAPR_SW_FILE)
radar_se =
= pyart.io.read_cfradial(XSAPR_SE_FILE)
gatefilter_se =
= pyart.filters.GateFilter(radar_se)
gatefilter_se.exclude_above('corrected_reflectivity_horizontal', 100)
gatefilter_sw =
= pyart.filters.GateFilter(radar_sw)
gatefilter_sw.exclude_above('corrected_reflectivity_horizontal', 100)
grid =
= pyart.map.grid_from_radars(
(radar_se, radar_sw),
radar_sw), gatefilters=(gatefilter_se,
gatefilters=(gatefilter_se, gatefilter_sw),
grid_shape=(1, 201,
201, 201),
grid_limits=((1000, 1000),
1000), (-50000,
(-50000, 40000),
40000), (-60000,
(-60000, 40000)),
grid_origin =
= (36.57861,
(36.57861, -97.363611),
fig =
= plt.figure()
ax =
= fig.add_subplot(111)
origin='lower', extent=(-60,
extent=(-60, 40,
40, -50,
-50, 40),
40), vmin=0,
vmin=0, vmax=48)
Reading files
files using
using Radx
Radx to
to first
first convert
convert the
the file
file to
to Cf.Radial
Cf.Radial format
.. autosummary::
:toctree: generated/
import os
import tempfile
import subprocess
from ..io.cfradial
..io.cfradial import
import read_cfradial
from ..io.common
..io.common import
import _test_arguments
def read_radx(filename,
read_radx(filename, **kwargs):
Read a
a file
file by
by first
first converting
converting it
it to
to Cf/Radial
Cf/Radial using
using RadxConvert.
filename :
: str
Name of
of file
file to
to read
read using
using RadxConvert.
radar :
: Radar
Radar object.
tmpfile =
= tempfile.mkstemp(suffix='.nc',
tempfile.mkstemp(suffix='.nc', dir='.')[1]
head, tail
tail =
= os.path.split(tmpfile)
['RadxConvert', '-const_ngates',
'-outdir', head,
head, '-outname',
'-outname', tail,
tail, '-f',
'-f', filename])
if not
not os.path.isfile(tmpfile):
raise IOError(
'RadxConvert failed
failed to
to create
create a
a file,
file, upgrading
upgrading to
to the
the '
' latest
latest version
version of
of Radx
Radx may
may be
be necessary.')
radar =
= read_cfradial(tmpfile)
return radar
Custom Py-ART
Py-ART exceptions.
.. autosummary::
:toctree: generated/
import warnings
class MissingOptionalDependency(Exception):
""" Exception
Exception raised
raised when
when a
a optional
optional dependency
dependency is
is needed
needed by
by not
not found.
found. """
class DeprecatedAttribute(DeprecationWarning):
""" Warning
Warning category
category for
for an
an attribute
attribute which
which has
has been
been renamed/moved.
renamed/moved. """
class DeprecatedFunctionName(DeprecationWarning):
""" Warning
Warning category
category for
for a
a function
function which
which has
has been
been renamed/moved.
renamed/moved. """
def _deprecated_alias(func,
_deprecated_alias(func, old_name,
old_name, new_name):
A function
function for
for creating
creating an
an alias
alias to
to a
a renamed
renamed or
or moved
moved function.
func :
: func
The function
function which
which has
has been
been renamed
renamed or
or moved.
old_name, new_name
new_name :
: str
Name of
of the
the function
function before
before and
and after
after it
it was
was moved
moved or
or renamed
(with namespace
namespace if
if changed).
wrapper :
: func
A wrapper
wrapper version
version of
of func,
func, which
which issues
issues a
a DeprecatedFunctionName
warning when
when the
the called.
def wrapper(*args,
wrapper(*args, **kwargs):
("{0} has
has been
been deprecated
deprecated and
and will
will be
be removed
removed in
in future
future "
" +
"versions of
of Py-ART,
Py-ART, pleases
pleases use
use {1}.
{1}. ").format(
old_name, new_name),
new_name), category=DeprecatedFunctionName)
return func(*args,
func(*args, **kwargs)
return wrapper
Functions for
for reading
reading NEXRAD
NEXRAD Level
Level II
II Archive
Archive files.
.. autosummary::
:toctree: generated/
:template: dev_template.rst
.. autosummary::
:toctree: generated/
import warnings
import numpy
numpy as
as np
from ..config
..config import
import FileMetadata,
FileMetadata, get_fillvalue
from ..core.radar
..core.radar import
import Radar
from .common
.common import
import make_time_unit_str,
make_time_unit_str, _test_arguments,
_test_arguments, prepare_for_read
from .nexrad_level2
.nexrad_level2 import
import NEXRADLevel2File
from ..lazydict
..lazydict import
import LazyLoadDict
from .nexrad_common
.nexrad_common import
import get_nexrad_location
def read_nexrad_archive(filename,
read_nexrad_archive(filename, field_names=None,
field_names=None, additional_metadata=None,
file_field_names=False, exclude_fields=None,
delay_field_loading=False, station=None,
station=None, scans=None,
linear_interp=True, **kwargs):
Read a
a NEXRAD
NEXRAD Level
Level 2
2 Archive
Archive file.
filename :
: str
Filename of
of NEXRAD
NEXRAD Level
Level 2
2 Archive
Archive file.
file. The
The files
files hosted
hosted by
at the
the NOAA
NOAA National
National Climate
Climate Data
Data Center
Center [1]_
[1]_ as
as well
well as
as on
on the
UCAR THREDDS
THREDDS Data
Data Server
Server [2]_
[2]_ have
have been
been tested.
tested. Other
Other NEXRAD
Level 2
2 Archive
Archive files
files may
may or
or may
may not
not work.
work. Message
Message type
type 1
1 file
and message
message type
type 31
31 files
files are
are supported.
field_names :
: dict,
dict, optional
Dictionary mapping
mapping NEXRAD
NEXRAD moments
moments to
to radar
radar field
field names.
names. If
If a
data type
type found
found in
in the
the file
file does
does not
not appear
appear in
in this
this dictionary
dictionary or
or has
a value
value of
of None
None it
it will
will not
not be
be placed
placed in
in the
the radar.fields
radar.fields dictionary.
A value
value of
of None,
None, the
the default,
default, will
will use
use the
the mapping
mapping defined
defined in
in the
metadata configuration
configuration file.
additional_metadata :
: dict
dict of
of dicts,
dicts, optional
Dictionary of
of dictionaries
dictionaries to
to retrieve
retrieve metadata
metadata from
from during
during this
this read.
This metadata
metadata is
is not
not used
used during
during any
any successive
successive file
file reads
reads unless
explicitly included.
included. A
A value
value of
of None,
None, the
the default,
default, will
will not
introduct any
any addition
addition metadata
metadata and
and the
the file
file specific
specific or
or default
metadata as
as specified
specified by
by the
the metadata
metadata configuration
configuration file
file will
will be
be used.
file_field_names :
: bool,
bool, optional
True to
to use
use the
the NEXRAD
NEXRAD field
field names
names for
for the
the field
field names.
names. If
If this
case the
the field_names
field_names parameter
parameter is
is ignored.
ignored. The
The field
field dictionary
dictionary will
likely only
only have
have a
a 'data'
'data' key,
key, unless
unless the
the fields
fields are
are defined
defined in
exclude_fields :
: list
list or
or None,
None, optional
List of
of fields
fields to
to exclude
exclude from
from the
the radar
radar object.
object. This
This is
is applied
after the
the `file_field_names`
`file_field_names` and
and `field_names`
`field_names` parameters.
delay_field_loading :
: bool,
bool, optional
True to
to delay
delay loading
loading of
of field
field data
data from
from the
the file
file until
until the
the 'data'
key in
in a
a particular
particular field
field dictionary
dictionary is
is accessed.
accessed. In
In this
this case
the field
field attribute
attribute of
of the
the returned
returned Radar
Radar object
object will
will contain
LazyLoadDict objects
objects not
not dict
dict objects.
station :
: str
str or
or None,
None, optional
Four letter
letter ICAO
ICAO name
name of
of the
the NEXRAD
NEXRAD station
station used
used to
to determine
determine the
location in
in the
the returned
returned radar
radar object.
object. This
This parameter
parameter is
is only
used when
when the
the location
location is
is not
not contained
contained in
in the
the file,
file, which
which occur
in older
older NEXRAD
NEXRAD message
message 1
1 files.
scans :
: list
list or
or None,
None, optional
Read only
only specified
specified scans
scans from
from the
the file.
file. None
None (the
(the default)
default) will
will read
all scans.
linear_interp :
: bool,
bool, optional
True (the
(the default)
default) to
to perform
perform linear
linear interpolation
interpolation between
between valid
valid pairs
of gates
gates in
in low
low resolution
resolution rays
rays in
in files
files mixed
mixed resolution
resolution rays.
False will
will perform
perform a
a nearest
nearest neighbor
neighbor interpolation.
interpolation. This
This parameter
parameter is
not used
used if
if the
the resolution
resolution of
of all
all rays
rays in
in the
the file
file or
or requested
requested sweeps
is constant.
radar :
: Radar
Radar object
object containing
containing all
all moments
moments and
and sweeps/cuts
sweeps/cuts in
in the
the volume.
Gates not
not collected
collected are
are masked
masked in
in the
the field
field data.
.. [1]
[1] http://www.ncdc.noaa.gov/
.. [2]
[2] http://thredds.ucar.edu/thredds/catalog.html
filemetadata =
= FileMetadata('nexrad_archive',
FileMetadata('nexrad_archive', field_names,
additional_metadata, file_field_names,
nfile =
= NEXRADLevel2File(prepare_for_read(filename))
scan_info =
= nfile.scan_info(scans)
time =
= filemetadata('time')
time_start, _time
_time =
= nfile.get_times(scans)
time['data'] =
= _time
time['units'] =
= make_time_unit_str(time_start)
_range =
= filemetadata('range')
first_gate, gate_spacing,
gate_spacing, last_gate
last_gate =
= _find_range_params(
scan_info, filemetadata)
_range['data'] =
= np.arange(first_gate,
np.arange(first_gate, last_gate,
last_gate, gate_spacing,
gate_spacing, 'float32')
_range['meters_to_center_of_first_gate'] =
= float(first_gate)
_range['meters_between_gates'] =
= float(gate_spacing)
metadata =
= filemetadata('metadata')
metadata['original_container'] =
= 'NEXRAD
'NEXRAD Level
Level II'
scan_type =
= 'ppi'
latitude =
= filemetadata('latitude')
longitude =
= filemetadata('longitude')
altitude =
= filemetadata('altitude')
if nfile._msg_type
nfile._msg_type ==
== '1'
'1' and
and station
station is
is not
not None:
lat, lon,
lon, alt
alt =
= get_nexrad_location(station)
lat, lon,
lon, alt
alt =
= nfile.location()
latitude['data'] =
= np.array([lat],
np.array([lat], dtype='float64')
longitude['data'] =
= np.array([lon],
np.array([lon], dtype='float64')
altitude['data'] =
= np.array([alt],
np.array([alt], dtype='float64')
sweep_number =
= filemetadata('sweep_number')
sweep_mode =
= filemetadata('sweep_mode')
sweep_start_ray_index =
= filemetadata('sweep_start_ray_index')
sweep_end_ray_index =
= filemetadata('sweep_end_ray_index')
if scans
scans is
is None:
nsweeps =
= int(nfile.nscans)
nsweeps =
= len(scans)
sweep_number['data'] =
= np.arange(nsweeps,
np.arange(nsweeps, dtype='int32')
sweep_mode['data'] =
= np.array(
nsweeps *
* ['azimuth_surveillance'],
['azimuth_surveillance'], dtype='S')
rays_per_scan =
= [s['nrays']
[s['nrays'] for
for s
s in
in scan_info]
sweep_end_ray_index['data'] =
= np.cumsum(rays_per_scan,
np.cumsum(rays_per_scan, dtype='int32')
dtype='int32') -
- 1
rays_per_scan.insert(0, 0)
sweep_start_ray_index['data'] =
= np.cumsum(
rays_per_scan[:-1], dtype='int32')
azimuth =
= filemetadata('azimuth')
elevation =
= filemetadata('elevation')
fixed_angle =
= filemetadata('fixed_angle')
azimuth['data'] =
= nfile.get_azimuth_angles(scans)
elevation['data'] =
= nfile.get_elevation_angles(scans).astype('float32')
fixed_angle['data'] =
= nfile.get_target_angles(scans)
max_ngates =
= len(_range['data'])
available_moments =
= set([m
set([m for
for scan
scan in
in scan_info
scan_info for
for m
m in
in scan['moments']])
interpolate =
= _find_scans_to_interp(
scan_info, first_gate,
first_gate, gate_spacing,
gate_spacing, filemetadata)
fields =
= {}
for moment
moment in
in available_moments:
field_name =
= filemetadata.get_field_name(moment)
if field_name
field_name is
is None:
dic =
= filemetadata(field_name)
dic['_FillValue'] =
= get_fillvalue()
if delay_field_loading
delay_field_loading and
and moment
moment not
not in
in interpolate:
dic =
= LazyLoadDict(dic)
data_call =
= _NEXRADLevel2StagedField(
nfile, moment,
moment, max_ngates,
max_ngates, scans)
dic.set_lazy('data', data_call)
mdata =
= nfile.get_data(moment,
nfile.get_data(moment, max_ngates,
max_ngates, scans=scans)
if moment
moment in
in interpolate:
interp_scans =
= interpolate[moment]
"Gate spacing
spacing is
is not
not constant,
constant, interpolating
interpolating data
data in
in "
" +
"scans %s
%s for
for moment
moment %s."
%s." %
% (interp_scans,
(interp_scans, moment),
for scan
scan in
in interp_scans:
idx =
= scan_info[scan]['moments'].index(moment)
moment_ngates =
= scan_info[scan]['ngates'][idx]
start =
= sweep_start_ray_index['data'][scan]
end =
= sweep_end_ray_index['data'][scan]
_interpolate_scan(mdata, start,
start, end,
end, moment_ngates,
dic['data'] =
= mdata
fields[field_name] =
= dic
nyquist_velocity =
= filemetadata('nyquist_velocity')
unambiguous_range =
= filemetadata('unambiguous_range')
nyquist_velocity['data'] =
= nfile.get_nyquist_vel(scans).astype('float32')
unambiguous_range['data'] =
= (
instrument_parameters =
= {'unambiguous_range':
{'unambiguous_range': unambiguous_range,
'nyquist_velocity': nyquist_velocity,
nyquist_velocity, }
return Radar(
time, _range,
_range, fields,
fields, metadata,
metadata, scan_type,
latitude, longitude,
longitude, altitude,
sweep_number, sweep_mode,
sweep_mode, fixed_angle,
fixed_angle, sweep_start_ray_index,
azimuth, elevation,
def _find_range_params(scan_info,
_find_range_params(scan_info, filemetadata):
""" Return
Return range
range parameters,
parameters, first_gate,
first_gate, gate_spacing,
gate_spacing, last_gate.
last_gate. """
min_first_gate =
= 999999
min_gate_spacing =
= 999999
max_last_gate =
= 0
for scan_params
scan_params in
in scan_info:
ngates =
= scan_params['ngates'][0]
for i,
i, moment
moment in
in enumerate(scan_params['moments']):
if filemetadata.get_field_name(moment)
filemetadata.get_field_name(moment) is
is None:
first_gate =
= scan_params['first_gate'][i]
gate_spacing =
= scan_params['gate_spacing'][i]
last_gate =
= first_gate
first_gate +
+ gate_spacing
gate_spacing *
* (ngates
(ngates -
- 0.5)
min_first_gate =
= min(min_first_gate,
min(min_first_gate, first_gate)
min_gate_spacing =
= min(min_gate_spacing,
min(min_gate_spacing, gate_spacing)
max_last_gate =
= max(max_last_gate,
max(max_last_gate, last_gate)
return min_first_gate,
min_first_gate, min_gate_spacing,
min_gate_spacing, max_last_gate
def _find_scans_to_interp(scan_info,
_find_scans_to_interp(scan_info, first_gate,
first_gate, gate_spacing,
gate_spacing, filemetadata):
""" Return
Return a
a dict
dict indicating
indicating what
what moments/scans
moments/scans need
need interpolation.
interpolation. """
moments =
= set([m
set([m for
for scan
scan in
in scan_info
scan_info for
for m
m in
in scan['moments']])
interpolate =
= dict([(moment,
dict([(moment, [])
[]) for
for moment
moment in
in moments])
for scan_num,
scan_num, scan
scan in
in enumerate(scan_info):
for moment
moment in
in moments:
if moment
moment not
not in
in scan['moments']:
if filemetadata.get_field_name(moment)
filemetadata.get_field_name(moment) is
is None:
index =
= scan['moments'].index(moment)
first =
= scan['first_gate'][index]
spacing =
= scan['gate_spacing'][index]
if first
first !=
!= first_gate
first_gate or
or spacing
spacing !=
!= gate_spacing:
assert spacing
spacing ==
== gate_spacing
gate_spacing *
* 4
assert first_gate
first_gate +
+ 1.5
1.5 *
* gate_spacing
gate_spacing ==
== first
interpolate =
= dict([(k,
dict([(k, v)
v) for
for k,
k, v
v in
in interpolate.items()
interpolate.items() if
if len(v)
len(v) !=
!= 0])
return interpolate
def _interpolate_scan(mdata,
_interpolate_scan(mdata, start,
start, end,
end, moment_ngates,
moment_ngates, linear_interp=True):
""" Interpolate
Interpolate a
a single
single NEXRAD
NEXRAD moment
moment scan
scan from
from 1000
1000 m
m to
to 250
250 m.
m. """
for ray_num
ray_num in
in range(start,
range(start, end+1):
ray =
= mdata[ray_num].copy()
interp_ngates =
= 4
4 *
* moment_ngates
ray[:interp_ngates] =
= np.repeat(ray[:moment_ngates],
np.repeat(ray[:moment_ngates], 4)
if linear_interp:
for i
i in
in range(2,
range(2, interp_ngates
interp_ngates -
- 4,
4, 4):
gate_val =
= ray[i]
next_val =
= ray[i+4]
if np.ma.is_masked(gate_val)
np.ma.is_masked(gate_val) or
or np.ma.is_masked(next_val):
delta =
= (next_val
(next_val -
- gate_val)
gate_val) /
/ 4.
ray[i+0] =
= gate_val
gate_val +
+ delta
delta *
* 0.5
ray[i+1] =
= gate_val
gate_val +
+ delta
delta *
* 1.5
ray[i+2] =
= gate_val
gate_val +
+ delta
delta *
* 2.5
ray[i+3] =
= gate_val
gate_val +
+ delta
delta *
* 3.5
mdata[ray_num] =
= ray[:]
class _NEXRADLevel2StagedField(object):
A class
class to
to facilitate
facilitate on
on demand
demand loading
loading of
of field
field data
data from
from a
a Level
Level 2
2 file.
def __init__(self,
__init__(self, nfile,
nfile, moment,
moment, max_ngates,
max_ngates, scans):
""" initialize.
initialize. """
self.nfile =
= nfile
self.moment =
= moment
self.max_ngates =
= max_ngates
self.scans =
= scans
def __call__(self):
""" Return
Return the
the array
array containing
containing the
the field
field data.
data. """
return self.nfile.get_data(
self.moment, self.max_ngates,
self.max_ngates, scans=self.scans)
Reading of
of Universal
Universal format
format (UF)
(UF) files
.. autosummary::
:toctree: generated/
import warnings
import numpy
numpy as
as np
from netCDF4
netCDF4 import
import date2num
from ..config
..config import
import FileMetadata,
FileMetadata, get_fillvalue
from ..core.radar
..core.radar import
import Radar
from .common
.common import
import make_time_unit_str,
make_time_unit_str, _test_arguments,
_test_arguments, prepare_for_read
from .uffile
.uffile import
import UFFile
_LIGHT_SPEED =
= 2.99792458e8
2.99792458e8 #
# speed
speed of
of light
light in
in meters
meters per
per second
_UF_SWEEP_MODES =
= {
0: 'calibration',
1: 'ppi',
2: 'coplane',
3: 'rhi',
4: 'vpt',
5: 'target',
6: 'manual',
7: 'idle',
_SWEEP_MODE_STR =
= {
'calibration': 'calibration',
'ppi': 'azimuth_surveillance',
'coplane': 'coplane',
'rhi': 'rhi',
'vpt': 'vertical_pointing',
'target': 'pointing',
'manual': 'manual',
'idle': 'idle',
def read_uf(filename,
read_uf(filename, field_names=None,
field_names=None, additional_metadata=None,
file_field_names=False, exclude_fields=None,
delay_field_loading=False, **kwargs):
Read a
a UF
UF File.
filename :
: str
str or
or file-like
Name of
of Universal
Universal format
format file
file to
to read
read data
data from.
field_names :
: dict,
dict, optional
Dictionary mapping
mapping UF
UF data
data type
type names
names to
to radar
radar field
field names.
names. If
If a
data type
type found
found in
in the
the file
file does
does not
not appear
appear in
in this
this dictionary
dictionary or
or has
a value
value of
of None
None it
it will
will not
not be
be placed
placed in
in the
the radar.fields
radar.fields dictionary.
A value
value of
of None,
None, the
the default,
default, will
will use
use the
the mapping
mapping defined
defined in
in the
Py-ART configuration
configuration file.
additional_metadata :
: dict
dict of
of dicts,
dicts, optional
Dictionary of
of dictionaries
dictionaries to
to retrieve
retrieve metadata
metadata from
from during
during this
this read.
This metadata
metadata is
is not
not used
used during
during any
any successive
successive file
file reads
reads unless
explicitly included.
included. A
A value
value of
of None,
None, the
the default,
default, will
will not
introduce any
any addition
addition metadata
metadata and
and the
the file
file specific
specific or
or default
metadata as
as specified
specified by
by the
the Py-ART
Py-ART configuration
configuration file
file will
will be
be used.
file_field_names :
: bool,
bool, optional
True to
to force
force the
the use
use of
of the
the field
field names
names from
from the
the file
file in
in which
case the
the `field_names`
`field_names` parameter
parameter is
is ignored.
ignored. False
False will
will use
use to
`field_names` parameter
parameter to
to rename
rename fields.
exclude_fields :
: list
list or
or None,
None, optional
List of
of fields
fields to
to exclude
exclude from
from the
the radar
radar object.
object. This
This is
is applied
after the
the `file_field_names`
`file_field_names` and
and `field_names`
`field_names` parameters.
delay_field_loading :
: bool
This option
option is
is not
not implemented
implemented in
in the
the function
function but
but included
included for
radar :
: Radar
Radar object.
filemetadata =
= FileMetadata('uf',
FileMetadata('uf', field_names,
field_names, additional_metadata,
file_field_names, exclude_fields)
ufile =
= UFFile(prepare_for_read(filename))
first_ray =
= ufile.rays[0]
dts =
= ufile.get_datetimes()
units =
= make_time_unit_str(min(dts))
time =
= filemetadata('time')
time['units'] =
= units
time['data'] =
= date2num(dts,
date2num(dts, units).astype('float32')
_range =
= filemetadata('range')
field_header =
= first_ray.field_headers[0]
ngates =
= field_header['nbins']
step =
= field_header['range_spacing_m']
start =
= (field_header['range_start_km']
(field_header['range_start_km'] *
* 1000.
1000. +
field_header['range_start_m'] +
+ step
step /
/ 2.)
_range['data'] =
= np.arange(ngates,
np.arange(ngates, dtype='float32')
dtype='float32') *
* step
step +
+ start
_range['meters_to_center_of_first_gate'] =
= start
_range['meters_between_gates'] =
= step
latitude =
= filemetadata('latitude')
longitude =
= filemetadata('longitude')
altitude =
= filemetadata('altitude')
lat, lon,
lon, height
height =
= first_ray.get_location()
latitude['data'] =
= np.array([lat],
np.array([lat], dtype='float64')
longitude['data'] =
= np.array([lon],
np.array([lon], dtype='float64')
altitude['data'] =
= np.array([height],
np.array([height], dtype='float64')
metadata =
= filemetadata('metadata')
metadata['original_container'] =
= 'UF'
metadata['site_name'] =
= first_ray.mandatory_header['site_name']
metadata['radar_name'] =
= first_ray.mandatory_header['radar_name']
sweep_start_ray_index =
= filemetadata('sweep_start_ray_index')
sweep_end_ray_index =
= filemetadata('sweep_end_ray_index')
sweep_start_ray_index['data'] =
= ufile.first_ray_in_sweep
sweep_end_ray_index['data'] =
= ufile.last_ray_in_sweep
sweep_number =
= filemetadata('sweep_number')
sweep_number['data'] =
= np.arange(ufile.nsweeps,
np.arange(ufile.nsweeps, dtype='int32')
scan_type =
= _UF_SWEEP_MODES[first_ray.mandatory_header['sweep_mode']]
sweep_mode =
= filemetadata('sweep_mode')
sweep_mode['data'] =
= np.array(
ufile.nsweeps *
* [_SWEEP_MODE_STR[scan_type]],
[_SWEEP_MODE_STR[scan_type]], dtype='S')
elevation =
= filemetadata('elevation')
elevation['data'] =
= ufile.get_elevations()
azimuth =
= filemetadata('azimuth')
azimuth['data'] =
= ufile.get_azimuths()
fixed_angle =
= filemetadata('fixed_angle')
fixed_angle['data'] =
= ufile.get_sweep_fixed_angles()
fields =
= {}
for uf_field_number,
uf_field_number, uf_field_dic
uf_field_dic in
in enumerate(first_ray.field_positions):
uf_field_name =
= uf_field_dic['data_type'].decode('ascii')
field_name =
= filemetadata.get_field_name(uf_field_name)
if field_name
field_name is
is None:
field_dic =
= filemetadata(field_name)
field_dic['data'] =
= ufile.get_field_data(uf_field_number)
field_dic['_FillValue'] =
= get_fillvalue()
fields[field_name] =
= field_dic
instrument_parameters =
= _get_instrument_parameters(ufile,
_get_instrument_parameters(ufile, filemetadata)
scan_rate =
= filemetadata('scan_rate')
scan_rate['data'] =
= ufile.get_sweep_rates()
return Radar(
time, _range,
_range, fields,
fields, metadata,
metadata, scan_type,
latitude, longitude,
longitude, altitude,
sweep_number, sweep_mode,
sweep_mode, fixed_angle,
fixed_angle, sweep_start_ray_index,
azimuth, elevation,
def _get_instrument_parameters(ufile,
_get_instrument_parameters(ufile, filemetadata):
""" Return
Return a
a dictionary
dictionary containing
containing instrument
instrument parameters.
parameters. """
pulse_width =
= filemetadata('pulse_width')
pulse_width['data'] =
= ufile.get_pulse_widths()
ufile.get_pulse_widths() /
/ _LIGHT_SPEED
_LIGHT_SPEED #
# m->sec
first_ray =
= ufile.rays[0]
field_header =
= first_ray.field_headers[0]
beam_width_h =
= field_header['beam_width_h']
field_header['beam_width_h'] /
/ 64.
beam_width_v =
= field_header['beam_width_v']
field_header['beam_width_v'] /
/ 64.
bandwidth =
= field_header['bandwidth']
field_header['bandwidth'] /
/ 16.
16. *
* 1.e6
wavelength_cm =
= field_header['wavelength_cm']
field_header['wavelength_cm'] /
/ 64.
if wavelength_cm
wavelength_cm ==
== 0:
warnings.warn('Invalid wavelength,
wavelength, frequency
frequency set
set to
to default
default value.')
wavelength_hz =
= 9999.0
wavelength_hz =
= _LIGHT_SPEED
_LIGHT_SPEED /
/ (wavelength_cm
(wavelength_cm /
/ 100.)
radar_beam_width_h =
= filemetadata('radar_beam_width_h')
radar_beam_width_h['data'] =
= np.array([beam_width_h],
np.array([beam_width_h], dtype='float32')
radar_beam_width_v =
= filemetadata('radar_beam_width_w')
radar_beam_width_v['data'] =
= np.array([beam_width_v],
np.array([beam_width_v], dtype='float32')
radar_receiver_bandwidth =
= filemetadata('radar_receiver_bandwidth')
radar_receiver_bandwidth['data'] =
= np.array([bandwidth],
np.array([bandwidth], dtype='float32')
polarization_mode =
= filemetadata('polarization_mode')
polarization_mode['data'] =
= ufile.get_sweep_polarizations()
frequency =
= filemetadata('frequency')
frequency['data'] =
= np.array([wavelength_hz],
np.array([wavelength_hz], dtype='float32')
prt =
= filemetadata('prt')
prt['data'] =
= ufile.get_prts()
ufile.get_prts() /
/ 1e6
1e6 #
# us->sec
instrument_parameters =
= {
'pulse_width': pulse_width,
'radar_beam_width_h': radar_beam_width_h,
'radar_beam_width_v': radar_beam_width_v,
'radar_receiver_bandwidth': radar_receiver_bandwidth,
'polarization_mode': polarization_mode,
'frequency': frequency,
'prt': prt,
nyquist_velocity =
= filemetadata('nyquist_velocity')
nyquist_velocity['data'] =
= ufile.get_nyquists()
if nyquist_velocity['data']
nyquist_velocity['data'] is
is not
not None:
instrument_parameters['nyquist_velocity'] =
= nyquist_velocity
return instrument_parameters
