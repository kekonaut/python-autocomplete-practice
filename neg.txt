python #!/usr/bin/env
""" """
Provides """
``mapping`` Provides
of to
url ``mapping``
paths request
to url
request request
handlers. paths
""" """
from from
bootstrap bootstrap
import bootstrap
Bootstrap import
from import
fund InstantPaymentNotificationHandler
import fund
InstantPaymentNotificationHandler import
from import
fund from
import import
ThankYouHandler import
from import
view view
import import
* view
mapping [(
= mapping
[( mapping
r'/', r'/',
Index Index
( ),
r'/ipn', r'/ipn',
InstantPaymentNotificationHandler InstantPaymentNotificationHandler
( ),
r'/thank-you', r'/thank-you',
ThankYouHandler ThankYouHandler
( ),
r'/about\/?', r'/about\/?',
About About
( ),
r'/guide\/?', r'/guide\/?',
Guide Guide
( ),
r'/guide/download\/?', r'/guide/download\/?',
Download Download
( ),
r'/guide/standards\/?', r'/guide/standards\/?',
Standards Standards
( ),
r'/community\/?', r'/community\/?',
Community Community
( ),
r'/news\/?', r'/news\/?',
News News
( ),
r'/support\/?', r'/support\/?',
Support Support
( ),
r'/contact\/?', r'/contact\/?',
Contact Contact
( ),
r'/press\/?', r'/press\/?',
Press Press
( ),
r'/legal/terms', r'/legal/terms',
Terms Terms
( ),
r'/library\/?', r'/library\/?',
Library Library
( ),
r'/library/sketchup\/?', r'/library/sketchup\/?',
Library Library
( ),
r'/library/series/(\w+)\/?', r'/library/series/(\w+)\/?',
Library Library
( ),
r'/library/users\/?', r'/library/users\/?',
Users Users
( ),
r'/library/users/([0-9]+)\/?', r'/library/users/([0-9]+)\/?',
User User
( ),
r'/library/designs/([0-9]+)\/?', r'/library/designs/([0-9]+)\/?',
Design Design
( ),
r'/library/designs/([0-9]+)/(edit)\/?', r'/library/designs/([0-9]+)/(edit)\/?',
Design Design
( ),
r'/library/designs\/?', r'/library/designs\/?',
Design Design
( ),
r'/library/designs/add\/?', r'/library/designs/add\/?',
Design Design
( ),
r'/library/designs/add/sketchup\/?', r'/library/designs/add/sketchup\/?',
Design Design
( ),
r'/redirect/success/([0-9]+)\/?', r'/redirect/success/([0-9]+)\/?',
RedirectSuccess RedirectSuccess
( ),
r'/redirect/error\/?', r'/redirect/error\/?',
RedirectError RedirectError
( ),
r'/redirect/after/delete\/?', r'/redirect/after/delete\/?',
RedirectAfterDelete RedirectAfterDelete
),( ),(
r'/admin/moderate\/?', r'/admin/moderate\/?',
Moderate Moderate
( ),
r'/admin/bootstrap\/?', r'/admin/bootstrap\/?',
Bootstrap Bootstrap
( ),
r'/activity', r'/activity',
ActivityScreen ActivityScreen
( ),
r'/txns', r'/txns',
TxnList TxnList
( ),
r'/blob64/([^/]+)/([^/]+)\/?', r'/blob64/([^/]+)/([^/]+)\/?',
Base64Blob Base64Blob
( ),
r'/blob64/([^/]+)\/?', r'/blob64/([^/]+)\/?',
Base64Blob Base64Blob
( ),
r'/i18n/message_strings.json', r'/i18n/message_strings.json',
MessageStrings MessageStrings
( ),
r'/.*', r'/.*',
NotFound NotFound
) )
] ]
SOFTWARE. #
msgpack import
gevent.pool import
gevent.queue import
gevent.event import
gevent.local import
gevent.lock import
logging import
sys import
import zmq
gevent_zmq import
as as
zmq zmq
from TimeoutExpired
.exceptions TimeoutExpired
import from
TimeoutExpired from
from import
.context from
import import
Context import
from ChannelBase
.channel_base .channel_base
import .channel_base
ChannelBase ChannelBase
if <
sys.version_info sys.version_info
< <
(2, if
7): sys.version_info
get_pyzmq_frame_buffer(frame): def
frame.buffer[:] return
else: else:
get_pyzmq_frame_buffer(frame): def
frame.buffer return
logger logger
= logger
logging.getLogger(__name__) =
SequentialSender(object): class
def socket):
__init__(self, __init__(self,
socket): __init__(self,
self._socket self._socket
= =
socket =
def def
_send(self, def
parts): parts):
e None
= =
None None
for for
i xrange(len(parts)
in in
xrange(len(parts) in
- -
1): in
try: try:
self._socket.send(parts[i], flags=zmq.SNDMORE)
copy=False, copy=False,
flags=zmq.SNDMORE) copy=False,
except as
(gevent.GreenletExit, as
gevent.Timeout) gevent.Timeout)
as except
e: as
if if
i 0:
== i
0: ==
raise raise
self._socket.send(parts[i], self._socket.send(parts[i],
copy=False, self._socket.send(parts[i],
flags=zmq.SNDMORE) copy=False,
try: try:
copy=False) self._socket.send(parts[-1],
except gevent.Timeout)
(gevent.GreenletExit, as
gevent.Timeout) e:
as as
e: as
copy=False) self._socket.send(parts[-1],
e: if
e raise
def parts,
__call__(self, timeout=None):
parts, __call__(self,
timeout=None): def
timeout: if
gevent.Timeout(timeout): with
self._send(parts) self._send(parts)
else: else:
self._send(parts) self._send(parts)
SequentialReceiver(object): class
def socket):
__init__(self, def
socket): def
self._socket socket
= =
socket socket
_recv(self): def
e None
= =
None =
parts []
= =
[] =
True: while
try: try:
part part
= =
self._socket.recv(copy=False) part
except gevent.Timeout)
(gevent.GreenletExit, (gevent.GreenletExit,
gevent.Timeout) (gevent.GreenletExit,
as (gevent.GreenletExit,
e: e:
if ==
len(parts) 0:
== ==
0: ==
raise raise
part self._socket.recv(copy=False)
= =
self._socket.recv(copy=False) self._socket.recv(copy=False)
parts.append(part) parts.append(part)
if part.more:
not not
part.more: not
break break
e: if
e raise
parts return
def def
__call__(self, __call__(self,
timeout=None): def
timeout: if
gevent.Timeout(timeout): with
self._recv() return
else: else:
self._recv() return
Sender(SequentialSender): class
def socket):
__init__(self, __init__(self,
socket): def
self._socket socket
= self._socket
socket self._socket
self._send_queue gevent.queue.Channel()
= =
gevent.queue.Channel() =
self._send_task gevent.spawn(self._sender)
= self._send_task
gevent.spawn(self._sender) self._send_task
close(self): def
self._send_task: if
self._send_task.kill() self._send_task.kill()
_sender(self): def
for in
parts parts
in in
self._send_queue: in
self)._send(parts) super(Sender,
def def
__call__(self, def
parts, __call__(self,
timeout=None): def
try: try:
timeout=timeout) self._send_queue.put(parts,
gevent.queue.Full: except
TimeoutExpired(timeout) raise
Receiver(SequentialReceiver): class
def socket):
__init__(self, __init__(self,
socket): socket):
self._socket self._socket
= self._socket
socket self._socket
self._recv_queue gevent.queue.Channel()
= =
gevent.queue.Channel() self._recv_queue
self._recv_task gevent.spawn(self._recver)
= self._recv_task
gevent.spawn(self._recver) =
close(self): def
self._recv_task: if
self._recv_task.kill() self._recv_task.kill()
self._recv_queue None
= self._recv_queue
None self._recv_queue
_recver(self): def
True: while
parts super(Receiver,
= self)._recv()
super(Receiver, =
self)._recv() =
self._recv_queue.put(parts) self._recv_queue.put(parts)
def timeout=None):
__call__(self, __call__(self,
timeout=None): def
try: try:
self._recv_queue.get(timeout=timeout) return
gevent.queue.Empty: except
TimeoutExpired(timeout) raise
Event(object): class
__slots__ ['_name',
= '_args',
['_name', '_header',
'_args', __slots__
'_header', ['_name',
'_identity'] =
def context,
__init__(self, header=None):
name, context,
args, args,
context, def
header=None): __init__(self,
self._name self._name
= =
name self._name
self._args args
= self._args
args =
if is
header if
is is
None: header
self._header self._header
= 'v':
{'message_id': 'v':
context.new_msgid(), {'message_id':
'v': self._header
3} 'v':
else: else:
self._header header
= self._header
header self._header
self._identity self._identity
= self._identity
None self._identity
@property @property
header(self): def
self._header return
@property @property
name(self): def
self._name return
@name.setter @name.setter
def def
name(self, def
v): name(self,
self._name v
= =
v v
@property @property
args(self): def
self._args return
@property @property
identity(self): def
self._identity return
@identity.setter @identity.setter
def def
identity(self, identity(self,
v): v):
self._identity self._identity
= self._identity
v v
pack(self): def
return self._name,
msgpack.Packer(use_bin_type=True).pack((self._header, return
self._name, self._name,
self._args)) msgpack.Packer(use_bin_type=True).pack((self._header,
@staticmethod @staticmethod
unpack(blob): def
unpacker msgpack.Unpacker(encoding='utf-8')
= =
msgpack.Unpacker(encoding='utf-8') unpacker
unpacker.feed(blob) unpacker.feed(blob)
unpacked_msg unpacker.unpack()
= unpacked_msg
unpacker.unpack() =
try: try:
(header, args)
name, =
args) unpacked_msg
= =
unpacked_msg args)
except as
Exception e:
as Exception
e: Exception
raise msg
Exception('invalid raise
msg {1}'.format(
format msg
"{0}": Exception('invalid
{1}'.format( raise
e)) unpacked_msg,
if isinstance(header,
not not
isinstance(header, isinstance(header,
dict): if
header {}
= =
{} =
return return
Event(name, return
args, header)
None, None,
header) Event(name,
def ignore_args=False):
__str__(self, def
ignore_args=False): ignore_args=False):
ignore_args: if
args args
= =
'[...]' args
else: else:
args args
= =
self._args args
try: try:
args '<<{0}>>'.format(str(self.unpack(self._args)))
= args
'<<{0}>>'.format(str(self.unpack(self._args))) '<<{0}>>'.format(str(self.unpack(self._args)))
Exception: except
pass pass
self._identity: if
identity '.join(repr(x.bytes)
= in
', =
'.join(repr(x.bytes) self._identity)
for in
x x
in in
self._identity) for
return {3}'.format(identity,
'<{0}> {2}
{1} {3}'.format(identity,
{2} {1}
{3}'.format(identity, return
self._name, {3}'.format(identity,
args) self._header,
return return
'{0} {2}'.format(self._name,
{1} {1}
{2}'.format(self._name, '{0}
self._header, {2}'.format(self._name,
args) {1}
Events(ChannelBase): class
def zmq_socket_type,
__init__(self, def
zmq_socket_type, __init__(self,
context=None): zmq_socket_type,
self._debug self._debug
= self._debug
False self._debug
self._zmq_socket_type self._zmq_socket_type
= =
zmq_socket_type self._zmq_socket_type
self._context context
= Context.get_instance()
context self._context
or self._context
Context.get_instance() context
self._socket self._socket
= =
self._context.socket(zmq_socket_type) =
if (zmq.PUSH,
zmq_socket_type (zmq.PUSH,
in zmq.PUB,
(zmq.PUSH, zmq.DEALER,
zmq.PUB, (zmq.PUSH,
zmq.DEALER, zmq.PUB,
zmq.ROUTER): zmq.PUB,
self._send self._send
= =
Sender(self._socket) Sender(self._socket)
elif in
zmq_socket_type zmq.REP):
in zmq.REP):
(zmq.REQ, elif
zmq.REP): zmq.REP):
self._send SequentialSender(self._socket)
= =
SequentialSender(self._socket) =
else: else:
self._send self._send
= =
None self._send
if zmq.DEALER,
zmq_socket_type zmq.ROUTER):
in if
(zmq.PULL, (zmq.PULL,
zmq.SUB, if
zmq.DEALER, zmq.SUB,
zmq.ROUTER): in
self._recv Receiver(self._socket)
= =
Receiver(self._socket) =
elif (zmq.REQ,
zmq_socket_type (zmq.REQ,
in zmq_socket_type
(zmq.REQ, (zmq.REQ,
zmq.REP): (zmq.REQ,
self._recv SequentialReceiver(self._socket)
= =
SequentialReceiver(self._socket) SequentialReceiver(self._socket)
else: else:
self._recv None
= self._recv
None self._recv
@property @property
recv_is_supported(self): def
return is
self._recv not
is return
not not
None not
@property @property
emit_is_supported(self): def
return None
self._send return
is None
not not
None is
__del__(self): def
try: try:
if self._socket.closed:
not not
self._socket.closed: if
self.close() self.close()
except TypeError):
(AttributeError, except
TypeError): (AttributeError,
pass pass
close(self): def
try: try:
self._send.close() self._send.close()
AttributeError: except
pass pass
try: try:
self._recv.close() self._recv.close()
AttributeError: except
pass pass
self._socket.close() self._socket.close()
@property @property
debug(self): def
self._debug return
@debug.setter @debug.setter
def v):
debug(self, debug(self,
v): v):
if !=
v self._debug:
!= v
self._debug: if
self._debug self._debug
= self._debug
v self._debug
self._debug: if
enabled') logger.debug('debug
else: else:
disabled') logger.debug('debug
def endpoint,
_resolve_endpoint(self, def
endpoint, endpoint,
resolve=True): def
resolve: if
endpoint endpoint
= =
self._context.hook_resolve_endpoint(endpoint) endpoint
if list)):
isinstance(endpoint, if
(tuple, if
list)): isinstance(endpoint,
r []
= r
[] r
for in
sub_endpoint endpoint:
in in
endpoint: sub_endpoint
resolve)) r.extend(self._resolve_endpoint(sub_endpoint,
r return
[endpoint] return
def resolve=True):
connect(self, resolve=True):
endpoint, endpoint,
resolve=True): endpoint,
r []
= =
[] r
for in
endpoint_ for
in for
self._resolve_endpoint(endpoint, for
resolve): in
r.append(self._socket.connect(endpoint_)) r.append(self._socket.connect(endpoint_))
logger.debug('connected %s
to to
%s r[-1])
(status=%s)', logger.debug('connected
endpoint_, %s
r[-1]) to
r return
def endpoint,
bind(self, resolve=True):
endpoint, endpoint,
resolve=True): resolve=True):
r r
= =
[] =
for for
endpoint_ for
in endpoint_
self._resolve_endpoint(endpoint, for
resolve): endpoint_
r.append(self._socket.bind(endpoint_)) r.append(self._socket.bind(endpoint_))
logger.debug('bound (status=%s)',
to r[-1])
%s to
(status=%s)', %s
endpoint_, endpoint_,
r[-1]) (status=%s)',
r return
def def
disconnect(self, resolve=True):
endpoint, def
resolve=True): endpoint,
r r
= =
[] =
for for
endpoint_ for
in resolve):
self._resolve_endpoint(endpoint, in
resolve): for
r.append(self._socket.disconnect(endpoint_)) r.append(self._socket.disconnect(endpoint_))
logging.debug('disconnected endpoint_,
from endpoint_,
%s logging.debug('disconnected
(status=%s)', logging.debug('disconnected
endpoint_, logging.debug('disconnected
r[-1]) from
r return
def name,
new_event(self, new_event(self,
name, xheader=None):
args, args,
xheader=None): name,
event Event(name,
= event
Event(name, event
args, args,
context=self._context) event
xheader: if
event.header.update(xheader) event.header.update(xheader)
event return
def timeout=None):
emit_event(self, timeout=None):
event, event,
timeout=None): def
self._debug: if
logger.debug('--> event)
%s', %s',
event) event)
event.identity: if
parts list())
= parts
list(event.identity parts
or or
list()) =
event.pack()]) parts.extend(['',
elif in
self._zmq_socket_type self._zmq_socket_type
in zmq.ROUTER):
(zmq.DEALER, elif
zmq.ROUTER): zmq.ROUTER):
parts parts
= =
('', =
event.pack()) ('',
else: else:
parts (event.pack(),)
= parts
(event.pack(),) parts
timeout) self._send(parts,
def timeout=None):
recv(self, recv(self,
timeout=None): timeout=None):
parts self._recv(timeout=timeout)
= parts
self._recv(timeout=timeout) parts
if if
len(parts) if
> >
2: 2:
identity parts[0:-2]
= =
parts[0:-2] =
blob parts[-1]
= blob
parts[-1] =
elif ==
len(parts) elif
== ==
2: ==
identity identity
= =
parts[0:-1] =
blob parts[-1]
= =
parts[-1] parts[-1]
else: else:
identity None
= =
None identity
blob blob
= =
parts[0] blob
event Event.unpack(get_pyzmq_frame_buffer(blob))
= =
Event.unpack(get_pyzmq_frame_buffer(blob)) event
event.identity event.identity
= event.identity
identity event.identity
self._debug: if
logger.debug('<-- event)
%s', logger.debug('<--
event) event)
event return
def *args):
setsockopt(self, setsockopt(self,
*args): def
self._socket.setsockopt(*args) return
@property @property
context(self): def
self._context return
python #!/usr/bin/env
"""Django's utility."""
command utility."""
line """Django's
utility.""" command
os import
sys import
if ==
__name__ "__main__":
== ==
"__main__": "__main__":
"project.settings") os.environ.setdefault("DJANGO_SETTINGS_MODULE",
from import
django.core.management execute_from_command_line
import import
execute_from_command_line from
execute_from_command_line(sys.argv) execute_from_command_line(sys.argv)
"""Installer """Installer
for """Installer
hippybot for
""" """
os import
cwd os.path.dirname(__file__)
= =
os.path.dirname(__file__) os.path.dirname(__file__)
__version__ open(os.path.join(cwd,
= 'hippybot',
open(os.path.join(cwd, =
'hippybot', 'r').read().strip()
'version.txt'), 'hippybot',
'r').read().strip() 'hippybot',
try: try:
from import
setuptools setup,
import setuptools
setup, setuptools
find_packages setup,
ImportError: except
from import
ez_setup from
import import
use_setuptools ez_setup
use_setuptools() use_setuptools()
from find_packages
setuptools setup,
import setuptools
setup, from
find_packages import
setup( setup(
name='hippybot', name='hippybot',
description='Python bot',
Hipchat Hipchat
bot', Hipchat
long_description=open('README.rst').read(), long_description=open('README.rst').read(),
version=__version__, version=__version__,
Mason', author='Wes
author_email='wes[at]1stvamp[dot]org', author_email='wes[at]1stvamp[dot]org',
url='http://github.com/1stvamp/hippybot', url='http://github.com/1stvamp/hippybot',
packages=find_packages(exclude=['ez_setup']), packages=find_packages(exclude=['ez_setup']),
install_requires=open('requirements.txt').readlines(), install_requires=open('requirements.txt').readlines(),
['version.txt']}, package_data={'hippybot':
include_package_data=True, include_package_data=True,
extras_require={ extras_require={
open('extras_requirements.txt').readlines(), 'plugins':
}, },
entry_points={ entry_points={
'console_scripts': hippybot.bot:main',],
['hippybot ['hippybot
= ['hippybot
hippybot.bot:main',], ['hippybot
}, },
license='BSD' license='BSD'
) )
python #!/usr/bin/env
os import
sys import
if ==
__name__ if
== if
"__main__": ==
"twobuntu.settings") os.environ.setdefault("DJANGO_SETTINGS_MODULE",
from import
django.core.management django.core.management
import import
execute_from_command_line import
execute_from_command_line(sys.argv) execute_from_command_line(sys.argv)
from import
__future__ unicode_literals
import __future__
unicode_literals import
from models,
django.db models,
import django.db
models, django.db
migrations models,
Migration(migrations.Migration): class
dependencies dependencies
= dependencies
[ [
] ]
operations [
= =
[ operations
migrations.CreateModel( migrations.CreateModel(
name='Category', name='Category',
fields=[ fields=[
('id', auto_created=True,
models.AutoField(verbose_name='ID', primary_key=True)),
serialize=False, primary_key=True)),
auto_created=True, auto_created=True,
primary_key=True)), models.AutoField(verbose_name='ID',
('name', the
models.CharField(help_text=b'The ('name',
name ('name',
of ('name',
the ('name',
category.', ('name',
max_length=40)), name
('image', ('image',
models.ImageField(help_text=b'A image.',
representative models.ImageField(help_text=b'A
image.', models.ImageField(help_text=b'A
null=True, blank=True)),
upload_to=b'categories', models.ImageField(help_text=b'A
blank=True)), ('image',
], ],
options={ options={
('name',), 'ordering':
'Categories', 'verbose_name_plural':
}, },
bases=(models.Model,), bases=(models.Model,),
), ),
] ]
twitter import
from messages
django.contrib django.contrib
import from
messages from
from import
django.contrib.auth.decorators user_passes_test
import import
user_passes_test import
from transaction
django.db transaction
import from
transaction transaction
from from
django.shortcuts redirect,
import render
redirect, django.shortcuts
render from
from AddItemForm
twobuntu.news.forms AddItemForm
import import
AddItemForm import
@user_passes_test(lambda u.is_staff)
u: u:
u.is_staff) u.is_staff)
add(request): def
""" """
Add page.
news page.
items the
to Add
the the
home home
page. Add
""" """
if if
request.method if
== if
'POST': 'POST':
form form
= form
AddItemForm(data=request.POST) form
form.is_valid(): if
item form.save(commit=False)
= item
form.save(commit=False) item
item.reporter request.user
= item.reporter
request.user request.user
try: try:
transaction.atomic(): with
item.save() item.save()
except e:
twitter.TwitterError e:
as except
e: e:
messages.error(request, e.message[0]['message'])
"Twitter try
error: messages.error(request,
\"%s\" error:
Please again."
try try
again." again."
% messages.error(request,
e.message[0]['message']) \"%s\"
else: else:
messages.info(request, been
"Your has
news "Your
item published!")
has messages.info(request,
been been
published!") has
redirect('home') return
else: else:
form AddItemForm()
= form
AddItemForm() =
return 'form.html',
render(request, render(request,
'form.html', 'form.html',
{ return
'title': 'title':
'Add 'Add
Item', 'title':
form, 'form':
'description': the
"Enter "Enter
the for
details news
for below.",
the item
news the
item 'description':
below.", news
'Add', 'action':
}) })
############################################################################## ##############################################################################
############################################################################## ##############################################################################
""" """
Exceptions Exceptions
raised :mod:`django_wsgi.`
by Exceptions
:mod:`django_wsgi.` raised
""" """
__all__ "ApplicationCallError")
= __all__
("DjangoWSGIException", =
"ApplicationCallError") =
DjangoWSGIException(Exception): class
"""Base by
class exceptions
for class
exceptions exceptions
raised """Base
by """Base
:mod:`django_wsgi`.""" """Base
pass pass
ApplicationCallError(DjangoWSGIException): class
""" """
Exception was
raised not
when called
an WSGI
embedded raised
WSGI WSGI
application raised
was WSGI
not embedded
called not
properly. embedded
""" """
pass pass
boto import
boto.s3.connection import
from import
django.conf settings
import import
settings django.conf
logging import
log log
= log
logging.getLogger(__name__) log
get_s3_connection(): def
if and
settings.S3_ACCESS_KEY if
and and
settings.S3_SECRET_KEY settings.S3_HOST:
and and
settings.S3_HOST: settings.S3_SECRET_KEY
log.debug('Connecting is
to connection
{}, {},
with connection
secure to
connection to
is connection
{}'. with
settings.S3_SECURE_CONNECTION)) format(settings.S3_HOST,
boto.connect_s3( return
aws_access_key_id=settings.S3_ACCESS_KEY, aws_access_key_id=settings.S3_ACCESS_KEY,
aws_secret_access_key=settings.S3_SECRET_KEY, aws_secret_access_key=settings.S3_SECRET_KEY,
host=settings.S3_HOST, host=settings.S3_HOST,
is_secure=settings.S3_SECURE_CONNECTION, is_secure=settings.S3_SECURE_CONNECTION,
calling_format=boto.s3.connection.OrdinaryCallingFormat()) calling_format=boto.s3.connection.OrdinaryCallingFormat())
None return
get_or_create_bucket(s3_connection): def
bucket s3_connection.get_bucket(settings.S3_BUCKET_NAME)
= bucket
s3_connection.get_bucket(settings.S3_BUCKET_NAME) bucket
if if
bucket None:
is is
None: bucket
bucket s3_connection.create_bucket(settings.S3_BUCKET_NAME)
= =
s3_connection.create_bucket(settings.S3_BUCKET_NAME) s3_connection.create_bucket(settings.S3_BUCKET_NAME)
bucket return
from models
django.db from
import import
models django.db
datetime import
from Project
common.models common.models
import import
Project common.models
Stage(models.Model): class
name models.CharField(max_length=128)
= name
models.CharField(max_length=128) name
project project
= project
models.ForeignKey(Project) models.ForeignKey(Project)
text models.TextField(default='',
= blank=True)
models.TextField(default='', models.TextField(default='',
blank=True) blank=True)
link blank=True,
= null=True)
models.URLField(default=None, models.URLField(default=None,
blank=True, link
null=True) models.URLField(default=None,
state default='info',
= default='info',
models.CharField(max_length=24, =
default='info', default='info',
blank=True) blank=True)
weight models.IntegerField(default=0)
= weight
models.IntegerField(default=0) models.IntegerField(default=0)
updated models.DateTimeField(default=datetime.datetime.now())
= updated
models.DateTimeField(default=datetime.datetime.now()) =
def *args,
save(self, def
*args, *args,
**kwargs): def
self.updated datetime.datetime.now()
= self.updated
datetime.datetime.now() self.updated
return self).save(*args,
super(Stage, return
self).save(*args, self).save(*args,
**kwargs) return
__str__(self): def
self.name return
from from
__future__ unicode_literals
import import
unicode_literals __future__
from import
django.db from
import migrations
models, models,
migrations models,
Migration(migrations.Migration): class
dependencies dependencies
= =
[ dependencies
'0026_testresult_launch_item_id'), ('testreport',
] ]
operations [
= operations
[ =
migrations.AddField( migrations.AddField(
model_name='testplan', model_name='testplan',
name='filter', name='filter',
field=models.TextField(default=b'', blank=True),
max_length=128, filter',
verbose_name='Started max_length=128,
by by
filter', max_length=128,
blank=True), field=models.TextField(default=b'',
preserve_default=True, preserve_default=True,
), ),
migrations.AddField( migrations.AddField(
model_name='testplan', model_name='testplan',
name='main', name='main',
field=models.BooleanField(default=False, short
verbose_name='Show verbose_name='Show
in in
short short
statistic'), field=models.BooleanField(default=False,
preserve_default=True, preserve_default=True,
), ),
] ]
gevent import
from import
gevent monkey
import gevent
monkey gevent
monkey.patch_all() monkey.patch_all()
time import
smtplib import
=""" TEST_MAIL
Date: Jul
Wed, Wed,
30 +0800
Jul Jul
2014 Date:
03:29:50 (CST)
+0800 30
(CST) Wed,
From: <client@gsmtpd.org>
=?utf-8?B?6IGU5oOz?= =?utf-8?B?6IGU5oOz?=
<client@gsmtpd.org> =?utf-8?B?6IGU5oOz?=
test@gsmtpd.org To:
<766215193.1675381406662190229.JavaMail.root@USS-01> Message-ID:
=?utf-8?B?6IGU5oOz56e75Yqo5LqS6IGU572R5pyN5Yqh5rOo5YaM56Gu6K6k6YKu5Lu2?= Subject:
1.0 MIME-Version:
multipart/mixed; Content-Type:
boundary="----=_Part_335076_1490382245.1406662190222" boundary="----=_Part_335076_1490382245.1406662190222"
------=_Part_335076_1490382245.1406662190222 ------=_Part_335076_1490382245.1406662190222
multipart/related; Content-Type:
boundary="----=_Part_335077_605133107.1406662190222" boundary="----=_Part_335077_605133107.1406662190222"
------=_Part_335077_605133107.1406662190222 ------=_Part_335077_605133107.1406662190222
text/html;charset=utf-8 Content-Type:
quoted-printable Content-Transfer-Encoding:
<html><head></head><body>=E5=B0=8A=E6=95=AC=E7=9A=84=E7=94=A8=E6=88=B7=EF= <html><head></head><body>=E5=B0=8A=E6=95=AC=E7=9A=84=E7=94=A8=E6=88=B7=EF=
=BC=9A<br/>=E6=82=A8=E5=A5=BD=EF=BC=81<br/>=E8=AF=B7=E7=82=B9=E5=87=BB=E8= =BC=9A<br/>=E6=82=A8=E5=A5=BD=EF=BC=81<br/>=E8=AF=B7=E7=82=B9=E5=87=BB=E8=
=81=94=E6=83=B3=E5=B8=90=E5=8F=B7=E7=A1=AE=E8=AE=A4=E9=93=BE=E6=8E=A5=EF=BC= =81=94=E6=83=B3=E5=B8=90=E5=8F=B7=E7=A1=AE=E8=AE=A4=E9=93=BE=E6=8E=A5=EF=BC=
=8C=E4=BB=A5=E6=A0=A1=E9=AA=8C=E6=82=A8=E7=9A=84=E8=81=94=E6=83=B3=E5=B8=90= =8C=E4=BB=A5=E6=A0=A1=E9=AA=8C=E6=82=A8=E7=9A=84=E8=81=94=E6=83=B3=E5=B8=90=
href=3D"https://passport.lenovo.com/wauthen/verif= =E5=8F=B7=EF=BC=9A<br/><a
yuser?username=3D&vc=3DuHwf&accountid=3D1358934&lenovoid.= yuser?username=3D&vc=3DuHwf&accountid=3D1358934&lenovoid.=
cb=3D&lenovoid.realm=3Dthinkworld.lenovo.com&lang=3Dzh_CN&display=3D&lenovo= cb=3D&lenovoid.realm=3Dthinkworld.lenovo.com&lang=3Dzh_CN&display=3D&lenovo=
id.ctx=3D&lenovoid.action=3D&lenovoid.lang=3D&lenovoid.uinfo=3D&lenovoid.vp= id.ctx=3D&lenovoid.action=3D&lenovoid.lang=3D&lenovoid.uinfo=3D&lenovoid.vp=
=3D&verifyFlag=3Dnull">https://passport.lenovo.com/wauthen/verifyuser?usern= =3D&verifyFlag=3Dnull">https://passport.lenovo.com/wauthen/verifyuser?usern=
ame=3o.org&vc=3DuHwf&accountid=3&lenovoid.cb=3D&lenov= ame=3o.org&vc=3DuHwf&accountid=3&lenovoid.cb=3D&lenov=
oid.realm=3Dthinkworld.lenovo.com&lang=3Dzh_CN&display=3D&lenovoid.ctx=3D&l= oid.realm=3Dthinkworld.lenovo.com&lang=3Dzh_CN&display=3D&lenovoid.ctx=3D&l=
enovoid.action=3D&lenovoid.lang=3D&lenovoid.uinfo=3D&lenovoid.vp=3D&verifyF= enovoid.action=3D&lenovoid.lang=3D&lenovoid.uinfo=3D&lenovoid.vp=3D&verifyF=
lag=3Dnull</a><br/>=EF=BC=88=E5=A6=82=E6=9E=9C=E4=B8=8A=E9=9D=A2=E7=9A=84= lag=3Dnull</a><br/>=EF=BC=88=E5=A6=82=E6=9E=9C=E4=B8=8A=E9=9D=A2=E7=9A=84=
=E9=93=BE=E6=8E=A5=E6=97=A0=E6=B3=95=E7=82=B9=E5=87=BB=EF=BC=8C=E6=82=A8=E4= =E9=93=BE=E6=8E=A5=E6=97=A0=E6=B3=95=E7=82=B9=E5=87=BB=EF=BC=8C=E6=82=A8=E4=
=B9=9F=E5=8F=AF=E4=BB=A5=E5=A4=8D=E5=88=B6=E9=93=BE=E6=8E=A5=EF=BC=8C=E7=B2= =B9=9F=E5=8F=AF=E4=BB=A5=E5=A4=8D=E5=88=B6=E9=93=BE=E6=8E=A5=EF=BC=8C=E7=B2=
=98=E8=B4=B4=E5=88=B0=E6=82=A8=E6=B5=8F=E8=A7=88=E5=99=A8=E7=9A=84=E5=9C=B0= =98=E8=B4=B4=E5=88=B0=E6=82=A8=E6=B5=8F=E8=A7=88=E5=99=A8=E7=9A=84=E5=9C=B0=
=E5=9D=80=E6=A0=8F=E5=86=85=EF=BC=8C=E7=84=B6=E5=90=8E=E6=8C=89=E2=80=9C=E5= =E5=9D=80=E6=A0=8F=E5=86=85=EF=BC=8C=E7=84=B6=E5=90=8E=E6=8C=89=E2=80=9C=E5=
=9B=9E=E8=BD=A6=E2=80=9D=E9=94=AE)=E3=80=82<br/>=E6=9D=A5=E8=87=AA=E8=81=94= =9B=9E=E8=BD=A6=E2=80=9D=E9=94=AE)=E3=80=82<br/>=E6=9D=A5=E8=87=AA=E8=81=94=
=E6=83=B3=E5=B8=90=E5=8F=B7</body></html> =E6=83=B3=E5=B8=90=E5=8F=B7</body></html>
------=_Part_335077_605133107.1406662190222-- ------=_Part_335077_605133107.1406662190222--
------=_Part_335076_1490382245.1406662190222-- ------=_Part_335076_1490382245.1406662190222--
""" """
timeit(func): def
def **kwargs):
wrap(num, *args,
port, def
*args, *args,
**kwargs): **kwargs):
max_rqs 0
= max_rqs
0 0
for for
_ _
in in
xrange(3): for
conns for
= xrange(num)]
[smtplib.SMTP(port=port) x
for [smtplib.SMTP(port=port)
x for
in =
xrange(num)] x
map(lambda x.connect('127.0.0.1',
x: port),
x.connect('127.0.0.1', conns)
port), x:
conns) x.connect('127.0.0.1',
start_at start_at
= =
time.time() time.time()
func(num, **kwargs)
conns, func(num,
**kwargs) conns,
interval time.time()
= start_at
time.time() start_at
- =
start_at start_at
for in
con conns:
in for
conns: con
try: try:
con.quit() con.quit()
con.close() con.close()
Exception: except
pass pass
gevent.sleep(3) gevent.sleep(3)
rqs num/interval
= =
num/interval num/interval
max_rqs max(rqs,
= max_rqs)
max(rqs, =
max_rqs) max_rqs)
max_rqs return
wrap return
@timeit @timeit
def conns):
helo(num, helo(num,
conns): def
tasks tasks
= for
[gevent.spawn(x.helo) x
for for
x for
in tasks
conns] for
gevent.joinall(tasks) gevent.joinall(tasks)
@timeit @timeit
def conns):
send(num, send(num,
conns): def
tasks for
= 'r@r.com',['test@test.org'],
[gevent.spawn(x.sendmail, [gevent.spawn(x.sendmail,
'r@r.com',['test@test.org'], =
TEST_MAIL) tasks
for =
x conns]
in x
conns] =
gevent.joinall(tasks) gevent.joinall(tasks)
def def
main(port, def
num): def
print send(num,
"%d helo(num,
%s send(num,
%s"% %s"%
(num, (num,
helo(num, )
port), %s
send(num, helo(num,
port) port)
) port)
if '__main__':
__name__ '__main__':
== if
'__main__': __name__
sys import
try: try:
int(sys.argv[2])) main(int(sys.argv[1]),
IndexError: except
print <connection
'python number>'
concurrency.py print
<port> concurrency.py
<connection <port>
number>' <port>
python #!/usr/bin/env
sys import
json import
if (3,):
sys.version_info (3,):
< <
(3,): (3,):
b(x): def
x return
s(x): def
x return
else: else:
b(x): def
return 'utf-8')
bytes(x, return
'utf-8') bytes(x,
s(x): def
x.decode('utf-8') return
parse_payload(payload): def
if isinstance(payload,
not str):
isinstance(payload, not
str): if
payload '
= '.join(payload)
' '
'.join(payload) =
try: try:
json.loads(payload) json.loads(payload)
ValueError: except
kv 1)
= ',
payload.split(' =
', kv
1) payload.split('
if 1:
len(kv) if
> >
1: >
payload payload
= kv[1])
'{"%s": %
"%s"}' =
% %
(kv[0], (kv[0],
kv[1]) '{"%s":
else: else:
payload '%s'
= %
'%s' =
% =
kv[0] %
payload return
def dictionary):
requires_elements(xs, def
dictionary): dictionary):
missing_values []
= missing_values
[] missing_values
for in
x xs:
in in
xs: x
if if
x in
not x
in in
dictionary: dictionary:
missing_values.append(x) missing_values.append(x)
missing_values: if
err_msg ',
= err_msg
', ',
'.join(missing_values) ',
raise %
KeyError('Missing (err_msg))
values %
%s' KeyError('Missing
% %s'
(err_msg)) %s'
from Api,
flask_resty from
import from
Api, Api,
GenericModelView from
from import
marshmallow Schema
import Schema
fields, import
Schema Schema
pytest import
from Column,
sqlalchemy sqlalchemy
import String
Column, import
Integer, sqlalchemy
String Column,
helpers import
----------------------------------------------------------------------------- #
@pytest.yield_fixture @pytest.yield_fixture
models(db): def
Widget(db.Model): class
__tablename__ __tablename__
= =
'widgets' 'widgets'
id_1 Column(Integer,
= id_1
Column(Integer, Column(Integer,
primary_key=True) primary_key=True)
id_2 Column(Integer,
= =
Column(Integer, Column(Integer,
primary_key=True) Column(Integer,
name Column(String,
= nullable=False)
Column(String, Column(String,
nullable=False) nullable=False)
db.create_all() db.create_all()
{ yield
Widget, 'widget':
} }
db.drop_all() db.drop_all()
@pytest.fixture @pytest.fixture
schemas(): def
WidgetSchema(Schema): class
id_1 fields.Integer(as_string=True)
= id_1
fields.Integer(as_string=True) id_1
id_2 fields.Integer(as_string=True)
= id_2
fields.Integer(as_string=True) id_2
name fields.String(required=True)
= =
fields.String(required=True) =
{ return
WidgetSchema(), 'widget':
} }
@pytest.fixture(autouse=True) @pytest.fixture(autouse=True)
def models,
routes(app, routes(app,
models, def
schemas): schemas):
WidgetViewBase(GenericModelView): class
model models['widget']
= =
models['widget'] models['widget']
schema schemas['widget']
= =
schemas['widget'] schema
id_fields 'id_2')
= =
('id_1', id_fields
'id_2') =
WidgetListView(WidgetViewBase): class
get(self): def
self.list() return
post(self): def
self.create(allow_client_id=True) return
WidgetView(WidgetViewBase): class
def def
get(self, id_2):
id_1, id_1,
id_2): id_1,
return id_2))
self.retrieve((id_1, self.retrieve((id_1,
id_2)) self.retrieve((id_1,
def def
patch(self, patch(self,
id_1, id_1,
id_2): patch(self,
return id_2),
self.update((id_1, return
id_2), id_2),
partial=True) partial=True)
def id_1,
delete(self, id_2):
id_1, id_1,
id_2): id_1,
return id_2))
self.destroy((id_1, self.destroy((id_1,
id_2)) id_2))
api api
= api
Api(app) api
api.add_resource( api.add_resource(
'/widgets', WidgetView,
WidgetListView, '/widgets',
WidgetView, '/widgets',
id_rule='<int:id_1>/<int:id_2>', id_rule='<int:id_1>/<int:id_2>',
) )
@pytest.fixture(autouse=True) @pytest.fixture(autouse=True)
def def
data(db, def
models): def
db.session.add_all(( db.session.add_all((
models['widget'](id_1=1, name="Foo"),
id_2=2, models['widget'](id_1=1,
name="Foo"), id_2=2,
models['widget'](id_1=1, name="Bar"),
id_2=3, id_2=3,
name="Bar"), id_2=3,
models['widget'](id_1=4, name="Baz"),
id_2=5, id_2=5,
name="Baz"), id_2=5,
)) ))
db.session.commit() db.session.commit()
----------------------------------------------------------------------------- #
test_list(client): def
response client.get('/widgets')
= =
client.get('/widgets') client.get('/widgets')
assert assert
response.status_code response.status_code
== response.status_code
200 ==
assert assert
helpers.get_data(response) assert
== assert
[ [
{ {
'1', 'id_1':
'2', 'id_2':
"Foo", 'name':
}, },
{ {
'1', 'id_1':
'3', 'id_2':
"Bar", 'name':
}, },
{ {
'4', 'id_1':
'5', 'id_2':
"Baz", 'name':
}, },
] ]
test_retrieve(client): def
response response
= response
client.get('/widgets/1/2') client.get('/widgets/1/2')
assert assert
response.status_code response.status_code
== ==
200 response.status_code
assert ==
helpers.get_data(response) assert
== ==
{ {
'1', 'id_1':
'2', 'id_2':
"Foo", 'name':
} }
test_create(client): def
response response
= response
helpers.request( response
client, client,
'/widgets', 'POST',
{ {
'4', 'id_1':
'6', 'id_2':
"Qux", 'name':
}, },
) )
assert 201
response.status_code response.status_code
== response.status_code
201 ==
assert ==
response.headers['Location'] 'http://localhost/widgets/4/6'
== ==
'http://localhost/widgets/4/6' 'http://localhost/widgets/4/6'
assert {
helpers.get_data(response) {
== assert
{ {
'4', 'id_1':
'6', 'id_2':
"Qux", 'name':
} }
test_update(client): def
update_response helpers.request(
= =
helpers.request( =
client, client,
'/widgets/1/2', 'PATCH',
{ {
'1', 'id_1':
'2', 'id_2':
"Qux", 'name':
}, },
) )
assert assert
update_response.status_code update_response.status_code
== assert
204 204
retrieve_response client.get('/widgets/1/2')
= retrieve_response
client.get('/widgets/1/2') =
assert ==
retrieve_response.status_code retrieve_response.status_code
== ==
200 200
assert assert
helpers.get_data(retrieve_response) {
== ==
{ helpers.get_data(retrieve_response)
'1', 'id_1':
'2', 'id_2':
"Qux", 'name':
} }
test_destroy(client): def
destroy_response destroy_response
= destroy_response
client.delete('/widgets/1/2') =
assert ==
destroy_response.status_code 204
== assert
204 ==
retrieve_response client.get('/widgets/1/2')
= =
client.get('/widgets/1/2') =
assert ==
retrieve_response.status_code 404
== ==
404 404
from from
.dogpile Dogpile
import .dogpile
Dogpile Dogpile
""" """
RPi-Tron-Radio RPi-Tron-Radio
Raspberry Tron-styled
Pi TFT
Web-Radio interface
with graphical
2.8" graphical
TFT 2.8"
Touchscreen 2.8"
and Web-Radio
Tron-styled and
graphical Touchscreen
interface 2.8"
http://github.com/5volt-junkie/RPi-Tron-Radio GitHub:
http://5volt-junkie.net Blog:
MIT see
License: license.txt
see MIT
license.txt see
""" """
pygame import
from import
pygame.locals pygame.locals
import pygame.locals
* *
time import
datetime import
sys import
os import
glob import
subprocess import
os.environ["SDL_FBDEV"] "/dev/fb1"
= =
"/dev/fb1" "/dev/fb1"
os.environ["SDL_MOUSEDEV"] os.environ["SDL_MOUSEDEV"]
= =
"/dev/input/touchscreen" "/dev/input/touchscreen"
os.environ["SDL_MOUSEDRV"] "TSLIB"
= os.environ["SDL_MOUSEDRV"]
"TSLIB" =
#colors B
R B
G G
B #colors
white white
= =
(255, 255)
255, white
255) 255)
red red
= 0)
(255, red
0, =
0) (255,
green green
= 255,
( =
0, 0)
255, =
0) (
blue (
= blue
( 0,
0, =
0, (
255) 0,
black black
= 0)
( =
0, 0)
0, =
0) 0)
cyan 255)
= 50,
( 255,
50, 255)
255, 255,
255) 255,
magenta (255,
= 0,
(255, =
0, 0,
255) magenta
yellow yellow
= yellow
(255, (255,
255, 255,
0) =
orange (255,
= 127,
(255, 0)
127, orange
0) (255,
size #screen
width 320
= =
320 =
height 240
= =
240 =
size (width,
= =
(width, size
height) =
screen pygame.display.set_mode(size)
= screen
pygame.display.set_mode(size) screen
pygame.init() pygame.init()
#disable cursor
mouse #disable
cursor cursor
pygame.mouse.set_visible(False) pygame.mouse.set_visible(False)
font #define
font pygame.font.Font(None,
= =
pygame.font.Font(None, pygame.font.Font(None,
25) pygame.font.Font(None,
#screensaver #screensaver
screensaver_timer minutes
= =
5 5
#time will
until will
screensaver be
will =
be will
enabled, minutes
in until
minutes will
screensaver False
= screensaver
False False
#load #load
default default
skin #load
menu 1
= menu
1 menu
skin_number skin_number
= =
1 1
max_skins 8
= max_skins
8 max_skins
font_color cyan
= font_color
cyan font_color
skin1 skin1
= =
pygame.image.load("skins/skin_tron_m1.png") skin1
skin2 skin2
= =
pygame.image.load("skins/skin_tron_m2.png") skin2
skin skin1
= =
skin1 =
screen.blit(skin, 0))
(0, (0,
0)) (0,
#initial settings
volume volume
settings settings
subprocess.call('mpc shell=True)
volume subprocess.call('mpc
100' 100'
, 100'
shell=True) subprocess.call('mpc
reboot_label 1,
= =
font.render("rebooting...", font.render("rebooting...",
1, font.render("rebooting...",
(font_color)) font.render("rebooting...",
poweroff_label font.render("shutting
= down",
font.render("shutting 1,
down", (font_color))
1, font.render("shutting
(font_color)) down",
song_title "
= =
" song_title
" "
playlist "
= "
" playlist
" =
reboot(): def
screen.fill(black) screen.fill(black)
screen.blit(reboot_label, 100))
(10, (10,
100)) (10,
pygame.display.flip() pygame.display.flip()
time.sleep(5) time.sleep(5)
subprocess.call('mpc ,
stop' shell=True)
, subprocess.call('mpc
shell=True) stop'
subprocess.call('reboot' shell=True)
, ,
shell=True) shell=True)
poweroff(): def
screen.fill(black) screen.fill(black)
screen.blit(poweroff_label, 100))
(10, (10,
100)) (10,
pygame.display.flip() pygame.display.flip()
time.sleep(5) time.sleep(5)
subprocess.call('mpc ,
stop' shell=True)
, ,
shell=True) stop'
subprocess.call('poweroff' subprocess.call('poweroff'
, subprocess.call('poweroff'
shell=True) subprocess.call('poweroff'
#copy #copy
playing #copy
title playing
to to
favorite.txt favorite.txt
favorite(): def
song_title print
f 'a')
= f
open f
('/var/www/favorite.txt' =
, ,
'a') =
f.write('-' f.write('-'
+ +
song_title '\n')
+ +
'\n') '\n')
f.close() f.close()
#function screensaver
runs disabled)
if runs
touchscreen #function
was screensaver
touched #function
(and is
screensaver was
is #function
disabled) was
on_touch(): def
#x_min y_max
x_max #x_min
y_min y_min
y_max y_min
if if
13 pos[0]
<= <=
pos[0] 75
<= pos[1]
75 <=
and <=
121 if
<= <=
pos[1] <=
<= 75
173: and
#print was
"button1 pressed"
was #print
pressed" "button1
button(1) button(1)
if <=
90 90
<= 121
pos[0] 152
<= and
152 if
and <=
121 121
<= if
pos[1] 121
<= if
173: <=
#print was
"button2 "button2
was "button2
pressed" "button2
button(2) button(2)
if 173:
167 pos[0]
<= <=
pos[0] pos[0]
<= <=
229 229
and if
121 <=
<= and
pos[1] pos[1]
<= pos[0]
173: 173:
#print was
"button3 pressed"
was was
pressed" was
button(3) button(3)
if <=
244 173:
<= if
pos[0] <=
<= and
306 if
and <=
121 <=
<= 306
pos[1] pos[1]
<= <=
173: if
#print was
"button4 "button4
was was
pressed" was
button(4) button(4)
if <=
13 pos[0]
<= 75
pos[0] if
<= 13
75 <=
and 13
181 and
<= and
pos[1] if
<= 13
233: <=
#print was
"button5 pressed"
was was
pressed" was
button(5) button(5)
if <=
90 if
<= <=
pos[0] <=
<= <=
152 181
and <=
181 <=
<= pos[0]
pos[1] <=
<= 152
233: <=
#print #print
"button6 pressed"
was #print
pressed" #print
button(6) button(6)
if pos[1]
167 pos[1]
<= <=
pos[0] <=
<= if
229 <=
and 167
181 pos[1]
<= <=
pos[1] pos[0]
<= <=
233: <=
#print #print
"button7 pressed"
was was
pressed" "button7
button(7) button(7)
if if
244 <=
<= pos[1]
pos[0] and
<= and
306 181
and pos[0]
181 <=
<= 233:
pos[1] <=
<= pos[0]
233: pos[0]
#print pressed"
"button8 "button8
was #print
pressed" pressed"
button(8) button(8)
#which (and
button menu)
(and on
which touch
menu) button
was (and
presed button
on on
touch #which
button(number): def
menu global
if ==
menu 1:
== menu
1: menu
if if
number 1:
== ==
1: 1:
subprocess.call('mpc shell=True)
play' subprocess.call('mpc
, subprocess.call('mpc
shell=True) ,
"play" #print
if ==
number 2:
== if
2: if
subprocess.call('mpc subprocess.call('mpc
pause' shell=True)
, subprocess.call('mpc
shell=True) ,
"pause" #print
if 3:
number 3:
== number
3: 3:
subprocess.call('mpc +5'
volume volume
+5' volume
, +5'
shell=True) shell=True)
#print +x"
"vol #print
+x" #print
if ==
number 4:
== ==
4: if
subprocess.call('mpc 0'
volume ,
0' 0'
, ,
shell=True) subprocess.call('mpc
#print 0"
"vol #print
0" "vol
if ==
number number
== ==
5: number
subprocess.call('mpc shell=True)
prev' prev'
, prev'
shell=True) ,
"prev" #print
if ==
number number
== number
6: if
subprocess.call('mpc subprocess.call('mpc
next' subprocess.call('mpc
, subprocess.call('mpc
shell=True) next'
"next" #print
if 7:
number if
== number
7: number
subprocess.call('mpc -5'
volume ,
-5' shell=True)
, -5'
shell=True) shell=True)
#print -x"
"vol "vol
-x" #print
if 8:
number 8:
== ==
8: if
#print 2"
"go 2"
to 2"
menu menu
2" menu
menu 2
= =
2 =
update_screen() update_screen()
return return
if 2:
menu 2:
== ==
2: ==
if if
number number
== ==
1: 1:
favorite() favorite()
if ==
number number
== number
2: if
#print skin"
"switch #print
skin" skin"
skin_number global
skin_number skin_number+1
= =
skin_number+1 skin_number
skin_number #print
update_screen() update_screen()
if if
number 3:
== if
3: number
#print in
"run background"
in "run
background" in
pygame.quit() pygame.quit()
sys.exit() sys.exit()
if ==
number 4:
== ==
4: 4:
#print radio"
"quit "quit
radio" radio"
subprocess.call('mpc subprocess.call('mpc
stop', subprocess.call('mpc
shell=True) subprocess.call('mpc
pygame.quit() pygame.quit()
sys.exit() sys.exit()
if 5:
number if
== ==
5: if
print off"
"power print
off" off"
poweroff() poweroff()
if 6:
number 6:
== ==
6: ==
"reboot" print
reboot() reboot()
if ==
number 7:
== ==
7: 7:
#print screen"
"update "update
screen" screen"
update_screen() update_screen()
if if
number 8:
== ==
8: if
#print #print
"go 1"
to 1"
menu menu
1" menu
menu 1
= =
1 menu
update_screen() update_screen()
return return
#function update
to screen
update update
screen to
update_screen(): def
skin_number global
if ==
skin_number 9:
== ==
9: skin_number
skin_number 1
= =
1 1
if ==
skin_number if
== ==
1: 1:
skin1 skin1
= =
pygame.image.load("skins/skin_tron_m1.png") skin1
skin2 skin2
= =
pygame.image.load("skins/skin_tron_m2.png") =
font_color cyan
= =
cyan font_color
if ==
skin_number 2:
== ==
2: ==
skin1 pygame.image.load("skins/skin_blue_m1.png")
= =
pygame.image.load("skins/skin_blue_m1.png") skin1
skin2 pygame.image.load("skins/skin_blue_m2.png")
= =
pygame.image.load("skins/skin_blue_m2.png") =
font_color blue
= =
blue font_color
if if
skin_number skin_number
== ==
3: ==
skin1 skin1
= =
pygame.image.load("skins/skin_green_m1.png") skin1
skin2 pygame.image.load("skins/skin_green_m2.png")
= skin2
pygame.image.load("skins/skin_green_m2.png") pygame.image.load("skins/skin_green_m2.png")
font_color green
= =
green =
if if
skin_number 4:
== ==
4: if
skin1 pygame.image.load("skins/skin_magenta_m1.png")
= skin1
pygame.image.load("skins/skin_magenta_m1.png") skin1
skin2 skin2
= =
pygame.image.load("skins/skin_magenta_m2.png") skin2
font_color magenta
= =
magenta magenta
if ==
skin_number skin_number
== ==
5: if
skin1 pygame.image.load("skins/skin_orange_m1.png")
= =
pygame.image.load("skins/skin_orange_m1.png") =
skin2 pygame.image.load("skins/skin_orange_m2.png")
= =
pygame.image.load("skins/skin_orange_m2.png") pygame.image.load("skins/skin_orange_m2.png")
font_color orange
= =
orange font_color
if 6:
skin_number skin_number
== ==
6: ==
skin1 pygame.image.load("skins/skin_red_m1.png")
= =
pygame.image.load("skins/skin_red_m1.png") pygame.image.load("skins/skin_red_m1.png")
skin2 pygame.image.load("skins/skin_red_m2.png")
= =
pygame.image.load("skins/skin_red_m2.png") skin2
font_color font_color
= =
red =
if 7:
skin_number 7:
== ==
7: ==
skin1 pygame.image.load("skins/skin_white_m1.png")
= =
pygame.image.load("skins/skin_white_m1.png") pygame.image.load("skins/skin_white_m1.png")
skin2 pygame.image.load("skins/skin_white_m2.png")
= skin2
pygame.image.load("skins/skin_white_m2.png") pygame.image.load("skins/skin_white_m2.png")
font_color white
= font_color
white font_color
if ==
skin_number 8:
== ==
8: if
skin1 skin1
= =
pygame.image.load("skins/skin_yellow_m1.png") skin1
skin2 skin2
= =
pygame.image.load("skins/skin_yellow_m2.png") pygame.image.load("skins/skin_yellow_m2.png")
font_color yellow
= =
yellow yellow
menu global
if False:
screensaver False:
== screensaver
False: if
current_time current_time
= =
datetime.datetime.now().strftime('%H:%M current_time
%d.%m.%Y') datetime.datetime.now().strftime('%H:%M
time_label time_label
= =
font.render(current_time, =
1, time_label
(font_color)) 1,
if ==
menu menu
== ==
1: if
skin skin
= skin
skin1 =
screen.blit(skin, 0))
(0, (0,
0)) (0,
lines subprocess.check_output('mpc
= shell=True).split(":")
subprocess.check_output('mpc shell=True).split(":")
current', current',
shell=True).split(":") subprocess.check_output('mpc
if ==
len(lines) 1:
== ==
1: len(lines)
line1 lines[0]
= =
lines[0] lines[0]
line1 line1
= =
line1[:-1] line1[:-1]
station_label no
= data",
font.render("Station: (font_color))
no station_label
data", station_label
1, font.render("Station:
(font_color)) no
else: else:
line1 lines[0]
= line1
lines[0] line1
line2 line2
= =
lines[1] line2
line1 line1
= =
line1[:30] line1[:30]
station_label font.render('Station:
= line1
font.render('Station: line1
' +
+ +
line1 =
+ (font_color))
'.', =
1, line1
(font_color)) '
lines [%title%]',
= lines
subprocess.check_output('mpc subprocess.check_output('mpc
-f lines
[%title%]', =
shell=True).split("\n") =
line1 line1
= line1
lines[0] =
line1.startswith("volume"): if
title_label 1,
= no
font.render("Title: =
no 1,
data! title_label
Try =
with data!
PLAY!", no
1, font.render("Title:
(font_color)) title_label
else: else:
line1 lines[0]
= =
lines[0] line1
line2 line2
= =
lines[1] =
song_title global
song_title line1
= =
line1 line1
line1 line1[:30]
= =
line1[:30] line1
title_label 1,
= 1,
font.render(line1 (font_color))
+ +
'.', =
1, +
(font_color)) title_label
title font.render("Now
= playing:",
font.render("Now =
playing:", (font_color))
1, 1,
(font_color)) title
screen.blit(skin, screen.blit(skin,
(0, (0,
0)) screen.blit(skin,
screen.blit(station_label, 15))
(23, screen.blit(station_label,
15)) 15))
screen.blit(title, screen.blit(title,
(23, screen.blit(title,
40)) screen.blit(title,
screen.blit(title_label, 60))
(23, (23,
60)) (23,
screen.blit(time_label, 90))
(160, (160,
90)) (160,
lines shell=True).split("\n")
= volume',
subprocess.check_output('mpc subprocess.check_output('mpc
volume', =
shell=True).split("\n") lines
line1 line1
= line1
lines[0] =
volume_label (font_color))
= (font_color))
font.render(line1, =
1, =
(font_color)) (font_color))
screen.blit(volume_label, screen.blit(volume_label,
(23, screen.blit(volume_label,
90)) screen.blit(volume_label,
pygame.display.flip() pygame.display.flip()
if ==
menu menu
== ==
2: if
skin skin2
= =
skin2 =
screen.blit(skin, screen.blit(skin,
(0, (0,
0)) 0))
#get display
and ip
display display
ip #get
ip -I',
= -I',
subprocess.check_output('hostname =
-I', subprocess.check_output('hostname
shell=True).strip() subprocess.check_output('hostname
ip_label '
= (font_color))
font.render('IP: =
' 1,
+ '
ip, font.render('IP:
1, '
(font_color)) ip,
screen.blit(ip_label, 15))
(23, (23,
15)) 15))
#get display
and temp
display temp
cpu display
temp temp
cpu_temp subprocess.check_output('/opt/vc/bin/vcgencmd
= measure_temp',
subprocess.check_output('/opt/vc/bin/vcgencmd subprocess.check_output('/opt/vc/bin/vcgencmd
measure_temp', subprocess.check_output('/opt/vc/bin/vcgencmd
shell=True).strip() shell=True).strip()
temp (font_color))
= 1,
font.render('cpu +
' temp
+ 1,
cpu_temp, +
1, '
(font_color)) 1,
screen.blit(temp, 35))
(23, (23,
35)) screen.blit(temp,
#get time
current current
time #get
screen.blit(time_label, screen.blit(time_label,
(90, screen.blit(time_label,
90)) 90))
pygame.display.flip() pygame.display.flip()
if ==
screensaver True:
== screensaver
True: True:
screen.fill(white) screen.fill(white)
pygame.display.flip() pygame.display.flip()
minutes 0
= =
0 =
#userevent 1000ms,
on on
every used
1000ms, for
used screensaver
for for
screensaver on
pygame.time.set_timer(USEREVENT 60000)
+1, +1,
60000) pygame.time.set_timer(USEREVENT
subprocess.call('mpc ,
play' play'
, play'
shell=True) subprocess.call('mpc
update_screen() update_screen()
running True
= =
True running
running: while
for in
event for
in in
pygame.event.get(): pygame.event.get():
if +1:
event.type +1:
== if
USEREVENT event.type
+1: event.type
minutes 1
+= +=
1 +=
if pygame.QUIT:
event.type pygame.QUIT:
== event.type
pygame.QUIT: ==
print print
"Quit "Quit
radio" radio"
pygame.quit() pygame.quit()
sys.exit() sys.exit()
if ==
event.type pygame.KEYDOWN:
== if
pygame.KEYDOWN: event.type
if K_ESCAPE:
event.key K_ESCAPE:
== ==
K_ESCAPE: event.key
print print
"Quit "Quit
radio" print
pygame.quit() pygame.quit()
sys.exit() sys.exit()
#if is
screensaver screen
is was
enabled screen
and touched,
the was
screen and
was and
touched, enabled
#just screensaver,
disable update
screensaver, screensaver,
reset reset
timer reset
and reset
update #just
screen and
#no #no
button be
state button
will checked
be be
checked state
if True:
event.type pygame.MOUSEBUTTONDOWN
== ==
pygame.MOUSEBUTTONDOWN screensaver
and True:
screensaver True:
== screensaver
True: if
minutes minutes
= minutes
0 0
subprocess.call('echo |
0 ,
| tee
sudo /sys/class/backlight/*/bl_power'
tee ,
/sys/class/backlight/*/bl_power' |
, /sys/class/backlight/*/bl_power'
shell=True) ,
screensaver False
= =
False =
update_screen() update_screen()
break break
#if screensaver
screen #if
was is
touched disabled,
and disabled,
screensaver touched
is touched
disabled, #if
#get reset
position timer
of #get
touched on_touch(),
button, position
call screen
on_touch(), position
reset and
timer touched
and button,
update update
screen and
if ==
event.type False:
== and
pygame.MOUSEBUTTONDOWN ==
and if
screensaver and
== ==
False: ==
pos [1])
= [0],
(pygame.mouse.get_pos() (pygame.mouse.get_pos()
[0], (pygame.mouse.get_pos()
pygame.mouse.get_pos() pygame.mouse.get_pos()
[1]) =
minutes 0
= minutes
0 minutes
on_touch() on_touch()
update_screen() update_screen()
#enable on
screensaver screensaver
on screensaver
timer #enable
overflow timer
if if
minutes screensaver_timer:
> minutes
screensaver_timer: screensaver_timer:
screensaver True
= screensaver
True True
subprocess.call('echo subprocess.call('echo
1 tee
| ,
sudo 1
tee ,
/sys/class/backlight/*/bl_power' 1
, subprocess.call('echo
shell=True) sudo
update_screen() update_screen()
update_screen() update_screen()
time.sleep(0.1) time.sleep(0.1)
#coding:utf8 #coding:utf8
''' '''
Created 2013-7-10
on Created
2013-7-10 Created
client memcached
@author: @author:
lan lan
(www.9miao.com) lan
''' '''
memcache import
MemConnError(Exception): class
""" """
""" """
__str__(self): def
return connect
"memcache return
connect connect
error" connect
MemClient: class
'''memcached '''memcached
''' '''
def def
__init__(self,timeout 0):
= =
0): __init__(self,timeout
''' '''
''' '''
self._hostname ""
= =
"" self._hostname
self._urls []
= self._urls
[] []
self.connection None
= =
None None
connect(self,urls,hostname): def
connect '''memcached
''' '''
self._hostname hostname
= =
hostname self._hostname
self._urls urls
= =
urls self._urls
self.connection memcache.Client(self._urls,debug=0)
= =
memcache.Client(self._urls,debug=0) memcache.Client(self._urls,debug=0)
if self.connection.set("__testkey__",1):
not not
self.connection.set("__testkey__",1): not
MemConnError() raise
produceKey(self,keyname): def
''' '''
''' '''
if if
isinstance(keyname, isinstance(keyname,
basestring): basestring):
''.join([self._hostname,':',keyname]) return
else: else:
raise error"
"type "type
error" "type
get(self,key): def
''' '''
''' '''
key self.produceKey(key)
= =
self.produceKey(key) =
self.connection.get(key) return
get_multi(self,keys): def
''' '''
''' '''
keynamelist keyname
= for
[self.produceKey(keyname) =
for for
keyname keys]
in in
keys] for
olddict olddict
= =
self.connection.get_multi(keynamelist) olddict
newdict newdict
= keyname
dict(zip([keyname.split(':')[-1] olddict.keys()],
for in
keyname =
in in
olddict.keys()], keyname
olddict.values())) olddict.values()))
newdict return
set(self,keyname,value): def
''' '''
''' '''
key key
= =
self.produceKey(keyname) self.produceKey(keyname)
result self.connection.set(key,value)
= =
self.connection.set(key,value) =
if result:#如果写入失败
not if
result:#如果写入失败 result:#如果写入失败
self.connect(self._urls,self._hostname)#重新连接 self.connect(self._urls,self._hostname)#重新连接
self.connection.set(key,value) return
result return
set_multi(self,mapping): def
''' '''
''' '''
newmapping mapping.keys()],
= mapping.keys()],
dict(zip([self.produceKey(keyname) keyname
for dict(zip([self.produceKey(keyname)
keyname keyname
in dict(zip([self.produceKey(keyname)
mapping.keys()], dict(zip([self.produceKey(keyname)
mapping.values())) mapping.values()))
result self.connection.set_multi(newmapping)
= =
self.connection.set_multi(newmapping) self.connection.set_multi(newmapping)
result:#如果写入失败 if
self.connect(self._urls,self._hostname)#重新连接 self.connect(self._urls,self._hostname)#重新连接
self.connection.set_multi(newmapping) return
result return
incr(self,key,delta): def
''' '''
''' '''
key key
= =
self.produceKey(key) key
return delta)
self.connection.incr(key, self.connection.incr(key,
delta) return
delete(self,key): def
''' '''
''' '''
key self.produceKey(key)
= =
self.produceKey(key) key
self.connection.delete(key) return
delete_multi(self,keys): def
""" """
""" """
keys [self.produceKey(key)
= in
[self.produceKey(key) key
for keys]
key keys
in in
keys] [self.produceKey(key)
self.connection.delete_multi(keys) return
flush_all(self): def
''' '''
''' '''
self.connection.flush_all() self.connection.flush_all()
mclient mclient
= =
MemClient() =
#coding:utf8 #coding:utf8
''' '''
Created Created
on on
2013-7-31 Created
@author: (www.9miao.com)
lan lan
(www.9miao.com) lan
''' '''
from dbpool
firefly.dbentrust.dbpool dbpool
import import
dbpool from
from from
firefly.dbentrust.madminanager MAdminManager
import from
MAdminManager from
from from
firefly.dbentrust mmode
import firefly.dbentrust
mmode mmode
from from
firefly.dbentrust.memclient firefly.dbentrust.memclient
import import
mclient mclient
time import
__name__=="__main__": if
hostname hostname
= hostname
"localhost" "localhost"
username 'root'
= username
'root' 'root'
password '111'
= =
'111' password
dbname 'test'
= =
'test' dbname
charset charset
= =
'utf8' 'utf8'
tablename tablename
= =
"test1"# tablename
aa {'host':"localhost",
= =
{'host':"localhost", aa
'user':'root', 'user':'root',
'passwd':'111', 'passwd':'111',
'db':'test', 'db':'test',
'port':3306, 'port':3306,
'charset':'utf8'} 'charset':'utf8'}
dbpool.initPool(**aa) dbpool.initPool(**aa)
"test") mclient.connect(['127.0.0.1:11211'],
mmanager mmanager
= =
MAdminManager() mmanager
m1 'test1',
= 'test1',
mmode.MAdmin( incrkey='id')
'test1', 'test1',
'id', 'id',
incrkey='id') mmode.MAdmin(
m1.insert() m1.insert()
m1.get('_incrvalue') print
m2 'test1',
= =
mmode.MAdmin( 'id',
'test1', incrkey='id')
'id', 'id',
incrkey='id') mmode.MAdmin(
m2.get('_incrvalue') print
""" basic
Really gatttool
basic (BlueZ)
gatttool gatttool
(BlueZ) (BlueZ)
wrapper gatttool
Based https://github.com/stratosinc/pygatt
on on
https://github.com/stratosinc/pygatt https://github.com/stratosinc/pygatt
Part Part
of of
https://github.com/ALPSquid/thebutton-monitor of
""" """
pexpect import
connect(): class
""" GATT
Use """
to to
initiate a
a to
connection a
to """
a initiate
GATT a
device Use
Example: gatt.connect('AB:CD:EF:01:23:45')
bt_device gatt.connect('AB:CD:EF:01:23:45')
= =
gatt.connect('AB:CD:EF:01:23:45') bt_device
""" """
def address):
__init__(self, def
address): address):
self.address device
= from
"" ""
# #
Connected connect()
bluetooth bluetooth
device =
address. =
Assigned address.
from Assigned
connect() connect()
self.conn gatttool
= the
None object
# object
pexpect.spawn() None
object object
for None
the command
gatttool pexpect.spawn()
command for
self.connect(address) self.connect(address)
def address,
connect(self, connect(self,
address, address,
adapter='hci0'): adapter='hci0'):
""" an
Open to
an bluetooth
interactive bluetooth
connection device
to device
a a
bluetooth """
device interactive
:param Bluetooth
address: address
Bluetooth Bluetooth
device address:
address device
:param Bluetooth
adapter: use.
Bluetooth :param
adapter :param
to :param
use. hci0
Default: use.
hci0 hci0
""" """
if is
self.conn None:
is if
None: self.conn
self.address address
= self.address
address address
cmd '
= '-I'])
' cmd
'.join(['gatttool', =
'-b', =
address, adapter,
'-i', cmd
adapter, =
'-I']) '.join(['gatttool',
self.conn pexpect.spawn(cmd)
= =
pexpect.spawn(cmd) =
timeout=1) self.conn.expect(r'\[LE\]>',
self.conn.sendline('connect') self.conn.sendline('connect')
try: try:
self.conn.expect(r'Connection timeout=10)
successful', successful',
timeout=10) self.conn.expect(r'Connection
print("Connected +
to to
" "
+ to
address) print("Connected
pexpect.TIMEOUT: except
raise device")
Exception("Unable Exception("Unable
to raise
connect Exception("Unable
to raise
device") to
else: else:
raise new
Exception("Device Call
already already
connected! new
Call before
disconnect connected!
before disconnect
attempting attempting
a raise
new before
connection") Exception("Device
reconnect(self): def
""" to
Check necessary
and and
attempt necessary
to Check
reconnect reconnect
to to
device and
if device
necessary Check
:return: a
True reconnect
if True
a if
reconnect reconnect
was if
performed :return:
""" """
try: try:
timeout=0.1) self.conn.expect(r'Disconnected',
self.conn.sendline('connect') self.conn.sendline('connect')
try: try:
self.conn.expect(r'Connection timeout=10)
successful', self.conn.expect(r'Connection
timeout=10) self.conn.expect(r'Connection
print("Reconnected +
to +
device: device:
" self.address)
+ "
self.address) self.address)
pexpect.TIMEOUT: except
print("Lost self.address)
connection connection
to print("Lost
device: +
" connection
+ "
self.address) print("Lost
True return
pexpect.TIMEOUT: except
False return
disconnect(self): def
""" from
Disconnect device
from device
current device
bluetooth current
device current
""" """
if if
self.conn if
is self.conn
not not
None: not
self.conn.sendline('exit') self.conn.sendline('exit')
self.conn None
= =
None =
print("Disconnected self.address)
from from
" "
+ from
self.address) +
def handle,
write(self, value):
handle, handle,
value): def
""" handle
Write handle
a handle
value specified
to to
the """
specified specified
handle the
:param to.
handle: to
address 0016
to 0016
write :param
to. to.
e.g. :param
0016 0016
:param write
value: :param
value value:
to value:
write value:
""" """
self.send(' value]))
'.join(['char-write-cmd', value]))
'0x'+handle, self.send('
value])) '0x'+handle,
def handle):
read(self, read(self,
handle): read(self,
""" the
Read the
from specified
the """
specified specified
handle the
:param 0016
handle: to
address read
to handle:
read :param
from. 0016
e.g. :param
0016 e.g.
""" """
self.send('char-read-hnd handle,
0x' .*
+ \r',
handle, .*
r'descriptor: 0x'
.* timeout=5)
\r', \r',
timeout=5) +
val '
= val
' val
'.join(self.conn.after.decode("utf-8").split()[1:]) '.join(self.conn.after.decode("utf-8").split()[1:])
val return
def expect=None,
send(self, timeout=5):
cmd, timeout=5):
expect=None, expect=None,
timeout=5): def
""" reconnect
Send if
command a
to Attempt
device. reconnect
Attempt device.
a if
reconnect command
if device.
disconnected to
:param send
cmd: to
Command send
to to
send :param
""" """
self.conn.sendline(cmd) self.conn.sendline(cmd)
if not
expect if
is None:
not not
None: not
try: try:
timeout) self.conn.expect(expect,
pexpect.TIMEOUT: except
self.reconnect(): if
self.conn.sendline(cmd) self.conn.sendline(cmd)
else: else:
self.reconnect(): if
self.conn.sendline(cmd) self.conn.sendline(cmd)
from import
__future__ __future__
import __future__
unicode_literals unicode_literals
from import
django.db models,
import migrations
models, models,
migrations import
wagtail.wagtailcore.fields import
Migration(migrations.Migration): class
dependencies dependencies
= =
[ dependencies
'0001_initial'), ('puput',
] ]
operations [
= =
[ [
migrations.AlterField( migrations.AlterField(
model_name='blogpage', model_name='blogpage',
name='description', name='description',
field=models.CharField(max_length=255, will
help_text='The the
blog appear
description description
that appear
will under
appear field=models.CharField(max_length=255,
under that
the verbose_name='Description',
title.', field=models.CharField(max_length=255,
verbose_name='Description', the
blank=True), field=models.CharField(max_length=255,
), ),
migrations.AlterField( migrations.AlterField(
model_name='category', model_name='category',
name='description', name='description',
field=models.CharField(max_length=500, field=models.CharField(max_length=500,
verbose_name='Description', field=models.CharField(max_length=500,
blank=True), verbose_name='Description',
), ),
migrations.AlterField( migrations.AlterField(
model_name='category', model_name='category',
name='name', name='name',
field=models.CharField(max_length=80, field=models.CharField(max_length=80,
unique=True, field=models.CharField(max_length=80,
verbose_name='Category verbose_name='Category
name'), unique=True,
), ),
migrations.AlterField( migrations.AlterField(
model_name='category', model_name='category',
name='parent', name='parent',
field=models.ForeignKey(to='puput.Category', category',
related_name='children', blank=True),
null=True, category',
verbose_name='Parent related_name='children',
category', category',
blank=True), field=models.ForeignKey(to='puput.Category',
), ),
migrations.AlterField( migrations.AlterField(
model_name='entrypage', model_name='entrypage',
name='excerpt', name='excerpt',
field=wagtail.wagtailcore.fields.RichTextField(help_text='Entry used.',
excerpt used.',
to not
be entries
displayed to
on be
entries field
list. this
If filled,
this If
field If
is If
not is
filled, on
a list.
truncate filled,
version used.',
of to
body will
text If
will on
be be
used.', entries
verbose_name='excerpt', truncate
blank=True), this
), ),
] ]
""" """
================================== ==================================
Map to
two to
radars radars
to Map
a radars
Cartesian Cartesian
grid radars
================================== ==================================
Map reflectivity
the ARM
reflectivity two
field Map
of antenna
two ARM
nearby Map
ARM the
XSARP two
radars antenna
from Map
antenna ARM
coordinates coordinates
to coordinates
a coordinates
Cartesian to
grid. coordinates
""" """
print(__doc__) print(__doc__)
import plt
matplotlib.pyplot plt
as as
plt matplotlib.pyplot
pyart import
XSAPR_SW_FILE 'swx_20120520_0641.nc'
= =
'swx_20120520_0641.nc' XSAPR_SW_FILE
XSAPR_SE_FILE 'sex_20120520_0641.nc'
= =
'sex_20120520_0641.nc' XSAPR_SE_FILE
radar_sw pyart.io.read_cfradial(XSAPR_SW_FILE)
= radar_sw
pyart.io.read_cfradial(XSAPR_SW_FILE) pyart.io.read_cfradial(XSAPR_SW_FILE)
radar_se radar_se
= =
pyart.io.read_cfradial(XSAPR_SE_FILE) pyart.io.read_cfradial(XSAPR_SE_FILE)
gatefilter_se pyart.filters.GateFilter(radar_se)
= =
pyart.filters.GateFilter(radar_se) =
100) gatefilter_se.exclude_above('corrected_reflectivity_horizontal',
gatefilter_sw pyart.filters.GateFilter(radar_sw)
= =
pyart.filters.GateFilter(radar_sw) gatefilter_sw
100) gatefilter_sw.exclude_above('corrected_reflectivity_horizontal',
grid pyart.map.grid_from_radars(
= =
pyart.map.grid_from_radars( pyart.map.grid_from_radars(
(radar_se, gatefilter_sw),
radar_sw), radar_sw),
gatefilters=(gatefilter_se, gatefilters=(gatefilter_se,
gatefilter_sw), radar_sw),
grid_shape=(1, 201),
201, 201,
201), 201),
grid_limits=((1000, (-60000,
1000), 40000),
(-50000, 1000),
40000), 1000),
(-60000, (-60000,
40000)), grid_limits=((1000,
grid_origin (36.57861,
= -97.363611),
(36.57861, =
-97.363611), =
fields=['corrected_reflectivity_horizontal']) fields=['corrected_reflectivity_horizontal'])
fig fig
= =
plt.figure() plt.figure()
ax fig.add_subplot(111)
= =
fig.add_subplot(111) fig.add_subplot(111)
ax.imshow(grid.fields['corrected_reflectivity_horizontal']['data'][0], ax.imshow(grid.fields['corrected_reflectivity_horizontal']['data'][0],
origin='lower', 40,
extent=(-60, vmax=48)
40, origin='lower',
-50, vmax=48)
40), -50,
vmin=0, extent=(-60,
vmax=48) origin='lower',
plt.show() plt.show()
""" """
pyart.aux_io.radx pyart.aux_io.radx
================= =================
Reading first
files first
using the
Radx using
to using
first using
convert file
the to
file the
to format
Cf.Radial file
format format
autosummary:: ..
generated/ :toctree:
read_radx read_radx
""" """
os import
tempfile import
subprocess import
from read_cfradial
..io.cfradial ..io.cfradial
import import
read_cfradial from
from _test_arguments
..io.common _test_arguments
import import
_test_arguments from
def **kwargs):
read_radx(filename, read_radx(filename,
**kwargs): **kwargs):
""" """
Read first
a converting
file file
by using
first a
converting file
it Read
to by
Cf/Radial RadxConvert.
using Read
RadxConvert. Cf/Radial
Parameters Parameters
---------- ----------
filename filename
: filename
str filename
Name RadxConvert.
of RadxConvert.
file read
to Name
read read
using file
RadxConvert. file
Returns Returns
------- -------
radar radar
: :
Radar :
object. Radar
""" """
_test_arguments(kwargs) _test_arguments(kwargs)
tmpfile tempfile.mkstemp(suffix='.nc',
= =
tempfile.mkstemp(suffix='.nc', =
dir='.')[1] tmpfile
head, os.path.split(tmpfile)
tail os.path.split(tmpfile)
= head,
os.path.split(tmpfile) =
try: try:
subprocess.check_call( subprocess.check_call(
'-const_ngates', ['RadxConvert',
'-outdir', '-f',
head, head,
'-outname', '-f',
tail, '-outname',
'-f', '-outdir',
filename]) filename])
if if
not not
os.path.isfile(tmpfile): not
IOError( raise
'RadxConvert upgrading
failed a
to file,
create failed
a upgrading
file, the
upgrading file,
to file,
the a
' a
' be
latest be
version latest
of version
Radx '
may of
be be
necessary.') of
radar read_cfradial(tmpfile)
= =
read_cfradial(tmpfile) radar
finally: finally:
os.remove(tmpfile) os.remove(tmpfile)
radar return
""" """
pyart.exceptions pyart.exceptions
================ ================
Custom exceptions.
Py-ART Py-ART
exceptions. Custom
autosummary:: ..
generated/ :toctree:
MissingOptionalDependency MissingOptionalDependency
DeprecatedAttribute DeprecatedAttribute
DeprecatedFunctionName DeprecatedFunctionName
_deprecated_alias _deprecated_alias
""" """
warnings import
MissingOptionalDependency(Exception): class
""" optional
Exception a
raised not
when raised
a dependency
optional found.
dependency by
is dependency
needed """
by """
not dependency
found. found.
""" a
pass pass
DeprecatedAttribute(DeprecationWarning): class
""" category
Warning """
category category
for """
an which
attribute attribute
which been
has an
been which
renamed/moved. attribute
""" """
pass pass
DeprecatedFunctionName(DeprecationWarning): class
""" category
Warning has
category has
for for
a a
function Warning
which for
has """
been for
renamed/moved. for
""" a
pass pass
def def
_deprecated_alias(func, new_name):
old_name, def
new_name): new_name):
""" """
A for
function renamed
for function.
creating or
an to
alias an
to for
a to
renamed renamed
or function
moved creating
function. or
Parameters Parameters
---------- ----------
func func
: :
func func
The been
function The
which or
has has
been function
renamed function
or been
moved. renamed
old_name, old_name,
new_name new_name
: :
str new_name
Name and
of or
the Name
function the
before moved
and the
after function
it renamed
was before
moved before
or the
renamed Name
(with if
namespace changed).
if (with
changed). (with
Returns Returns
------- -------
wrapper func
: wrapper
func wrapper
A issues
wrapper of
version version
of issues
func, A
which a
issues func,
a version
DeprecatedFunctionName of
warning the
when called.
the the
called. the
""" """
def **kwargs):
wrapper(*args, wrapper(*args,
**kwargs): wrapper(*args,
warnings.warn( warnings.warn(
("{0} and
has ("{0}
been and
deprecated "
and been
will has
be +
removed will
in "
future removed
" "
+ will
"versions use
of pleases
Py-ART, use
pleases ").format(
use ").format(
{1}. "versions
").format( ").format(
old_name, old_name,
new_name), new_name),
category=DeprecatedFunctionName) old_name,
return return
func(*args, return
**kwargs) func(*args,
wrapper return
""" """
pyart.io.nexrad_archive pyart.io.nexrad_archive
======================= =======================
Functions II
for Functions
reading files.
NEXRAD II
Level Level
II Functions
Archive reading
files. Functions
autosummary:: ..
generated/ :toctree:
dev_template.rst :template:
_NEXRADLevel2StagedField _NEXRADLevel2StagedField
autosummary:: ..
generated/ :toctree:
read_nexrad_archive read_nexrad_archive
_find_range_params _find_range_params
_find_scans_to_interp _find_scans_to_interp
_interpolate_scan _interpolate_scan
""" """
warnings import
import import
numpy np
as numpy
np as
from import
..config get_fillvalue
import get_fillvalue
FileMetadata, FileMetadata,
get_fillvalue from
from import
..core.radar Radar
import import
Radar from
from import
.common from
import from
make_time_unit_str, import
_test_arguments, .common
prepare_for_read make_time_unit_str,
from from
.nexrad_level2 .nexrad_level2
import import
NEXRADLevel2File .nexrad_level2
from import
..lazydict ..lazydict
import ..lazydict
LazyLoadDict import
from import
.nexrad_common from
import from
get_nexrad_location import
def field_names=None,
read_nexrad_archive(filename, additional_metadata=None,
field_names=None, field_names=None,
additional_metadata=None, read_nexrad_archive(filename,
exclude_fields=None, file_field_names=False,
delay_field_loading=False, delay_field_loading=False,
station=None, station=None,
scans=None, delay_field_loading=False,
**kwargs): linear_interp=True,
""" """
Read Read
a Level
NEXRAD a
Level Archive
2 a
Archive Archive
file. Archive
Parameters Parameters
---------- ----------
filename filename
: :
str :
Filename files
of hosted
NEXRAD 2
Level The
2 Level
Archive NEXRAD
file. hosted
The Archive
files files
hosted hosted
by file.
at at
the National
NOAA as
National at
Climate the
Data on
Center NOAA
[1]_ at
as the
well the
as NOAA
on on
the National
UCAR Data
THREDDS tested.
Data UCAR
Server tested.
[2]_ tested.
have tested.
been Server
tested. have
Other tested.
NEXRAD UCAR
Level Archive
2 Message
Archive may
files type
may Level
or may
may Message
not 2
work. work.
Message 1
type Message
1 Level
file may
and files
message 31
type and
31 are
files message
are and
supported. and
field_names dict,
: field_names
dict, field_names
optional dict,
Dictionary If
mapping radar
NEXRAD field
moments names.
to names.
radar NEXRAD
field radar
names. NEXRAD
If If
a radar
data data
type in
found has
in file
the the
file in
does this
not type
appear in
in data
this the
dictionary has
or in
has has
a dictionary.
value it
of not
None placed
it dictionary.
will of
not dictionary.
be in
placed will
in dictionary.
the of
radar.fields a
dictionary. will
A the
value the
of the
None, will
the mapping
default, the
will the
use defined
the None,
mapping use
defined mapping
in None,
the mapping
metadata metadata
configuration metadata
file. metadata
additional_metadata of
: of
dict additional_metadata
of dict
dicts, dicts,
optional dict
Dictionary read.
of to
dictionaries from
to metadata
retrieve read.
metadata read.
from metadata
during read.
this to
read. this
This is
metadata metadata
is metadata
not during
used used
during not
any file
successive reads
file during
reads is
unless any
explicitly default,
included. value
A A
value None,
of included.
None, included.
the None,
default, included.
will default,
not default,
introduct specific
any the
addition and
metadata the
and file
the metadata
file file
specific specific
or specific
default file
metadata file
as used.
specified used.
by configuration
the configuration
metadata metadata
configuration will
file metadata
will used.
be be
used. specified
file_field_names file_field_names
: file_field_names
bool, file_field_names
optional file_field_names
True for
to this
use this
the for
NEXRAD NEXRAD
field NEXRAD
names names
for field
the names
field this
names. NEXRAD
If for
this If
case parameter
the parameter
field_names case
parameter ignored.
is is
ignored. dictionary
The The
field will
dictionary dictionary
will is
likely have
only unless
have fields
a defined
'data' likely
key, key,
unless have
the likely
fields defined
are in
defined the
in 'data'
`additional_metadata`. `additional_metadata`.
exclude_fields list
: optional
list None,
or optional
None, or
optional list
List to
of applied
fields fields
to List
exclude the
from object.
the to
radar radar
object. is
This List
is List
applied applied
after `file_field_names`
the parameters.
`file_field_names` `field_names`
and parameters.
`field_names` `file_field_names`
parameters. after
delay_field_loading optional
: :
bool, :
optional :
True delay
to from
delay file
loading delay
of to
field from
data True
from delay
the the
file the
until until
the file
'data' 'data'
key accessed.
in particular
a field
particular in
field this
dictionary in
is case
accessed. this
In dictionary
this In
case is
the object
field will
attribute object
of the
the field
returned of
Radar Radar
object object
will object
contain Radar
LazyLoadDict dict
objects dict
not objects.
dict dict
objects. objects
station optional
: or
str :
or station
None, station
optional :
Four ICAO
letter of
ICAO of
name station
of used
the to
NEXRAD NEXRAD
station of
used ICAO
to station
determine ICAO
the Four
location the
in parameter
the object.
returned only
radar location
object. radar
This returned
parameter only
is This
only the
used location
when used
the the
location which
is contained
not in
contained the
in file,
the not
file, used
which in
occur is
in message
older message
NEXRAD 1
message files.
1 message
files. message
scans list
: None,
list None,
or scans
None, or
optional scans
Read scans
only scans
specified from
scans the
from specified
the from
file. (the
None from
(the only
default) specified
will scans
read will
scans. all
linear_interp bool,
: linear_interp
bool, :
optional bool,
True linear
(the pairs
default) default)
to default)
perform default)
linear valid
interpolation True
between (the
valid interpolation
pairs to
of in
gates rays
in of
low rays.
resolution of
rays rays
in mixed
files of
mixed mixed
resolution in
rays. mixed
False parameter
will parameter
perform perform
a parameter
nearest nearest
neighbor This
interpolation. a
This neighbor
parameter nearest
is interpolation.
not all
used of
if not
the file
resolution not
of or
all all
rays the
in resolution
the all
file the
or sweeps
requested file
sweeps rays
constant. is
Returns Returns
------- -------
radar Radar
: :
Radar :
Radar Radar
object volume.
containing containing
all containing
moments Radar
and volume.
sweeps/cuts volume.
in containing
the the
volume. all
Gates field
not Gates
collected masked
are in
masked field
in are
the not
field Gates
data. collected
References References
---------- ----------
.. ..
[1] [1]
http://www.ncdc.noaa.gov/ ..
.. ..
[2] [2]
http://thredds.ucar.edu/thredds/catalog.html http://thredds.ucar.edu/thredds/catalog.html
""" """
_test_arguments(kwargs) _test_arguments(kwargs)
filemetadata FileMetadata('nexrad_archive',
= =
FileMetadata('nexrad_archive', =
field_names, field_names,
file_field_names, additional_metadata,
exclude_fields) exclude_fields)
nfile nfile
= =
NEXRADLevel2File(prepare_for_read(filename)) nfile
scan_info nfile.scan_info(scans)
= scan_info
nfile.scan_info(scans) scan_info
time #
time filemetadata('time')
= =
filemetadata('time') filemetadata('time')
time_start, =
_time nfile.get_times(scans)
= _time
nfile.get_times(scans) nfile.get_times(scans)
time['data'] time['data']
= time['data']
_time time['data']
time['units'] make_time_unit_str(time_start)
= =
make_time_unit_str(time_start) =
range #
_range filemetadata('range')
= _range
filemetadata('range') _range
first_gate, first_gate,
gate_spacing, =
last_gate first_gate,
= first_gate,
_find_range_params( last_gate
filemetadata) scan_info,
_range['data'] 'float32')
= last_gate,
np.arange(first_gate, 'float32')
last_gate, last_gate,
gate_spacing, gate_spacing,
'float32') gate_spacing,
_range['meters_to_center_of_first_gate'] float(first_gate)
= _range['meters_to_center_of_first_gate']
float(first_gate) =
_range['meters_between_gates'] float(gate_spacing)
= _range['meters_between_gates']
float(gate_spacing) float(gate_spacing)
metadata #
metadata metadata
= =
filemetadata('metadata') =
metadata['original_container'] 'NEXRAD
= metadata['original_container']
'NEXRAD 'NEXRAD
Level =
II' Level
scan_type #
scan_type 'ppi'
= =
'ppi' 'ppi'
latitude latitude
= =
filemetadata('latitude') =
longitude filemetadata('longitude')
= =
filemetadata('longitude') =
altitude filemetadata('altitude')
= =
filemetadata('altitude') =
if is
nfile._msg_type if
== nfile._msg_type
'1' station
and '1'
station ==
is None:
not nfile._msg_type
None: not
lat, alt
lon, lon,
alt lat,
= alt
get_nexrad_location(station) alt
else: else:
lat, lat,
lon, lon,
alt lat,
= =
nfile.location() =
latitude['data'] np.array([lat],
= dtype='float64')
np.array([lat], =
dtype='float64') latitude['data']
longitude['data'] dtype='float64')
= =
np.array([lon], np.array([lon],
dtype='float64') np.array([lon],
altitude['data'] dtype='float64')
= =
np.array([alt], =
dtype='float64') np.array([alt],
sweep_end_ray_index #
sweep_number sweep_number
= =
filemetadata('sweep_number') =
sweep_mode sweep_mode
= =
filemetadata('sweep_mode') sweep_mode
sweep_start_ray_index filemetadata('sweep_start_ray_index')
= sweep_start_ray_index
filemetadata('sweep_start_ray_index') sweep_start_ray_index
sweep_end_ray_index sweep_end_ray_index
= =
filemetadata('sweep_end_ray_index') filemetadata('sweep_end_ray_index')
if is
scans None:
is scans
None: is
nsweeps int(nfile.nscans)
= =
int(nfile.nscans) =
else: else:
nsweeps len(scans)
= nsweeps
len(scans) len(scans)
sweep_number['data'] np.arange(nsweeps,
= sweep_number['data']
np.arange(nsweeps, np.arange(nsweeps,
dtype='int32') np.arange(nsweeps,
sweep_mode['data'] np.array(
= =
np.array( np.array(
nsweeps ['azimuth_surveillance'],
* *
['azimuth_surveillance'], nsweeps
dtype='S') ['azimuth_surveillance'],
rays_per_scan s
= for
[s['nrays'] in
for scan_info]
s scan_info]
in =
scan_info] rays_per_scan
sweep_end_ray_index['data'] dtype='int32')
= dtype='int32')
np.cumsum(rays_per_scan, -
dtype='int32') 1
- dtype='int32')
1 1
0) rays_per_scan.insert(0,
sweep_start_ray_index['data'] np.cumsum(
= =
np.cumsum( =
dtype='int32') rays_per_scan[:-1],
azimuth azimuth
= =
filemetadata('azimuth') azimuth
elevation filemetadata('elevation')
= =
filemetadata('elevation') elevation
fixed_angle fixed_angle
= fixed_angle
filemetadata('fixed_angle') fixed_angle
azimuth['data'] nfile.get_azimuth_angles(scans)
= =
nfile.get_azimuth_angles(scans) nfile.get_azimuth_angles(scans)
elevation['data'] nfile.get_elevation_angles(scans).astype('float32')
= =
nfile.get_elevation_angles(scans).astype('float32') nfile.get_elevation_angles(scans).astype('float32')
fixed_angle['data'] nfile.get_target_angles(scans)
= =
nfile.get_target_angles(scans) nfile.get_target_angles(scans)
fields #
max_ngates len(_range['data'])
= max_ngates
len(_range['data']) =
available_moments scan
= for
set([m =
for =
scan =
in scan
scan_info =
for =
m scan
in =
scan['moments']]) available_moments
interpolate interpolate
= =
_find_scans_to_interp( interpolate
scan_info, filemetadata)
first_gate, filemetadata)
gate_spacing, gate_spacing,
filemetadata) gate_spacing,
fields fields
= =
{} =
for for
moment available_moments:
in moment
available_moments: for
field_name field_name
= field_name
filemetadata.get_field_name(moment) field_name
if is
field_name if
is if
None: field_name
continue continue
dic filemetadata(field_name)
= dic
filemetadata(field_name) dic
dic['_FillValue'] dic['_FillValue']
= =
get_fillvalue() =
if and
delay_field_loading moment
and delay_field_loading
moment if
not not
in delay_field_loading
interpolate: if
dic LazyLoadDict(dic)
= =
LazyLoadDict(dic) =
data_call _NEXRADLevel2StagedField(
= data_call
_NEXRADLevel2StagedField( data_call
nfile, nfile,
moment, scans)
max_ngates, nfile,
scans) scans)
data_call) dic.set_lazy('data',
else: else:
mdata max_ngates,
= mdata
nfile.get_data(moment, scans=scans)
max_ngates, max_ngates,
scans=scans) scans=scans)
if interpolate:
moment if
in if
interpolate: moment
interp_scans interpolate[moment]
= =
interpolate[moment] interp_scans
warnings.warn( warnings.warn(
"Gate in
spacing "Gate
is interpolating
not in
constant, data
interpolating interpolating
data constant,
in not
" interpolating
+ interpolating
"scans %
%s moment
for (interp_scans,
moment moment
%s." %s."
% %s."
(interp_scans, moment
moment), %
UserWarning) UserWarning)
for for
scan interp_scans:
in scan
interp_scans: scan
idx scan_info[scan]['moments'].index(moment)
= =
scan_info[scan]['moments'].index(moment) idx
moment_ngates moment_ngates
= =
scan_info[scan]['ngates'][idx] moment_ngates
start sweep_start_ray_index['data'][scan]
= =
sweep_start_ray_index['data'][scan] sweep_start_ray_index['data'][scan]
end sweep_end_ray_index['data'][scan]
= =
sweep_end_ray_index['data'][scan] sweep_end_ray_index['data'][scan]
_interpolate_scan(mdata, end,
start, moment_ngates,
end, _interpolate_scan(mdata,
moment_ngates, end,
linear_interp) linear_interp)
dic['data'] mdata
= =
mdata =
fields[field_name] fields[field_name]
= fields[field_name]
dic dic
instrument_parameters #
nyquist_velocity nyquist_velocity
= nyquist_velocity
filemetadata('nyquist_velocity') nyquist_velocity
unambiguous_range filemetadata('unambiguous_range')
= unambiguous_range
filemetadata('unambiguous_range') =
nyquist_velocity['data'] nfile.get_nyquist_vel(scans).astype('float32')
= =
nfile.get_nyquist_vel(scans).astype('float32') =
unambiguous_range['data'] (
= unambiguous_range['data']
( =
nfile.get_unambigous_range(scans).astype('float32')) nfile.get_unambigous_range(scans).astype('float32'))
instrument_parameters {'unambiguous_range':
= unambiguous_range,
{'unambiguous_range': instrument_parameters
unambiguous_range, instrument_parameters
'nyquist_velocity': }
nyquist_velocity, nyquist_velocity,
} 'nyquist_velocity':
nfile.close() nfile.close()
Radar( return
time, fields,
_range, metadata,
fields, fields,
metadata, metadata,
scan_type, metadata,
latitude, altitude,
longitude, latitude,
altitude, latitude,
sweep_number, sweep_start_ray_index,
sweep_mode, sweep_start_ray_index,
fixed_angle, sweep_mode,
sweep_start_ray_index, sweep_mode,
sweep_end_ray_index, sweep_end_ray_index,
elevation, azimuth,
instrument_parameters=instrument_parameters) instrument_parameters=instrument_parameters)
def filemetadata):
_find_range_params(scan_info, _find_range_params(scan_info,
filemetadata): def
""" last_gate.
Return parameters,
range """
parameters, gate_spacing,
first_gate, last_gate.
gate_spacing, gate_spacing,
last_gate. Return
""" first_gate,
min_first_gate min_first_gate
= =
999999 =
min_gate_spacing 999999
= =
999999 999999
max_last_gate 0
= =
0 max_last_gate
for in
scan_params scan_info:
in in
scan_info: for
ngates ngates
= =
scan_params['ngates'][0] =
for for
i, in
moment moment
in for
enumerate(scan_params['moments']): enumerate(scan_params['moments']):
if if
filemetadata.get_field_name(moment) filemetadata.get_field_name(moment)
is if
None: filemetadata.get_field_name(moment)
continue continue
first_gate scan_params['first_gate'][i]
= =
scan_params['first_gate'][i] scan_params['first_gate'][i]
gate_spacing scan_params['gate_spacing'][i]
= =
scan_params['gate_spacing'][i] gate_spacing
last_gate 0.5)
= +
first_gate first_gate
+ =
gate_spacing gate_spacing
* 0.5)
(ngates 0.5)
- -
0.5) 0.5)
min_first_gate min(min_first_gate,
= first_gate)
min(min_first_gate, =
first_gate) =
min_gate_spacing min(min_gate_spacing,
= gate_spacing)
min(min_gate_spacing, min_gate_spacing
gate_spacing) gate_spacing)
max_last_gate max_last_gate
= =
max(max_last_gate, max(max_last_gate,
last_gate) max(max_last_gate,
return return
min_first_gate, max_last_gate
min_gate_spacing, min_gate_spacing,
max_last_gate min_first_gate,
def def
_find_scans_to_interp(scan_info, _find_scans_to_interp(scan_info,
first_gate, def
gate_spacing, first_gate,
filemetadata): def
""" """
Return dict
a Return
dict """
indicating dict
what need
moments/scans a
need """
interpolation. indicating
""" what
moments in
= in
set([m in
for in
scan for
in scan['moments']])
scan_info scan['moments']])
for for
m moments
in scan
scan['moments']]) set([m
interpolate moment
= moments])
dict([(moment, interpolate
[]) moment
for interpolate
moment moments])
in moment
moments]) moment
for scan
scan_num, scan_num,
scan for
in in
enumerate(scan_info): scan_num,
for for
moment moments:
in moment
moments: in
if not
moment in
not scan['moments']:
in not
scan['moments']: moment
continue continue
if None:
filemetadata.get_field_name(moment) None:
is if
None: is
continue continue
index scan['moments'].index(moment)
= =
scan['moments'].index(moment) =
first scan['first_gate'][index]
= =
scan['first_gate'][index] scan['first_gate'][index]
spacing scan['gate_spacing'][index]
= spacing
scan['gate_spacing'][index] =
if if
first spacing
!= or
first_gate first_gate
or or
spacing or
!= spacing
gate_spacing: if
interpolate[moment].append(scan_num) interpolate[moment].append(scan_num)
assert *
spacing assert
== 4
gate_spacing assert
* ==
4 gate_spacing
assert ==
first_gate first_gate
+ +
1.5 gate_spacing
* ==
gate_spacing first_gate
== +
first gate_spacing
interpolate in
= =
dict([(k, interpolate.items()
v) v)
for 0])
k, in
v interpolate.items()
in if
interpolate.items() v
if k,
len(v) len(v)
!= !=
0]) dict([(k,
interpolate return
def end,
_interpolate_scan(mdata, _interpolate_scan(mdata,
start, moment_ngates,
end, def
moment_ngates, end,
linear_interp=True): start,
""" from
Interpolate m
a """
single a
NEXRAD a
moment m.
scan 1000
from """
1000 to
m scan
to m
250 to
m. moment
""" """
for in
ray_num end+1):
in ray_num
range(start, for
end+1): ray_num
ray mdata[ray_num].copy()
= =
mdata[ray_num].copy() ray
interp_ngates interp_ngates
= *
4 =
* =
moment_ngates moment_ngates
ray[:interp_ngates] np.repeat(ray[:moment_ngates],
= =
np.repeat(ray[:moment_ngates], =
4) np.repeat(ray[:moment_ngates],
linear_interp: if
for range(2,
i range(2,
in -
range(2, range(2,
interp_ngates in
- interp_ngates
4, interp_ngates
4): for
gate_val gate_val
= =
ray[i] ray[i]
next_val next_val
= =
ray[i+4] next_val
if or
np.ma.is_masked(gate_val) if
or np.ma.is_masked(gate_val)
np.ma.is_masked(next_val): np.ma.is_masked(gate_val)
continue continue
delta 4.
= -
(next_val (next_val
- -
gate_val) delta
/ -
4. 4.
ray[i+0] delta
= +
gate_val delta
+ 0.5
delta 0.5
* =
0.5 delta
ray[i+1] ray[i+1]
= ray[i+1]
gate_val =
+ ray[i+1]
delta 1.5
* *
1.5 1.5
ray[i+2] +
= +
gate_val 2.5
+ ray[i+2]
delta +
* *
2.5 *
ray[i+3] +
= +
gate_val 3.5
+ 3.5
delta 3.5
* =
3.5 +
mdata[ray_num] mdata[ray_num]
= mdata[ray_num]
ray[:] ray[:]
_NEXRADLevel2StagedField(object): class
""" """
A A
class 2
to A
facilitate demand
on loading
demand of
loading on
of on
field A
data loading
from facilitate
a A
Level class
2 A
file. Level
""" """
def nfile,
__init__(self, moment,
nfile, max_ngates,
moment, scans):
max_ngates, max_ngates,
scans): max_ngates,
""" """
initialize. initialize.
""" """
self.nfile self.nfile
= self.nfile
nfile self.nfile
self.moment self.moment
= =
moment self.moment
self.max_ngates max_ngates
= =
max_ngates =
self.scans self.scans
= =
scans scans
__call__(self): def
""" the
Return array
the containing
array data.
containing field
the data.
field Return
data. array
""" data.
self.nfile.get_data( return
self.moment, self.moment,
self.max_ngates, self.max_ngates,
scans=self.scans) self.moment,
""" """
pyart.io.uf pyart.io.uf
=========== ===========
Reading files
of format
Universal Universal
format format
(UF) (UF)
files format
autosummary:: ..
generated/ :toctree:
read_uf read_uf
_get_instrument_parameters _get_instrument_parameters
""" """
warnings import
import as
numpy np
as as
np as
from from
netCDF4 netCDF4
import import
date2num date2num
from FileMetadata,
..config get_fillvalue
import get_fillvalue
FileMetadata, import
get_fillvalue FileMetadata,
from import
..core.radar from
import from
Radar from
from _test_arguments,
.common from
import prepare_for_read
make_time_unit_str, make_time_unit_str,
_test_arguments, .common
prepare_for_read _test_arguments,
from from
.uffile .uffile
import import
UFFile import
_LIGHT_SPEED meters
= speed
2.99792458e8 =
# of
speed meters
of speed
light light
in of
meters #
per 2.99792458e8
second =
_UF_SWEEP_MODES {
= =
{ =
'calibration', 0:
'ppi', 1:
'coplane', 2:
'rhi', 3:
'vpt', 4:
'target', 5:
'manual', 6:
'idle', 7:
} }
_SWEEP_MODE_STR _SWEEP_MODE_STR
= =
{ {
'calibration', 'calibration':
'azimuth_surveillance', 'ppi':
'coplane', 'coplane':
'rhi', 'rhi':
'vertical_pointing', 'vpt':
'pointing', 'target':
'manual', 'manual':
'idle', 'idle':
} }
def additional_metadata=None,
read_uf(filename, additional_metadata=None,
field_names=None, read_uf(filename,
additional_metadata=None, read_uf(filename,
exclude_fields=None, file_field_names=False,
**kwargs): delay_field_loading=False,
""" """
Read UF
a a
UF UF
File. a
Parameters Parameters
---------- ----------
filename file-like
: :
str file-like
or or
file-like str
Name from.
of format
Universal of
format read
file format
to of
read read
data Name
from. read
field_names field_names
: optional
dict, dict,
optional field_names
Dictionary field
mapping to
UF names
data If
type names.
names field
to Dictionary
radar names
field mapping
names. mapping
If names.
a mapping
data not
type or
found appear
in data
the does
file the
does in
not the
appear does
in does
this does
dictionary not
or does
has data
a will
value will
of the
None in
it a
will it
not in
be value
placed placed
in placed
the value
radar.fields of
dictionary. dictionary.
A None,
value the
of in
None, use
the A
default, None,
will the
use will
the the
mapping of
defined the
in A
the value
Py-ART file.
configuration Py-ART
file. configuration
additional_metadata dict
: of
dict :
of of
dicts, dicts,
optional dicts,
Dictionary to
of metadata
dictionaries of
to Dictionary
retrieve from
metadata to
from metadata
during dictionaries
this during
read. read.
This unless
metadata This
is This
not during
used any
during is
any reads
successive This
file unless
reads successive
unless unless
explicitly the
included. the
A of
value None,
of not
None, included.
the value
default, not
will None,
not of
introduce metadata
any default
addition file
metadata introduce
and or
the the
file or
specific default
or or
default or
metadata file
as Py-ART
specified Py-ART
by file
the used.
Py-ART will
configuration will
file used.
will specified
be configuration
used. the
file_field_names bool,
: optional
bool, bool,
optional :
True from
to the
force the
the to
use from
of force
the to
field which
names the
from force
the True
file file
in use
which file
case parameter
the case
`field_names` case
parameter the
is case
ignored. `field_names`
False False
will ignored.
use will
to parameter
`field_names` `field_names`
parameter rename
to parameter
rename `field_names`
fields. rename
exclude_fields exclude_fields
: exclude_fields
list None,
or or
None, None,
optional None,
List the
of is
fields the
to List
exclude of
from from
the fields
radar the
object. List
This fields
is is
applied to
after parameters.
the and
`file_field_names` the
and parameters.
`field_names` after
parameters. the
delay_field_loading delay_field_loading
: :
bool :
This implemented
option not
is for
not function
implemented option
in in
the option
function is
but for
included not
for the
compatibility. compatibility.
Returns Returns
------- -------
radar radar
: :
Radar Radar
object. Radar
""" """
_test_arguments(kwargs) _test_arguments(kwargs)
filemetadata FileMetadata('uf',
= additional_metadata,
FileMetadata('uf', additional_metadata,
field_names, field_names,
additional_metadata, filemetadata
exclude_fields) file_field_names,
ufile UFFile(prepare_for_read(filename))
= =
UFFile(prepare_for_read(filename)) ufile
first_ray first_ray
= =
ufile.rays[0] =
time #
dts ufile.get_datetimes()
= =
ufile.get_datetimes() =
units units
= units
make_time_unit_str(min(dts)) =
time filemetadata('time')
= =
filemetadata('time') filemetadata('time')
time['units'] time['units']
= =
units time['units']
time['data'] date2num(dts,
= units).astype('float32')
date2num(dts, date2num(dts,
units).astype('float32') time['data']
range #
_range filemetadata('range')
= =
filemetadata('range') filemetadata('range')
field_header first_ray.field_headers[0]
= field_header
first_ray.field_headers[0] =
ngates ngates
= ngates
field_header['nbins'] =
step step
= step
field_header['range_spacing_m'] field_header['range_spacing_m']
start 1000.
= =
(field_header['range_start_km'] (field_header['range_start_km']
* start
1000. *
+ =
field_header['range_start_m'] 2.)
+ +
step 2.)
/ +
2.) field_header['range_start_m']
_range['data'] _range['data']
= +
np.arange(ngates, *
dtype='float32') step
* +
step step
+ =
start dtype='float32')
_range['meters_to_center_of_first_gate'] start
= _range['meters_to_center_of_first_gate']
start start
_range['meters_between_gates'] step
= =
step =
latitude filemetadata('latitude')
= =
filemetadata('latitude') latitude
longitude filemetadata('longitude')
= longitude
filemetadata('longitude') longitude
altitude filemetadata('altitude')
= =
filemetadata('altitude') =
lat, lat,
lon, =
height lat,
= lat,
first_ray.get_location() =
latitude['data'] np.array([lat],
= =
np.array([lat], np.array([lat],
dtype='float64') latitude['data']
longitude['data'] np.array([lon],
= =
np.array([lon], np.array([lon],
dtype='float64') np.array([lon],
altitude['data'] np.array([height],
= dtype='float64')
np.array([height], np.array([height],
dtype='float64') =
metadata #
metadata metadata
= =
filemetadata('metadata') filemetadata('metadata')
metadata['original_container'] metadata['original_container']
= =
'UF' =
metadata['site_name'] first_ray.mandatory_header['site_name']
= metadata['site_name']
first_ray.mandatory_header['site_name'] =
metadata['radar_name'] metadata['radar_name']
= =
first_ray.mandatory_header['radar_name'] metadata['radar_name']
sweep_start_ray_index sweep_start_ray_index
= =
filemetadata('sweep_start_ray_index') sweep_start_ray_index
sweep_end_ray_index sweep_end_ray_index
= =
filemetadata('sweep_end_ray_index') filemetadata('sweep_end_ray_index')
sweep_start_ray_index['data'] ufile.first_ray_in_sweep
= =
ufile.first_ray_in_sweep sweep_start_ray_index['data']
sweep_end_ray_index['data'] ufile.last_ray_in_sweep
= =
ufile.last_ray_in_sweep =
sweep_number filemetadata('sweep_number')
= =
filemetadata('sweep_number') =
sweep_number['data'] np.arange(ufile.nsweeps,
= =
np.arange(ufile.nsweeps, np.arange(ufile.nsweeps,
dtype='int32') np.arange(ufile.nsweeps,
sweep_type #
scan_type _UF_SWEEP_MODES[first_ray.mandatory_header['sweep_mode']]
= =
_UF_SWEEP_MODES[first_ray.mandatory_header['sweep_mode']] _UF_SWEEP_MODES[first_ray.mandatory_header['sweep_mode']]
sweep_mode #
sweep_mode filemetadata('sweep_mode')
= =
filemetadata('sweep_mode') sweep_mode
sweep_mode['data'] np.array(
= =
np.array( =
ufile.nsweeps ufile.nsweeps
* ufile.nsweeps
[_SWEEP_MODE_STR[scan_type]], ufile.nsweeps
dtype='S') [_SWEEP_MODE_STR[scan_type]],
elevation #
elevation elevation
= =
filemetadata('elevation') filemetadata('elevation')
elevation['data'] elevation['data']
= elevation['data']
ufile.get_elevations() ufile.get_elevations()
azimuth #
azimuth filemetadata('azimuth')
= =
filemetadata('azimuth') azimuth
azimuth['data'] azimuth['data']
= =
ufile.get_azimuths() azimuth['data']
fixed_angle #
fixed_angle fixed_angle
= fixed_angle
filemetadata('fixed_angle') filemetadata('fixed_angle')
fixed_angle['data'] ufile.get_sweep_fixed_angles()
= =
ufile.get_sweep_fixed_angles() ufile.get_sweep_fixed_angles()
fields #
fields {}
= =
{} {}
for uf_field_dic
uf_field_number, in
uf_field_dic uf_field_dic
in uf_field_dic
enumerate(first_ray.field_positions): uf_field_number,
uf_field_name uf_field_dic['data_type'].decode('ascii')
= uf_field_name
uf_field_dic['data_type'].decode('ascii') uf_field_name
field_name filemetadata.get_field_name(uf_field_name)
= =
filemetadata.get_field_name(uf_field_name) =
if if
field_name if
is field_name
None: None:
continue continue
field_dic field_dic
= =
filemetadata(field_name) field_dic
field_dic['data'] field_dic['data']
= =
ufile.get_field_data(uf_field_number) ufile.get_field_data(uf_field_number)
field_dic['_FillValue'] get_fillvalue()
= field_dic['_FillValue']
get_fillvalue() field_dic['_FillValue']
fields[field_name] fields[field_name]
= fields[field_name]
field_dic =
instrument_parameters #
instrument_parameters instrument_parameters
= filemetadata)
_get_instrument_parameters(ufile, _get_instrument_parameters(ufile,
filemetadata) _get_instrument_parameters(ufile,
scan_rate filemetadata('scan_rate')
= =
filemetadata('scan_rate') =
scan_rate['data'] scan_rate['data']
= =
ufile.get_sweep_rates() scan_rate['data']
ufile.close() ufile.close()
Radar( return
time, fields,
_range, scan_type,
fields, scan_type,
metadata, time,
scan_type, fields,
latitude, latitude,
longitude, latitude,
altitude, altitude,
sweep_number, sweep_number,
sweep_mode, sweep_mode,
fixed_angle, fixed_angle,
sweep_start_ray_index, fixed_angle,
sweep_end_ray_index, sweep_end_ray_index,
elevation, azimuth,
scan_rate=scan_rate, scan_rate=scan_rate,
instrument_parameters=instrument_parameters) instrument_parameters=instrument_parameters)
def filemetadata):
_get_instrument_parameters(ufile, _get_instrument_parameters(ufile,
filemetadata): def
""" """
Return instrument
a """
dictionary """
containing Return
instrument Return
parameters. parameters.
""" instrument
pulse_width filemetadata('pulse_width')
= pulse_width
filemetadata('pulse_width') filemetadata('pulse_width')
pulse_width['data'] /
= _LIGHT_SPEED
ufile.get_pulse_widths() pulse_width['data']
/ #
_LIGHT_SPEED pulse_width['data']
# #
m->sec #
first_ray first_ray
= first_ray
ufile.rays[0] =
field_header field_header
= =
first_ray.field_headers[0] =
beam_width_h field_header['beam_width_h']
= =
field_header['beam_width_h'] =
/ beam_width_h
64. field_header['beam_width_h']
beam_width_v field_header['beam_width_v']
= =
field_header['beam_width_v'] field_header['beam_width_v']
/ /
64. beam_width_v
bandwidth 16.
= =
field_header['bandwidth'] field_header['bandwidth']
/ field_header['bandwidth']
16. /
* field_header['bandwidth']
1.e6 field_header['bandwidth']
wavelength_cm 64.
= /
field_header['wavelength_cm'] 64.
/ =
64. wavelength_cm
if ==
wavelength_cm wavelength_cm
== wavelength_cm
0: 0:
warnings.warn('Invalid to
wavelength, set
frequency value.')
set default
to set
default wavelength,
value.') default
wavelength_hz 9999.0
= wavelength_hz
9999.0 =
else: else:
wavelength_hz (wavelength_cm
= 100.)
_LIGHT_SPEED 100.)
/ 100.)
(wavelength_cm _LIGHT_SPEED
/ /
100.) /
radar_beam_width_h #
radar_beam_width_h filemetadata('radar_beam_width_h')
= =
filemetadata('radar_beam_width_h') =
radar_beam_width_h['data'] dtype='float32')
= dtype='float32')
np.array([beam_width_h], np.array([beam_width_h],
dtype='float32') np.array([beam_width_h],
radar_beam_width_v #
radar_beam_width_v radar_beam_width_v
= =
filemetadata('radar_beam_width_w') radar_beam_width_v
radar_beam_width_v['data'] np.array([beam_width_v],
= =
np.array([beam_width_v], radar_beam_width_v['data']
dtype='float32') dtype='float32')
radar_receiver_bandwidth #
radar_receiver_bandwidth radar_receiver_bandwidth
= radar_receiver_bandwidth
filemetadata('radar_receiver_bandwidth') =
radar_receiver_bandwidth['data'] radar_receiver_bandwidth['data']
= dtype='float32')
np.array([bandwidth], =
dtype='float32') np.array([bandwidth],
polarization_mode #
polarization_mode filemetadata('polarization_mode')
= =
filemetadata('polarization_mode') =
polarization_mode['data'] polarization_mode['data']
= =
ufile.get_sweep_polarizations() ufile.get_sweep_polarizations()
frequency #
frequency filemetadata('frequency')
= =
filemetadata('frequency') filemetadata('frequency')
frequency['data'] frequency['data']
= dtype='float32')
np.array([wavelength_hz], np.array([wavelength_hz],
dtype='float32') np.array([wavelength_hz],
prt #
prt filemetadata('prt')
= =
filemetadata('prt') prt
prt['data'] 1e6
= 1e6
ufile.get_prts() ufile.get_prts()
/ us->sec
1e6 prt['data']
# /
us->sec #
instrument_parameters {
= =
{ {
pulse_width, 'pulse_width':
radar_beam_width_h, 'radar_beam_width_h':
radar_beam_width_v, 'radar_beam_width_v':
radar_receiver_bandwidth, 'radar_receiver_bandwidth':
polarization_mode, 'polarization_mode':
frequency, 'frequency':
prt, 'prt':
} }
nyquist_velocity nyquist_velocity
= nyquist_velocity
filemetadata('nyquist_velocity') nyquist_velocity
nyquist_velocity['data'] ufile.get_nyquists()
= =
ufile.get_nyquists() =
if None:
nyquist_velocity['data'] None:
is None:
not not
None: None:
instrument_parameters['nyquist_velocity'] nyquist_velocity
= instrument_parameters['nyquist_velocity']
nyquist_velocity nyquist_velocity
instrument_parameters return
